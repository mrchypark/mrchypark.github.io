[
  {
    "path": "post/distill로-옮깁니다/",
    "title": "distil로 옮깁니다",
    "description": "드디어 블로그를 단순하게 유지하기 위해 distill로 옮깁니다.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2021-01-28",
    "categories": [],
    "contents": "\n\nContents\nblogdown의 대안을 찾아서\ndistill 소개\n\nblogdown의 대안을 찾아서\nblogdown은 꽤 오랫동안 사용한 블로그 패키지다. 여전히 좋은 패키지라고 생각한다. blogdown 또한 rstudio에서 관리하며, 최근 버전 1.0.0 을 출시했다.\n대안이 필요한 이유는 blogdown 자체의 문제만은 아니지만, 여전히 문제다.\n한글 윈도우 rstudio 에서 빌드시 경로 문제가 발생할 때가 있다.\n캐쉬 동작을 이해하지 못해서 빌드 결과가 다르다.\nrstudio가 글 작성 도구로써 매우 좋다고 할 수 없다.\nrstudio가 글 작성 도구로써 매우 좋다고 할 수 없는 이유는, 우선 매우 무겁기 때문이다. 오죽하면 Rmd 전용 글 작성 도구만 따로 만들까 고민하던 적이 있기도 하다.(지금도 유효하다.)\ndistill 소개\ndistill 은 rstudio 의 패키지로\n\n# A tibble: 14 x 11\n     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb\n   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n 1  21       6 160     110  3.9   2.62  16.5     0     1     4     4\n 2  21       6 160     110  3.9   2.88  17.0     0     1     4     4\n 3  22.8     4 108      93  3.85  2.32  18.6     1     1     4     1\n 4  21.4     6 258     110  3.08  3.22  19.4     1     0     3     1\n 5  24.4     4 147.     62  3.69  3.19  20       1     0     4     2\n 6  22.8     4 141.     95  3.92  3.15  22.9     1     0     4     2\n 7  32.4     4  78.7    66  4.08  2.2   19.5     1     1     4     1\n 8  30.4     4  75.7    52  4.93  1.62  18.5     1     1     4     2\n 9  33.9     4  71.1    65  4.22  1.84  19.9     1     1     4     1\n10  21.5     4 120.     97  3.7   2.46  20.0     1     0     3     1\n11  27.3     4  79      66  4.08  1.94  18.9     1     1     4     1\n12  26       4 120.     91  4.43  2.14  16.7     0     1     5     2\n13  30.4     4  95.1   113  3.77  1.51  16.9     1     1     5     2\n14  21.4     4 121     109  4.11  2.78  18.6     1     1     4     2\n[1] \"heloe\"\n\n\n\n\n",
    "preview": {},
    "last_modified": "2021-05-05T05:34:03+00:00",
    "input_file": {}
  },
  {
    "path": "post/rtips-불리는-패키지가-없습니다-해결-방법/",
    "title": "[Rtips] 불리는 패키지가 없습니다 해결 방법",
    "description": "blogdown으로 옮겨서 시작합니다.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2020-01-11",
    "categories": [
      "R",
      "Rtips",
      "library",
      "package",
      "tech"
    ],
    "contents": "\n\n\n이라고 불리는 패키지가 없습니다.\n이 에러는 library()함수를 사용할 때 나오는 문구입니다. 정확히는 패키지가 설치되어 있지 않다고 알려주는 것이지요. 그래서 이 문제를 해결하는 가장 간단한 방법은 패키지를 설치하는 것입니다. 예를 들어 vars 라는 이름의 패키지를 사용해 보겠습니다.\ninstall.packages(\"vars\")\nlibrary(vars)\n언제나 깔끔하게 설치되면 좋겠지만, 문제가 발생하는 경우가 있습니다. 사실 경험이 부족한 입장에서는 인스톨 과정이 문제 없이 잘 끝났는지 인지하는 것도 쉬운 일이 아닙니다. 아래 스크린샷을 그 대표적인 예시입니다.\n\n커뮤니티에 조진형 님이 올려주신 질문입니다.\n스크린샷을 보아하니 설치 명령은 수행하셨지만 모종의 이유로 설치 과정에서 에러가 났습니다. 에러에 설명이 되어 있기는 한데, 영어다보니 이해하기가 쉽지 않습니다.\n필요한 문구는 library(vars) 명령어 이전 줄 중에 가장 마지막 줄입니다.\n\nTry removing 'c:\\Users\\enieh\\Documents\\R\\win-library\\3.6/00LOCK'\n\n저 언급한 경로의 00LOCK 파일을 지우고, 다시 설치해보라는 것인데요. 지금 설치가 실패한 패키지는 vars이긴 합니다만, 의존성이 있는 zoo 패키지가 실패한 것입니다. 그래서 00LOCK 파일을 지우면서도, 그 폴더가 패키지들이 설치되는 곳이니 zoo 폴더를 함께 지워줍니다. 이 후에 다시 패키지를 설치하면 문제없이 설치될 것 입니다.\n문제가 무엇이었나?\n항상 그런 것은 아니지만, zoo 패키지가 메모리에 올라가 사용 중인 상태였을 수 있습니다. 순수 R 코드로 이루어진 패키지들에게 생기는 문제는 아니고, cpp가 함께 있는 패키지에서 이런 문제가 있을 수 있는데요. 패키지를 메모리에 올려 사용하고 있는 상태에서는 패키지 폴더를 삭제할 수 없습니다. 파일을 사용 중인 상태이기 때문이죠.\n그래서 보통 패키지를 설치하려고 할 때 몇몇 패키지를 불러온 상태라면 재시작을 하고 설치할꺼냐고 물어보기는 합니다. 모든 잘못된 동작을 막기에는 부족한 것 같습니다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106514270-651d3c00-6517-11eb-8b5f-54dfb9c3470b.png",
    "last_modified": "2021-05-05T05:35:19+00:00",
    "input_file": {}
  },
  {
    "path": "post/correttor-r을-위해서-java를-설치해보자/",
    "title": "[correttor] R을 위해서 JAVA를 설치해보자",
    "description": "`multilinguer::install_java()`를 쓰세요.(MacOS는 컴퓨터 비밀번호가 필요)",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2019-08-10",
    "categories": [
      "R",
      "java",
      "rJava",
      "package",
      "correttor"
    ],
    "contents": "\n\n한줄요약\nmultilinguer::install_java()를 쓰세요.(MacOS는 컴퓨터 비밀번호가 필요)\n앞서 R에서 python을 설치해서 사용하기 위해 conda를 설치하는 방법을 살펴봤습니다. 이번에는 java입니다.(두둥)(엄근진)\njava를 설치하기 위해서 corretto 배포판을 선택했습니다. corretto 배포판의 설치를 지원하는 correttor 패키지는 Windows 32 bit, 64 bit, MacOS를 지원합니다.\nconda4r 패키지와 마찬가지로 correttor 패키지는 multilinguer 패키지군의 일원입니다.\nmultilinguer 패키지가 직접 인스톨 코드 등을 가지도록 개발하고 있습니다.\n이 포스트는 두말 않고 진행해보겠습니다.\n\n\n# install.packages(\"remotes\")\nremotes::install_github(\"mrchypark/multilinguer\")\nlibrary(multilinguer)\ninstall_java()\n\n\n\ninstall_java() 함수의 목표는 rJava를 설치하여 문제 없이 동작하게 만드는 것입니다. install_java() 함수는 현재 컴퓨터에 java가 설치되어 있는지 확인합니다. 없다면 설치를 시작합니다. Windows 에서는 사용자 계정 별 폴더에 corretto 폴더를 만들고 저장합니다. 그리고 유저 환경변수를 설정합니다. MacOS 에서는 /Library/Java/JavaVirtualMachines/ 경로에 java11 버전으로 명시하여 저장합니다. 말씀 드린 것 처럼, MacOS는 앞의 위치에 설치하기 위해서 컴퓨터 비밀번호가 필요합니다. 문제있는 동작은 없으니 걱정되시면 소스를 확인해 주세요.\n앞의 설치는 마지막에 재시작을 하고 rJava 패키지를 binary로 설치한 후 다시 재시작합니다. .jinit() 함수를 수행하면서 마무리를 하기 때문에 문제가 있다면 이 단계에서 에러를 출력합니다. 혹시 에러가 발생하면 꼭 알려주세요.\n위 설치로 바로 사용해 볼 수 있는 패키지는 역시 KoNLP 입니다.\n\n\ninstall.packages(\"KoNLP\")\nlibrary(KoNLP)\n\n\n\n## Checking user defined dictionary!\n위 메세지가 실행된다면, 자바를 사용하는 R 패키지를 문제없이 사용할 수 있는 상태가 되었다는 뜻입니다.\n현재 MacOS에서 R 버전이 3.5.X 버전일 때 문제가 있는 것을 파악했습니다.\ncorrettor 패키지 개발에 도움을 주신 많은 분들께 다시 한번 감사드립니다. 빨리 여러 곳에서 안정적으로 동작하는 패키지가 되도록 노력하겠습니다. 감사합니다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106564199-45663200-6570-11eb-894c-d89fa3c860f4.png",
    "last_modified": "2021-05-05T05:34:00+00:00",
    "input_file": {}
  },
  {
    "path": "post/conda4r-r을-위해서-conda를-설치해보자/",
    "title": "[conda4r] R을 위해서 conda를 설치해보자",
    "description": "`multilinguer::install_conda()`를 쓰세요. (응?)",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2019-07-31",
    "categories": [
      "R",
      "python",
      "reticulate",
      "conda",
      "conda4r",
      "package"
    ],
    "contents": "\n\nContents\nconda4r 패키지 개발을 중단합니다.\n\n\nconda4r 패키지 개발을 중단합니다.\nreticulate 패키지에 install_miniconda() 함수가 포함되기로 결정되어서 패키지 개발을 중단합니다.\nmultilinguer 패키지의 install_conda() 함수는 reticulate 패키지의 함수를 사용하는 것으로 변경 중입니다.\n블로그 내의 함수 동작도 우선은 전부 멈춰두었습니다. 이후 reticulate 패키지의 cran 버전에 포함되면 위 이야기대로 동작하도록 하겠습니다.\n한줄요약\nmultilinguer::install_conda()를 쓰세요. (응?)\nconda는 다양한 언어를 위한 패키지 매니저로 개발중입니다. anaconda로 익히 알려지면서 python 배포판의 일종으로 쓰이고 있습니다. 최근 파이썬은 딥러닝 프레임워크들의 인기에 힘입어 많은 사람들의 관심을 받고 있습니다. 개발과 연구라는 두 마리 토끼를 잡기 위해서 많은 프레임워크가 파이썬으로 개발되었습니다.\n이런 환경에서 R은 취약한 자체적인 프레임워크를 해결하기 위해 python을 품는 결정을 합니다. 그 결과로 나온 부산물이 reticulate 패키지입니다. Rstudio 팀은 tensorflow와 keras를 이용하기 위해서 reticulate 패키지를 개발합니다. 이는 놀라운 생산성으로 이어졌습니다. R 패키지는 python 패키지에서 api 변경만 따라가면 되는 상황이 되었습니다. 내부 로직을 전부 python 패키지에 위임함으로써 R 패키지의 유지보수관리에 혁신적인 효율성을 확보한 셈이죠.\n이 때 중요하게 권장하는 사항이 conda 패키지 매니저를 사용하는 것입니다. 헌데 R 사용자에게 다른 개발 언어를 설치하는 것은 어려운 일일 수 있습니다. 그 중에 conda 패키지 매니저는 매우 쉬운 축에 속합니다…만, 뭔가 화면 하나하나, 옵션 하나하나 어떤 것인지 아는 것은 확실히 어려운 일입니다. 그런거 다 알꺼면 왜 R로 스크립팅하나요…\n그래서 conda4r 패키지를 준비했습니다. conda4r 패키지는 Windows 32bit, 64bit, MacOS, Linux를 지원하는 miniconda를 설치하는 함수를 제공합니다.\n설치 방법\nconda4r 패키지는 R 사용자를 위한 다른 개발 언어 설치를 지원하는 프로젝트인 multilinguer 패키지군의 일원입니다. conda4r 패키지는 인프라로써 설치를 위한 개별 함수들을 제공합니다. multilinguer 패키지는 has_conda() 함수를 제공합니다. has_conda() 함수는 제가 할 수 있는 한의 테스트를 통해서 conda가 동작하는 상태를 만드는 것을 목표로 합니다.\n\n\n# install.packages(\"remotes\")\nremotes::install_github(\"mrchypark/multilinguer\")\n\n\n\n사용법\n위에 설명드린 대로 has_conda() 함수를 실행하면 끝입니다.\n\n\nlibrary(multilinguer)\nhas_conda()\n\n\n\n그럼 기존에 설치된 conda가 있는지 확인합니다. 있으면 그대로 종료, 아니라면 conda 설치를 시작합니다. 우선 다운로드 받고, 표준 경로에 miniconda를 설치합니다. Windows에서 ssl 관련된 문제가 있어 수정합니다. 그리고 conda 버전을 업데이트 합니다. 버전 업데이트를 진행하고 싶지 않다면 update 옵션을 FALSE를 주면 됩니다. 잘 됬는지 확인하기 위해 conda를 사용하는 패키지를 설치, 실행해 보겠습니다.\n\n\nremotes::install_github(\"haven-jeon/KoSpacing\")\n\n\n\nKoSpacing 패키지는 KoNLP 패키지의 개발자이신 고감자님이 만든 띄어쓰기 패키지입니다. python의 keras 패키지를 사용하기 때문에, 패키지를 사용하기 위해서 reticulate 패키지와 conda가 필요합니다.\n\n\nlibrary(KoSpacing)\n\n\n\nKoSpacing 패키지는 버전이 0.1.1 이상인지 꼭 확인하셔야 합니다. 이전 버전은 설치에 문제가 있어서 동작하지 않습니다.\n\n\npackageVersion(\"KoSpacing\")\n\n\n\nKoSpacing 패키지의 설치에서는 conda가 필요하지 않습니다만, library(KoSpacing)을 실행시 나오는 안내 문구처럼 set_env() 함수를 실행할 때 필요합니다. 앞서 has_conda()를 잘 실행하셨다면 이제 set_env() 실행할 때 문제가 생기지 않으면 좋을 것 같습니다.(응?)\n\n\nset_env()\n\n\n\n아마 위에 함수가 잘 끝나면 세션을 재시작할 것입니다. 이제 동작을 확인해보겠습니다.\n\n\nlibrary(KoSpacing)\nspacing(\"김형호영화시장분석가는'1987'의네이버영화정보네티즌10점평에서언급된단어들을지난해12월27일부터올해1월10일까지통계프로그램R과KoNLP패키지로텍스트마이닝하여분석했다.\")\n\n\n\n2019-08-10 03:28:32.102292: I T:\\src\\github\\tensorflow\\tensorflow\\core\\platform\\cpu_feature_guard.cc:141] Your CPU supports instructions that this TensorFlow binary was not compiled to use: AVX2\nloaded KoSpacing model!\n[1] \"김형호 영화시장 분석가는 '1987'의 네이버 영화 정보 네티즌 10점 평에서 언급된 단어들을 지난해 12월 27일부터 올해 1월 10일까지 통계 프로그램 R과 KoNLP 패키지로 텍스트마이닝하여 분석했다.\"\n첫 실행 이후에는 위 메세지 없이 결과만 출력합니다.\n잘 동작하시나요? 혹시라도 안되시는 분들은 댓글로 남겨주시면 감사하겠습니다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106564003-fe783c80-656f-11eb-948f-7896c100b4db.png",
    "last_modified": "2021-05-05T05:33:53+00:00",
    "input_file": {}
  },
  {
    "path": "post/rtips-윈도우-계정-한글일때-문제-해결하기-1탄-임시-폴더-위치-바꾸기/",
    "title": "[Rtips] 윈도우 계정 한글일때 문제 해결하기 1탄 임시 폴더 위치 바꾸기",
    "description": "blogdown으로 옮겨서 시작합니다.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2019-05-26",
    "categories": [
      "R",
      "Rtips",
      "temp",
      "tempdir"
    ],
    "contents": "\n\n한줄요약\nTemp(임시 폴더)의 위치를 .Renviron 파일에 써서 바꾸세요.\nKRSG에 질문글이 올라와서 아는 내에서 해결책을 공유하고자 합니다.\n우선 공유해 주신 에러 화면을 보겠습니다.\n\n우선 hist() 함수를 사용하는데, 에러가 발생한다고 문제를 공유해주셨습니다. 그림을 출력하기 위해서는 그림을 저장하고, 화면에 뿌리는 과정을 진행합니다. 위 과정을 프로그램(rstudio)이 진행해 주기 때문에 과정을 알 필요는 없는데요. 이 때 그림 저장을 임시 폴더에 합니다. 프로그램이 기본으로 사용하는 임시 폴더의 위치는 tempdir() 함수로 확인할 수 있습니다. 저의 컴퓨터는 아래 결과를 확인할 수 있었습니다.\n\n\ntempdir()\n\n\n\n[1] \"C:\\\\Users\\\\MRCHYP~1\\\\AppData\\\\Local\\\\Temp\\\\RtmpkNMIVs\"\n이 위치는 윈도우의 사용자 계정 이름(mrchypark)의 하위 폴더입니다. 저는 영어로 계정이름을 만들어서 문제 없이 동작하는데요. 질문자의 경우 저 경로에 ??????로 되어 있는 것으로 봐서 윈도우의 사용자 계정이 한글로 되어 있는 것 같습니다.\n가장 좋은 해결책은 윈도우 계정을 한글로 바꾸는 것이기는 한데요. 😭 현실적으로 다시 만들어서 다시 환경을 설정하는 것은 쉬운일이 아닙니다.\n그래서 임시 폴더 위치를 변경하는 방법을 소개합니다.\n우선 경로에 한글이 없을만한 임시 폴더를 하나 만듭니다. 저는 C:/에 바로 만들려고 합니다.\n\n\n\nC:/rtemp 라는 폴더를 만들었습니다. 이제 usethis 패키지를 설치합니다.\ninstall.packages(\"usethis\")\nusethis 패키지에는 R의 환경 변수를 관리하는 .Renvron 파일을 수정할 수 있게 열어주는 함수를 제공합니다.\n\n\nlibrary(usethis)\nedit_r_environ()\n\n\n\n그럼 .Renvron 파일을 수정할 수 있게 스크립트 창에서 열어줍니다.\n\n이제 아래 3줄을 .Renvron 파일에 저장합니다.\nTMPDIR=C:/rtemp\nTMP=C:/rtemp\nTEMP=C:/rtemp\n\n그리고 새션 재시작(ctrl+shit+F10)을 한 후 tempdir() 함수로 경로가 잘 변경되었는지를 확인합니다.\n이제 hist(iris$Sepal.Length) 같은 명령어로 동작하는지 확인합니다.\n\n이 방법은 프로그램이 사용하는 임시 폴더의 경로를 바꿈으로써 문제를 해결합니다. 그렇기 때문에 사용자의 계정 폴더를 사용하는 다른 문제에 대해서 해결하는지 알 수 없습니다. 혹시 위 방법으로도 비슷한 에러가 나오는 사례를 알려주시면 감사하겠습니다.\n감사합니다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106563781-a17c8680-656f-11eb-8578-fe866238dc8e.png",
    "last_modified": "2021-05-05T05:35:31+00:00",
    "input_file": {}
  },
  {
    "path": "post/josaplay-rmd로-만드는-한글-보고서의-친구/",
    "title": "[josaplay] Rmd로 만드는 한글 보고서의 친구",
    "description": "`을(를)` 이 눈에 거슬린다면 `josaplay`가 문제를 해결해 줄 겁니다.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2019-05-15",
    "categories": [
      "R",
      "josaplay",
      "package",
      "Rmd"
    ],
    "contents": "\n\n한줄요약\n을(를) 이 눈에 거슬린다면 josaplay가 문제를 해결해 줄 겁니다.\n개인적인 일들이 많이 있어서 정신을 못차리고 있는 중입니다. 데이터홀릭을 계속하는 만큼, R코홀릭도 좀 어떻게 해야할텐데 말이죠. 그동안 정기 보고서를 만들 때 한글만의 문제를 해결하는 패키지가 없어서 벼르고만 있었습니다만, 드디어 만들었습니다!\n이름하야 josaplay 패키지입니다.\n혹시 마우스을(를) 선택하셨습니다. 같은 멘트를 보신 적이 있으신가요? 앞의 단어가 어떤 것이 올지 결정나지 않았을 때, 그에 붙을 조사 또한 결정나지 않습니다. 위와 같이 경우를 다 작성해두는 선택을 한 사람들이 참 많습니다.\njosaplay 패키지는 이 때, 앞 단어의 마지막이 모음인지 자음인지를 보고 을/를 중 선택하여 출력해 줍니다.\n설치는 아래 코드를 사용하면 됩니다.\ninstall.packages(\"josaplay\")\n코드가 동작하는 것을 살펴볼까요?\n\n\nlibrary(josaplay)\n\njsp_gwawa(\"상품\")\n\n\n[1] \"상품과\"\n\njsp_gwawa(\"텀블러\")\n\n\n[1] \"텀블러와\"\n\njsp_eunneun(\"사랑\")\n\n\n[1] \"사랑은\"\n\njsp_eunneun(\"탁자\")\n\n\n[1] \"탁자는\"\n\njsp_iga(\"고객\")\n\n\n[1] \"고객이\"\n\njsp_iga(\"모니터\")\n\n\n[1] \"모니터가\"\n\njsp_eulleul(\"패키지\")\n\n\n[1] \"패키지를\"\n\njsp_eulleul(\"컵\")\n\n\n[1] \"컵을\"\n\njsp_iga(\"145\")\n\n\n[1] \"145가\"\n\njsp_iga(\"k146\")\n\n\n[1] \"k146이\"\n\n그럼 어떻게 쓰면 좋을까요? Rmd로 보고서 등을 작성할 때, 위처럼 코드청크를 사용하는 것이 아닌 경우가 있습니다. 백틱(`)을 하나만 사용하는 형식으로 인라인 코드를 작성할 수 있는데요. 이때 josaplay가 힘을 발휘합니다.\n\n\ndata1 <- \"병아리\"\n\n\n\n\n병아리이(가) 성장하였습니다.\n\n라고 작성하는 것을\n\n병아리가 성장하였습니다.\n\n로 고치면 data1의 글자에 따라 적절한 이/가를 선택해 출력해줍니다.\n앞으로 진행할 프로젝트에 적용할 생각을 하니 너무 즐겁네요. 한글이 들어간 자동화 보고서를 생성할 때 꼭 필요한 인프라 패키지를 만들게 되서 영광입니다.\n현재 josaplay는 4개의 함수에 완성형 한글과 숫자를 커버합니다. 자음 모음의 한글이나 영어, 특수문자는 아직 동작하지 않습니다. 영어 알파벳 발음에 대응하는 것은 필요한 일 같다는 생각이 듭니다.\n문의나 질문 사항은 언제나 환영합니다. 댓글로 문의 주시면 제가 할 수 있는 최대로 답변드리도록 노력하겠습니다. 감사합니다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106563544-43e83a00-656f-11eb-9629-f220d82e2792.png",
    "last_modified": "2021-05-05T05:34:21+00:00",
    "input_file": {}
  },
  {
    "path": "post/python과-r-어떤-걸-공부-해야-할까/",
    "title": "Python과 R 어떤 걸 공부 해야 할까",
    "description": "blogdown으로 옮겨서 시작합니다.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2019-03-20",
    "categories": [
      "R",
      "Python"
    ],
    "contents": "\n\n원글\n당신이 학생이라면, 회사에 들어가기 전에 충분히 숙달할 시간과 자신이 있다면 아무거나 해라. 두 언어 모두 기계의 효율성보다는 사람의 생산성을 우선하는 언어다.\n당신이 취업을 앞둔 학생이라면, Python을 해라. 어떤 직업이 되었건 R만 특화하여 명시적으로 뽑는 자리는 없지만, 반대는 매우 많다.\n당신이 직업이 있다면, 개발일이 더 적성에 맞는 것 같다면 Python을 배워라. Python은 범용 개발언어로서 당신이 Python을 할 줄 안다면 결국 개발자에 가까운 일을 하게 될 것이다.\n당신이 하는 일에 개발에 개자도 끼지 않을 것 같았는데, 그럴 기미가 보인다면 R을 공부해라. R은 그 어떤 언어보다도 직관적으로 이해하는 것을 중시한다. 평생 개발일은 안할 것같지만 업무에 30-40퍼센트 미만으로 필요할 것 같다면 R은 적은 시간을 공부하고도 많은 시간 공부한 것 같은 효과를 줄 것이다.\n당신이 머신 러닝 프로젝트를 많이 해야한다면 미안한 말이지만 둘다해라. 데이터를 다루는데는 R이, 머신러닝 모델 개발에는 Python이 좋다. 물론 지금 그렇다는거다. 미래를 보건데 충분한 지원을 받는 좋은 패키지는 거의 모든 언어에서 사용하는걸 목표로 한다. 대표적인 것이 xgboost 이다. 모두 해보고 마음가는걸 메인, 아닌걸 서브로 공부해라.\n당신이 딥러닝을 연구할 계획이라면 이 조언이 필요치 않다.\n당신이 딥러닝을 활용해보려면 R을 해라. R에는 이미 훌륭하게 Keras 패키지가 좋은 회사의 지원을 받으며 성장하고 있다. 왜 Python이 아니냐고 묻는다면 Python을 해야하는 사람들은 이미 스스로 판단할 능력을 가지고 있다.\n당신이 개발자라면 어떤 경우에서건 Python을 해라. 위에서 언급했듯 R은 직관에 가까운 언어기때문에 이미 다른 문법에 익숙해져 있다면 R은 괴상한 문법 체계인 것처럼 느껴질 것이다.\n당신이 숫자를 다루는 일을 한다면 R을 배워라. 어떤 언어든 부동소수점 문제나 다른 연산등의 문제에서 자유로울수 없지만, R은 참 많은 고려가 되어 있다.\n당신옆에 개발자가 있다면 위의 모든 것을 무시하고 Python을 배워라. 질문에 대답을 들을 수 있는 환경은 그 어떤 것보다 강력하다.\n페이스북에서 흥한 김에 기록용으로 포스트합니다.\n어떤 내용의 댓글도 환영합니다. 감사합니다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106563355-ff5c9e80-656e-11eb-84e0-439b14c1b9c1.png",
    "last_modified": "2021-05-05T05:34:38+00:00",
    "input_file": {}
  },
  {
    "path": "post/rtips-dbi-소스의-tbl의-요약-정보-확인하기-glimpse/",
    "title": "[rtips] DBI 소스의 tbl의 요약 정보 확인하기 glimpse()",
    "description": "src_dbi인 tbl의 str()을 확인할 때는 dplyr::glimpse() 함수를 사용하세요.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2019-01-25",
    "categories": [
      "R",
      "glimpse",
      "str",
      "tbl",
      "dbi",
      "dplyr"
    ],
    "contents": "\n\n한줄요약\nsrc_dbi인 tbl의 str()을 확인할 때는 dplyr::glimpse() 함수를 사용하세요.\nstr() 함수는 매우 유용합니다. 복잡한 데이터의 구조를 한눈에 보여주는 R의 효자 함수지요. 그런데 DBI을 이용한 table 객체를 사용할 때 문제가 있습니다.\n문제상황을 만들기 위해 sqlite를 사용해서 테이블을 만들어 보겠습니다.\n\n\nlibrary(DBI)\nlibrary(RSQLite)\nlibrary(dplyr)\ntb <- dbConnect(SQLite(), \":memory:\")\ntb\n\n\n<SQLiteConnection>\n  Path: :memory:\n  Extensions: TRUE\n\ncopy_to(tb, mtcars)\nmtcars_sql <- tbl(tb, \"mtcars\")       \n\n\n\n유용한 내장 데이터인 mtcars 데이터셋을 sqlite로 저장하고, dplyr::tbl() 함수로 테이블 객체를 불러왔습니다. 이제 데이터를 살펴볼 때 유용한 함수인 str()로 데이터를 확인해보겠습니다. 우선 R 객체인 mtcars를 확인해 볼까요?\n\n\nstr(mtcars)\n\n\n'data.frame':   32 obs. of  11 variables:\n $ mpg : num  21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...\n $ cyl : num  6 6 4 6 8 6 8 4 4 6 ...\n $ disp: num  160 160 108 258 360 ...\n $ hp  : num  110 110 93 110 175 105 245 62 95 123 ...\n $ drat: num  3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...\n $ wt  : num  2.62 2.88 2.32 3.21 3.44 ...\n $ qsec: num  16.5 17 18.6 19.4 17 ...\n $ vs  : num  0 0 1 1 0 1 0 1 1 1 ...\n $ am  : num  1 1 1 0 0 0 0 0 0 0 ...\n $ gear: num  4 4 4 3 3 3 3 4 4 4 ...\n $ carb: num  4 4 1 1 2 1 4 2 2 4 ...\n\n그리고 테이블 객체로 저장한 mtcars_sql을 확인해보겠습니다.\n\n\nstr(mtcars_sql)\n\n\nList of 2\n $ src:List of 2\n  ..$ con  :Formal class 'SQLiteConnection' [package \"RSQLite\"] with 8 slots\n  .. .. ..@ ptr                :<externalptr> \n  .. .. ..@ dbname             : chr \":memory:\"\n  .. .. ..@ loadable.extensions: logi TRUE\n  .. .. ..@ flags              : int 70\n  .. .. ..@ vfs                : chr \"\"\n  .. .. ..@ ref                :<environment: 0x7ffc512b2a90> \n  .. .. ..@ bigint             : chr \"integer64\"\n  .. .. ..@ extended_types     : logi FALSE\n  ..$ disco: NULL\n  ..- attr(*, \"class\")= chr [1:4] \"src_SQLiteConnection\" \"src_dbi\" \"src_sql\" \"src\"\n $ ops:List of 2\n  ..$ x   : 'ident' chr \"mtcars\"\n  ..$ vars: chr [1:11] \"mpg\" \"cyl\" \"disp\" \"hp\" ...\n  ..- attr(*, \"class\")= chr [1:3] \"op_base_remote\" \"op_base\" \"op\"\n - attr(*, \"class\")= chr [1:5] \"tbl_SQLiteConnection\" \"tbl_dbi\" \"tbl_sql\" \"tbl_lazy\" ...\n\n확실히 기대하는 모양이랑 좀 다릅니다. 테이블 객체 자체에 대한 정보를 보여주는군요.\n제가 다루는 db의 테이블들은 컬럼이 몇 십개씩 있거나 하기도 합니다.\ntibble 자료형이 매우 좋은 요약정보를 제공합니다만, 컬럼이 많아지면 한눈에 보기 불편한 문제가 있습니다.\n\n\nlibrary(nycflights13)\nflights\n\n\n# A tibble: 336,776 x 19\n    year month   day dep_time sched_dep_time dep_delay arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>\n 1  2013     1     1      517            515         2      830\n 2  2013     1     1      533            529         4      850\n 3  2013     1     1      542            540         2      923\n 4  2013     1     1      544            545        -1     1004\n 5  2013     1     1      554            600        -6      812\n 6  2013     1     1      554            558        -4      740\n 7  2013     1     1      555            600        -5      913\n 8  2013     1     1      557            600        -3      709\n 9  2013     1     1      557            600        -3      838\n10  2013     1     1      558            600        -2      753\n# … with 336,766 more rows, and 12 more variables:\n#   sched_arr_time <int>, arr_delay <dbl>, carrier <chr>,\n#   flight <int>, tailnum <chr>, origin <chr>, dest <chr>,\n#   air_time <dbl>, distance <dbl>, hour <dbl>, minute <dbl>,\n#   time_hour <dttm>\n\n이렇게 화면을 벗어나게 컬럼이 많으면 값들의 일부조차도 요약해서 보여주죠. 물론 컬럼 출력 옵션을 조정할 수 도 있습니다. 하지만 그런 커스텀이 많아지는걸 저는 좋아하지 않습니다.\n대신 dplyr::glimpse() 함수를 제공한다는 사실을 알게되었습니다. 대체 dbi src str 같은 검색을 죽어라 할 때는 없더니… 등잔밑이 어둡다가 정말 이럴때 쓰는 말인가 싶더군요.\n\n\nglimpse(mtcars_sql)\n\n\nRows: ??\nColumns: 11\nDatabase: sqlite 3.35.2 [:memory:]\n$ mpg  <dbl> 21.0, 21.0, 22.8, 21.4, 18.7, 18.1, 14.3, 24.4, 22.8, …\n$ cyl  <dbl> 6, 6, 4, 6, 8, 6, 8, 4, 4, 6, 6, 8, 8, 8, 8, 8, 8, 4, …\n$ disp <dbl> 160.0, 160.0, 108.0, 258.0, 360.0, 225.0, 360.0, 146.7…\n$ hp   <dbl> 110, 110, 93, 110, 175, 105, 245, 62, 95, 123, 123, 18…\n$ drat <dbl> 3.90, 3.90, 3.85, 3.08, 3.15, 2.76, 3.21, 3.69, 3.92, …\n$ wt   <dbl> 2.620, 2.875, 2.320, 3.215, 3.440, 3.460, 3.570, 3.190…\n$ qsec <dbl> 16.46, 17.02, 18.61, 19.44, 17.02, 20.22, 15.84, 20.00…\n$ vs   <dbl> 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, …\n$ am   <dbl> 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, …\n$ gear <dbl> 4, 4, 4, 3, 3, 3, 3, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 4, …\n$ carb <dbl> 4, 4, 1, 1, 2, 1, 4, 2, 2, 4, 4, 3, 3, 3, 4, 4, 4, 1, …\n\ndb를 소스로 사용하는 테이블 객체를 살펴볼 때 필수 함수가 아닐까 싶습니다. flights 데이터로 한번 더 비교하면서 글 마무리하겠습니다. 감사합니다.\n\n\ncopy_to(tb, flights)\nflights_sql <- tbl(tb, \"flights\")\nstr(flights_sql)\n\n\nList of 2\n $ src:List of 2\n  ..$ con  :Formal class 'SQLiteConnection' [package \"RSQLite\"] with 8 slots\n  .. .. ..@ ptr                :<externalptr> \n  .. .. ..@ dbname             : chr \":memory:\"\n  .. .. ..@ loadable.extensions: logi TRUE\n  .. .. ..@ flags              : int 70\n  .. .. ..@ vfs                : chr \"\"\n  .. .. ..@ ref                :<environment: 0x7ffc512b2a90> \n  .. .. ..@ bigint             : chr \"integer64\"\n  .. .. ..@ extended_types     : logi FALSE\n  ..$ disco: NULL\n  ..- attr(*, \"class\")= chr [1:4] \"src_SQLiteConnection\" \"src_dbi\" \"src_sql\" \"src\"\n $ ops:List of 2\n  ..$ x   : 'ident' chr \"flights\"\n  ..$ vars: chr [1:19] \"year\" \"month\" \"day\" \"dep_time\" ...\n  ..- attr(*, \"class\")= chr [1:3] \"op_base_remote\" \"op_base\" \"op\"\n - attr(*, \"class\")= chr [1:5] \"tbl_SQLiteConnection\" \"tbl_dbi\" \"tbl_sql\" \"tbl_lazy\" ...\n\nglimpse(flights_sql)\n\n\nRows: ??\nColumns: 19\nDatabase: sqlite 3.35.2 [:memory:]\n$ year           <int> 2013, 2013, 2013, 2013, 2013, 2013, 2013, 20…\n$ month          <int> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,…\n$ day            <int> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,…\n$ dep_time       <int> 517, 533, 542, 544, 554, 554, 555, 557, 557,…\n$ sched_dep_time <int> 515, 529, 540, 545, 600, 558, 600, 600, 600,…\n$ dep_delay      <dbl> 2, 4, 2, -1, -6, -4, -5, -3, -3, -2, -2, -2,…\n$ arr_time       <int> 830, 850, 923, 1004, 812, 740, 913, 709, 838…\n$ sched_arr_time <int> 819, 830, 850, 1022, 837, 728, 854, 723, 846…\n$ arr_delay      <dbl> 11, 20, 33, -18, -25, 12, 19, -14, -8, 8, -2…\n$ carrier        <chr> \"UA\", \"UA\", \"AA\", \"B6\", \"DL\", \"UA\", \"B6\", \"E…\n$ flight         <int> 1545, 1714, 1141, 725, 461, 1696, 507, 5708,…\n$ tailnum        <chr> \"N14228\", \"N24211\", \"N619AA\", \"N804JB\", \"N66…\n$ origin         <chr> \"EWR\", \"LGA\", \"JFK\", \"JFK\", \"LGA\", \"EWR\", \"E…\n$ dest           <chr> \"IAH\", \"IAH\", \"MIA\", \"BQN\", \"ATL\", \"ORD\", \"F…\n$ air_time       <dbl> 227, 227, 160, 183, 116, 150, 158, 53, 140, …\n$ distance       <dbl> 1400, 1416, 1089, 1576, 762, 719, 1065, 229,…\n$ hour           <dbl> 5, 5, 5, 5, 6, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6,…\n$ minute         <dbl> 15, 29, 40, 45, 0, 58, 0, 0, 0, 0, 0, 0, 0, …\n$ time_hour      <dbl> 1357034400, 1357034400, 1357034400, 13570344…\n\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106563142-b1e03180-656e-11eb-8501-f3729df21e9a.png",
    "last_modified": "2021-05-05T05:34:57+00:00",
    "input_file": {}
  },
  {
    "path": "post/2018년-회고/",
    "title": "2018년 회고",
    "description": "blogdown으로 옮겨서 시작합니다.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2019-01-04",
    "categories": [
      "blog",
      "retrospect"
    ],
    "contents": "\n\n벌써 1월이 되어 2019년입니다. 회고라는 걸 해봐야지 라고 생각하고 시간이 이렇게나 지나버렸네요. 2018년을 정리하고 되돌아보는 것이 중요한 시점이 되어서 늦게라도 작성해 보려고 합니다.\n원래 2018년 계획\n원래 2018년 계획은 건강이었습니다. 2017년 능력에 차지도 않은 강의를 진행하면서 무리한다는 생각을 많이 했었거든요. 그래서 2018년 계획은 엄청 단순하게 건강이었습니다. 헌데…\n일어난 일\n결혼 1년차와 아이, 이사\n결혼 1년차와 아이, 이사는 정말 많은 시간이 필요했습니다. 물론 제가 시간을 썼다기 보단, 정신없이 지나가 버렸다고나 할까요?\n이직\n이직이 있었습니다. 이직을 하는 바람에 원래 1년 계획이었던 음성 인식은 안드로메다로…(눈물) 챗봇으로 좋은 제안이 왔었는데, 이리저리 재보다가 지금의 회사로 결정했습니다. 회사에서 R을 사용하고 싶다는 욕구와, 챗봇에서 도망치고 싶은 마음이 겹쳤죠. 독특하게 재무팀에서 일을 하는 중입니다. 재무팀이 필요한 데이터를 찾고, 만들고, 사용하기 좋은 환경을 갖추려고 노력하고 있습니다. 물론 놀랍게도 감사를 경험하고 있는 중인데, 저에게 득인지 실인지 잘 모르겠네요.\n번역\n\n책을 하나 번역했습니다. 이건 17년에 벌린 일이니 최대한 빨리 마무리해보자는 생각에 결국 끝낼 수 있었습니다. 물론 5명이나 진행했고, 일을 벌린 것 이외에는 저는 한게 없는 활동이었습니다만. 덕분에 너무 좋은 분들과 협업하는 경험을 해보게 되었습니다. 제가 처음 코드 리뷰 프로세스를 코드가 아닌걸로 겪어보게 된 것이기도 하구요.\n기업 강의\n강의도 하나 했네요. 영우님이 너무 좋은 기회를 만들어 주셨습니다. 부족한 능력에 과분한 대접도 받아보고, 값진 경험이었습니다. 전업을 충분히 고민할만 하면서도, 여전히 부족하구나 라는 생각을 하게 되었습니다.\nAI 대회 참여\n\n네이버 ai 해커톤 2018(와… 레포를 날렸어?!)에 참가했습니다. 어떻게 딱 이직 타이밍이라 예선을 할 시간이 있었군요. 다행히 결선 범위에 들어갈 수 있게 되어서 춘천의 커넥트원도 구경할 수 있었습니다. 제 기억에 지식인 질문 유사도 문제에서 한 9등쯤 했던거 같은데…. 제가 무식하게 제꺼 기록 해둔 레포도 날렸네요. 덕분에 이런저런 고민을 했던 이벤트이기도 합니다. keras도 많이 쓰고, 그때 멘토셨던 경호님이 좋게 봐주셨던 기분좋은 일도 있었죠.\n블로그\n어영부영 블로그를 열심히 했습니다. blogdown이란 신박한 패키지가 드디어 불을 질렀다고나 할까요. 버려진 워드프레스, 텀플러 등등을 거쳐 드디어 안착하고 18년엔 26개 포스트를 작성했네요.\n\n1년 동안 방문자는 17,466명 입니다. 재방문자 비율이 33% 쯤 되는군요.\n\n블로그에 붙어 있는 광고로 총 16.16 달러를 벌었군요. 압도적인 1등 컨텐츠는 R 크롤링에 대한 발표자료입니다. 아마 검색에 잘 걸려서지 않을까 싶습니다. 2번째는 번역이고, 개발 관련 글이다 보니 독자층이 좀더 넓은 편이었던 것 같습니다. 상위에 실제 18년 포스트는 4건이 있군요.\n\n쓰면서 느꼈던 점은, 최대한 원소스 멀티유즈 하자였습니다. 새롭게 컨텐츠를 기획하지 말고 있는 컨텐츠를 발산해야 컨텐츠 생산성이 좋다 느껴졌습니다.\n패키지\n관리하는 패키지에 변화도 좀 있었고, 새로 만든 것들도 있었습니다. 우선 드디어 DNH4에 댓글 수집 기능이 들어갔습니다. 덕분에 서비스에서 키를 관리하는 다른 방법을 배울 수 있었구요. 이 배움은 뭔가 기록을 남기고 싶은데, 그냥 삽질한거라 잘 모르겠네요. 아마 최근 시작한 유튜브로 한번 리마인드해보면 좋겠다는 생각이 듭니다. (네이버(N2H4)와 다음 뉴스의 댓글은 이제 셀레늄 쓰지 않고 빠르게 수집할 수 있으니 많이 사랑해주세요.)\npresidentSpeechKr 패키지는 한글 설명을 제거한 presidentSpeech 패키지로 우선 변환하였습니다. 윈도우에서 나는 경고와 같은 에러는 역시 사용하는데 많이 불편하더라구요. 우선 이 문제를 Rstudio 1.3 버전 마일스톤으로 이슈를 제기한 것으로 만족하려고 합니다. 참고로 Rstduio 현재 안정화 버전은 1.1.463입니다. (네.. 언제 될지 알 수 없단 뜻이죠…)\n나머지는 대부분 데이터 패키지이고, 야심차게 시작한 건 DBF입니다. 물론 개념만 겨우 확인한 패키지이지만, 개인적인 쓸모에 의해 만들어서 그런가 아주 애정이 갑니다. 이제 잘 다듬고, 워크플로우에 잘 녹여 사용해야겠죠.\n또 메일 서버가 세팅되어 있으면 좋겠지만, 없는 곳에서 사용하려고 sendgridr를 만들었습니다. 최초로 클래스 개념으로 패키지를 작성해봤는데, 많은 공부를 할 수 있었어요. 잘 활용하면 if 지옥을 좀 벗어날 수 있을 것 같은 가능성을 봤습니다.\n발표자료\n18년은 건강! 쉬자! 라고 생각한 만큼 발표는 전혀 생각하고 있지 않았습니다. 헌데 어영부영 2번이나 하고 말았습니다.\n데이터야 놀자에서 R과 redshift를 항해할 때 알아야할 상식사전(+협업) 라는 제목으로 한번 했구요. IBM 개발자 컨퍼런스에서 R로 만든 머신러닝 모델을 api로 제공하기 라는 제목으로 다른 한번을 했습니다. 무슨 부귀영화를 누리겠다고, 내용을 두개나 만들었는지… 덕분에 둘 다 부실부실해서 안타깝기만 합니다.\n유튜브\n\n여름쯤 시작하려고 했던 유튜브를 기어이 시작했습니다. 12월 18일에 첫 영상를 촬영하고, 오늘 1월 4일 기준 구독자 100명이 되었습니다. 데이터 패키지를 만드는 영상은 여러분이 도와주셔서 100건이 넘는 조회수를 기록했습니다. 7건의 동영상을 업로드했고, 4건을 한시간씩 하는 무서운 짓을 해버렸습니다. 시작하자마자 어디 아프고 해서 매일하겠다는 다짐을 지키질 못했네요.\n회사일\n뭔가 프로젝트스럽게 딱 끝낸게 있으면 좋을텐데 아쉽게도 그렇게 하지 못했습니다. 전부 다 진행 중이기만 하고, 속시원히 마무리한게 아직 없네요. 새해에는 상상하고 있는 그림이 잘 구현되었으면 좋겠습니다.\n새해 다짐\n우선 크게 3가지 정도 생각하고 있는데요.\n첫째는 역시 건강입니다. 지난 한해는 건강을 생각만 했다면, 올해는 구체적인 계획을 세워볼까 해요. 운동 계획과 치과 진료 계획을 세우고 실행하는 것이 목표입니다.\n둘째는 유튜브 입니다. 광고수익을 나눌 수 있는 최소 기준이 구독자 1,000명입니다. 구독자를 1,000명 모으는 것. 아마도 중요한 목표가 될 것 같습니다.\n셋째는 다시 회사 일입니다. 역시 업으로 삼고 해야 스스로의 성장에도 도움이 되는 법입니다. 현실적인 계획으로 작고, 빠르게 실행하는 걸 새롭게 다짐해보려고 합니다. 기왕하는거 다시 기록도 좀 잘 해서, 일마다 분석하고 회고할 수 있게 하려구요.\n+알파를 추가하자면 go를 공부하는 겁니다. 이번엔 좀 진짜 해서 손에 익으면 좋겠다 생각하고 있습니다.\n이렇게 회고글을 써보니 19년은 회고를 위해서 기록을 좀 열심히 해야 겠다는 생각이 들었습니다. 페이스북 글 분석 같은거로 거창하게 해볼까 하다가, 뭐든 시간이 걸리면 될 것도 안된다는 마음으로 임하고 있습니다.\n\n더 작고 더 빠르게\n\n아무리 되뇌어도 적응하기 쉽지 않네요.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106562771-24044680-656e-11eb-8576-052a795b24c4.png",
    "last_modified": "2021-05-05T05:33:38+00:00",
    "input_file": {}
  },
  {
    "path": "post/rtips-사륜안-패키지로-rmd-실시간-결과-preview-확인하기/",
    "title": "[Rtips] 사륜안 패키지로 Rmd 실시간 결과(preview) 확인하기",
    "description": "Rmd 작성할 때 `xaringan::inf_mr()` 실행하고 작업하세요.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2018-12-06",
    "categories": [
      "R",
      "xaringan",
      "rmd",
      "preview"
    ],
    "contents": "\n\n\n\n한줄요약\nRmd 작성할 때 xaringan::inf_mr() 실행하고 작업하세요.\n오타쿠 감성 넘치는 이름의 패키지 xaringan(사륜안)은 이름과는 완전히 무관하게 Web Presentation 도구입니다. 제 발표자료는 전부 이 패키지를 활용했다고 해도 과언이 아닌데요. xaringan 패키지에는 발표자료를 작성할 때 유용한 함수를 제공합니다. 바로 xaringan::inf_mr() 입니다.\n실시간 프리뷰 보기\nmarkdown은 매우 광범위하게 사용되는 문서 양식입니다. Rstudio에서는 R의 코드 청크를 실행하여 markdown 문서에 결과를 추가하여 작성하는 Rmd 양식을 지원합니다. 주피터 노트북과 비슷하다고 할 수 있습니다. 물론 저는 R과 Rmd가 익숙할 뿐입니다. ㅎㅎ\nRmd는 여러 패키지의 열열한 지원에 힘입어 많은 양식을 결과물로 내놓을 수 있게 되었습니다. 여러 Web Presentation 발표자료 도구들이 나왔지만, 저는 xaringan가 가장 마음에 들더군요. 가장 마음에 든 기능이 실시간 프리뷰 함수를 제공하는 것이었습니다.\nxaringan::inf_mr() 함수를 실행하면 xaringan을 결과물로 만드는 Rmd 파일을 저장할 때 마다 실시간 프리뷰를 보여줍니다! 가장 기가 막힌 부분은 지금부터인데요. 이게 모든 Rmd 형식에서 지원합니다! 물론 html이 결과물 양식일 때 입니다.\nRmd 파일을 실시간 프리뷰를 보면서 작업하기\nxaringan::inf_mr() 함수는 Rmd 파일이 저장될 때 마다 자동으로 knitr::render() 함수를 실행해서 결과를 보여주는 효과가 있습니다. 아래 gif는 중간 제목에 test 글자를 추가하는 과정을 보여줍니다.\n\n\n\nxaringan::inf_mr() 함수는 Addin을 제공하고 있어서 Knit 버튼처럼 클릭으로 진행할 수도 있습니다. 아 설치방법이 궁금하실 수도 있을 것 같습니다. xaringan은 github에서의 설치만을 지원합니다.\n# remotes 패키지가 없다면 아래 패키지 설치 함수를 실행해주세요.\n# install.packages(\"remotes\")\nremotes::install_github('yihui/xaringan')\n이후에는 Rmd 파일을 작성하실 때 gif 같이 사용하시면 됩니다.\n감사합니다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106562406-97f21f00-656d-11eb-8bfe-e9caa338d2c9.png",
    "last_modified": "2021-05-05T05:35:26+00:00",
    "input_file": {}
  },
  {
    "path": "post/usehelp-r의-help-글을-포스트에서-활용하기/",
    "title": "[usehelp] R의 help 글을 포스트에서 활용하기",
    "description": "다른 좋은 접근이 많아서 개발을 중지하였습니다. 포스트나 발표자료에서 함수를 설명할 일이 많아서 `usehelp`라는 패키지를 만들었습니다.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2018-11-26",
    "categories": [
      "R",
      "usehelp",
      "package",
      "blog"
    ],
    "contents": "\n\nContents\n업데이트\n\n\n업데이트\n다른 좋은 접근이 많아서 개발을 중지하였습니다.\n한줄요약\n포스트나 발표자료에서 함수를 설명할 일이 많아서 usehelp라는 패키지를 만들었습니다.\n저는 R 언어를 매우 사랑합니다. 이미 문법이 익숙해서, 다른 걸 사용하는게 매우 불편하죠. 이 블로그도 blogdown 패키지를 이용하고 있고, 발표자료는 xaringan으로 만들어 공유합니다. 포스트를 작성할 때 마다 대문 이미지를 계속 넣어왔는데요. img 태그를 쓰다가 결국, htmltools로 바꿨습니다. 아주 마음이 편하네요. ㅎㅎㅎ 잠시 딴길로 샜는데, 어쩄든 포스트나 발표자료를 R로 만들다 보니, 함수 설명할 일이 매우 많습니다.\n매번 제가 직접 작성하고 있었는데… 생각해보니 설명서에 제목이며, 설명이며 다 있는 겁니다! 그래서 그 텍스트를 가져와서 출력해주는 패키지를 생각해보게 되었습니다.\nusehelp\n당장 가볍게 만들다보니, 설명서의 텍스트를 R 객체로 가져오는 선에서 끝나고 있습니다. 이제 시작인 셈인데요. github 버전만 있어서 우선 remotes::install_github() 함수로 설치해야 합니다.\n\n\nremotes::install_github(\"mrchypark/usehelp\")\n\n\n\n그럼 이제 사용해 봅시다.\n\n\nlibrary(usehelp)\nget_help(\"usehelp\",\"get_help\")\n\n\n{html_document}\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\n[1] <head>\\n<title>R: get help<\/title>\\n<meta http-equiv=\"Content-T ...\n[2] <body>\\n\\n<table width=\"100%\" summary=\"page for get_help\"><tr>\\ ...\n\nget_help() 함수는 패키지 이름, 함수 이름을 받아 help의 글자를 전부 가져와서, help 클래스로 만듭니다. help 클래스의 출력를 조정해야 하지만, 이제 0.0.0.9000 버전일 뿐이니 우선 넘어가죠. help 클래스라고 했는데, 지금 모양은 xml_document 입니다. 여러 양식으로 제공해주던데, 제가 다루기 쉬운 xml로 처리하기로 했습니다. 일부 데이터를 가져오는 것은 당연히 rvest를 사용했습니다.\n\n\nget_help(\"usehelp\",\"get_help\") %>% \n  get_title()\n\n\n[1] \"get help\"\n\n그래서 필요한 글자를 가져오는 함수들은 전부 rvest를 덮어서 만들었습니다. 아직은 title과 description, usage 만 있지만 차츰 추가해 나가겠습니다.\n향후 계획\n우선 포스트와 발표자료에 예쁘게 사용하기 위해 html 출력을 추가할 계획입니다. help 클래스의 콘솔 출력도 조정해야 할 것 같구요. 마지막으로 가능하다면 번역기를 붙여서 한글자료 만들 때 어설픈 채로라도 사용할 수 있게 조정해볼 계획입니다.\n마지막은 정말 희망사항이네요 ㅎㅎ\n여기까지 usehelp 패키지 소개였습니다. 아직 사용할 수준은 아니지만, 사용하시게 되면 이슈나 PR 대환영입니다. 콘솔 출력과 html 형태 삽입만 마무리되면 cran에 등록할 계획입니다.\n감사합니다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106562157-3fbb1d00-656d-11eb-8c40-6740e14ecc1f.png",
    "last_modified": "2021-05-05T05:36:04+00:00",
    "input_file": {}
  },
  {
    "path": "post/회고-tqk-업데이트-수정-종가-반영-및-param-조정/",
    "title": "[회고] tqk 업데이트 수정 종가 반영 및 param 조정",
    "description": "blogdown으로 옮겨서 시작합니다.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2018-11-22",
    "categories": [
      "R",
      "tqk",
      "adjusted",
      "announce"
    ],
    "contents": "\n\n이번 0.1.0 버전 업데이트는 다음 소스 추가로 인한 속도 향상 및 수정주가 반영입니다. 거기에 tq_get()함수를 모방하기로 한 주제에 param 설계가 달라서 맞춰주는 작업을 수행했습니다.\n배운 점\n새롭게 json을 처리하면서 purrr::transpose(), dplyr::select_if()를 알게 되었습니다. json을 tibble::as_tibble() 로 처리한 후 tidyr::unnest() 시 발생하는 문제의 원인을 알게 되었습니다.\ntibble자료형과 as_tibble() 함수\ntibble, tbl 자료형은 현대적인 R을 사용하는데 근간이 되는 자료형입니다. base R의 data.frame의 현대적 버전이라고 할 수 있는데요. 매우 많은 장점이 있습니다.\n우선 dim(), head(), class() 개별 컬럼의 class()가 객체를 출력하는 것으로 한번에 해결됩니다. 출력량도 화면에 기반하여 제한하고 있어서, 많은 출력으로 멈추거나 하는 문제를 사전에 방지하고 있습니다. 좀 불편하다면, 컬럼도 출력 제한을 한다는 점 정도 인데요.\n보통 matrix 나 data.frame을 tibble 자료형으로 바꾸려면 as_tibble() 함수를 사용합니다. json으로 들어온 list는 웹 데이터를 다룰 때 많이 겪게 되는데요. 2단 구조의 list일 때 as_tibble()이 동작한다면 아주 편할 것 같습니다.\n예를 들어 보겠습니다.\n\n\ncol_first_list <- list(a = list(1, 2, 3), b = list(4, 5, 6))\ncol_first_list\n\n\n$a\n$a[[1]]\n[1] 1\n\n$a[[2]]\n[1] 2\n\n$a[[3]]\n[1] 3\n\n\n$b\n$b[[1]]\n[1] 4\n\n$b[[2]]\n[1] 5\n\n$b[[3]]\n[1] 6\n\n2단 구조를 만들 때 헷갈리지 않기 위해서 1단은 이름을 지어서, 2단은 이름없이 2단 list를 만들었습니다. 간단히 대응하면 1,2,3 데이터를 가지는 a 컬럼과 4,5,6 데이터를 가지는 b 컬럼의 table일 수 있을 것 같습니다. 컬럼 단위로 묶어서 데이터를 보냈으므로, 저는 col_first_list라고 이름지어 봤습니다.\n\n\nlibrary(dplyr)\ncol_first_list %>% \n    tibble::as_tibble()\n\n\n# A tibble: 3 x 2\n  a         b        \n  <list>    <list>   \n1 <dbl [1]> <dbl [1]>\n2 <dbl [1]> <dbl [1]>\n3 <dbl [1]> <dbl [1]>\n\n음… tibble로는 된거 같은데, 뭔가 이상합니다. 찾아보니 tibble은 컬럼의 자료형이 list가 가능하더라구요. 그럼 평소에 알고 있는 모습으로 바꾸는 작업이 필요할 것 같습니다.\n새롭게 배운 함수 1 tidyr::unnest()\nNest and unnest\n\nDescription\nNesting creates a list-column of data frames; unnesting flattens it back out into regular columns. Nesting is implicitly a summarising operation: you get one row for each group defined by the non-nested columns. This is useful in conjunction with other summaries that work with whole datasets, most notably models.\n\nLearn more in vignette(\"nest\").\n\nUsage\nnest(.data, ..., .key = deprecated())\n\nunnest(data, cols, ..., keep_empty = FALSE, ptype = NULL,\n  names_sep = NULL, names_repair = \"check_unique\",\n  .drop = deprecated(), .id = deprecated(), .sep = deprecated(),\n  .preserve = deprecated())\n제목과 설명을 보면 딱 필요한 함수 같아 보입니다. 한번 사용해 볼까요?\n\n\ncol_first_list %>% \n  tibble::as_tibble() %>% \n  tidyr::unnest()\n\n\n# A tibble: 3 x 2\n      a     b\n  <dbl> <dbl>\n1     1     4\n2     2     5\n3     3     6\n\n깔끔하게 결과가 나왔습니다.\n하지만 보통 json을 웹서비스에서 받을 때 반대로 되어 있는 경우가 많습니다.\n\n\nrow_first_list <- list(list(a = 1, b = 4), list(a = 2, b = 5), list(a = 3, b = 6))\nrow_first_list\n\n\n[[1]]\n[[1]]$a\n[1] 1\n\n[[1]]$b\n[1] 4\n\n\n[[2]]\n[[2]]$a\n[1] 2\n\n[[2]]$b\n[1] 5\n\n\n[[3]]\n[[3]]$a\n[1] 3\n\n[[3]]$b\n[1] 6\n\n\n\nrow_first_list %>% \n    tibble::as_tibble()\n\n\nError: Columns 1, 2, and 3 must be named.\n\n우선 tibble::as_tibble()이 바로 처리 해주지를 못합니다. 컬럼은 이름이 있어야만 한다는 군요. 이때 purrr::transpose() 가 필요합니다.\n새롭게 배운 함수 2 purrr::transpose()\nTranspose a list.\n\nDescription\nTranspose turns a list-of-lists \"inside-out\"; it turns a pair of lists into a list of pairs, or a list of pairs into pair of lists. For example, if you had a list of length n where each component had values a and b, transpose() would make a list with elements a and b that contained lists of length n. It's called transpose because x[[1]][[2]] is equivalent to transpose(x)[[2]][[1]].\n\nUsage\ntranspose(.l, .names = NULL)\n\n\nrow_first_list %>% \n    purrr::transpose() %>% \n    tibble::as_tibble() %>% \n    tidyr::unnest()\n\n\n# A tibble: 3 x 2\n      a     b\n  <dbl> <dbl>\n1     1     4\n2     2     5\n3     3     6\n\n이렇게 2단 으로 구성된 json 파일은 쉽게 tibble 자료형으로 고쳐서 R에서 다룰수 있습니다.\ntidyr::unnest() 함수의 문제점\n이제 얼마든지 json 데이터를 사용하기 좋게 tibble로 바꿀 수 있게 된 것 같았습니다. (2단 구성이라면 말이지요.) 하지만 어찌된 일인지 상황에 따라 에러가 계속 발생하더군요. 찾아보니 컬럼에 null이 있을 때가 문제였습니다. list 자료형은 그대로 null을 가지고 있는 반면, tidyr::unnest()가 동작할 때 null이 없어져서 다른 컬럼과 갯수가 맞지 않게 되는 것이었습니다.\n\n\ninclud_null <- list(a = list(1, 2, 3), b = list(4, NULL, 6.5))\ninclud_null %>% \n  tibble::as_tibble()\n\n\n# A tibble: 3 x 2\n  a         b        \n  <list>    <list>   \n1 <dbl [1]> <dbl [1]>\n2 <dbl [1]> <NULL>   \n3 <dbl [1]> <dbl [1]>\n\n이렇게 tibble::as_tibble() 함수는 null을 유지한 채로 동작했습니다. 하지만 tidyr::unnest()은 처리하지 못하고 에러가 발생하네요.\n\n\ninclud_null %>% \n  tibble::as_tibble() %>% \n  tidyr::unnest()\n\n\n# A tibble: 3 x 2\n      a     b\n  <dbl> <dbl>\n1     1   4  \n2     2  NA  \n3     3   6.5\n\n또 전체가 null인 컬럼도 있으면 안됩니다.\n\n\nall_null <- list(a = list(1, 2, 3), b = list(NULL, NULL,NULL))\nall_null %>% \n  tibble::as_tibble()\n\n\n# A tibble: 3 x 2\n  a         b     \n  <list>    <list>\n1 <dbl [1]> <NULL>\n2 <dbl [1]> <NULL>\n3 <dbl [1]> <NULL>\n\nall_null %>% \n  tibble::as_tibble() %>% \n  tidyr::unnest()\n\n\nError: `b` must be a data frame column\n\n이 두 가지는 다른 처리방법을 사용해야 할 것 같습니다. 전체가 null인 컬럼은 제거하고, 일부가 null인 컬럼은 null을 다른 값으로 대체해야 겠네요. 전체가 null인 컬럼 이름을 하드코딩할 수도 있겠지만, 찾아서 제거하는 것이 더 좋아보였습니다.\n새롭게 배운 함수 3 dplyr::*_if()\ndplyr 패키지에는 muate() 함수나 select() 함수 뒤에 _if()가 붙은 조건 계열의 함수가 있습니다. 이걸 이용해서 컬럼내 데이터가 전체 null인 것을 제외하고 select() 하겠다가 가능할 것 같습니다.\n\n\nnulls_party <- list(a = list(1, 2, 3), \n                    b = list(NULL, NULL,NULL),\n                    c = list(NULL, 1,2),\n                    d = list(1,NULL,NULL),\n                    e = list(1,NULL,3))\nnulls_party %>% \n  tibble::as_tibble() %>% \n  dplyr::select_if( ~ !all(is.null(unlist(.x))))\n\n\n# A tibble: 3 x 4\n  a         c         d         e        \n  <list>    <list>    <list>    <list>   \n1 <dbl [1]> <NULL>    <dbl [1]> <dbl [1]>\n2 <dbl [1]> <dbl [1]> <NULL>    <NULL>   \n3 <dbl [1]> <dbl [1]> <NULL>    <dbl [1]>\n\n조금 복잡한데요. ~은 익명 함수를 작성하는 줄임표현입니다. ~ sum(.x)는 funcion(x) sum(x)와 같은 표현이죠. !는 논리형을 반대로 바꿔라는 뜻이구요. all() 함수는 is.null() 함수는 데이터가 null인지를 확인하는 함수 입니다. select_if() 함수 내에서 익명 함수 문법을 사용하게 되면, .x는 컬럼을 뜻하게 됩니다. 지금은 컬럼이 리스트기 때문에 unlist()로 vector로 바꾸었습니다.\n그럼 설명해보면\n... %>% \n  dplyr::select_if( ~ !all(is.null(unlist(.x))))\nselect_if(): 조건에 맞는 것만 선택할꺼야. ~: 함수를 조합해야 하니까 익명함수를 쓸께. !: 뒤에 논리형 결과가 나오면 반대로 바꿔줘. all(): 안에 모두가 TRUE면 TRUE하나를, 하나라도 아니라면 FALSE를 반환해. is.null: 값이 NULL이면 TRUE를 주세요. unlist(): list 자료형을 vector로 풀어줘. .x: 익명 함수에서 입력을 대표해.\n입니다.\n그러고 보니…\n... %>% \n  dplyr::select_if(~ .x %>% unlist() %>% is.null() %>% all() %>% !.)\n이렇게 해도 되는군요. 조금 가독성이 좋아졌습니다.\n이제 전체 NULL인 컬럼을 제거 했으니, 일부가 NULL인 경우 우선 0으로 대체 해보겠습니다.\nmap’s party\n우선 결론 먼저 쓰고 시작해보면,\n\n\nnulls_party %>% \n  tibble::as_tibble() %>% \n  dplyr::select_if(~ .x %>% unlist %>% is.null %>% all %>% !.) %>% \n  purrr::map_dfc(~ .x %>% purrr::map(is.null) %>% ifelse(0,.x) %>% unlist())\n\n\n# A tibble: 3 x 4\n      a     c     d     e\n  <dbl> <dbl> <dbl> <dbl>\n1     1     0     1     1\n2     2     1     0     0\n3     3     2     0     3\n\n입니다.\n새롭게 배우게 된 함수는 purrr::map_dfc() 였습니다.\npurrr::map()함수는 기본적으로 list를 인풋으로 받습니다. 결과도 마찬가지로 list를 출력해줍니다.\n복잡하게 결과가 나와야 한다면, 전처리를 따로 하기위해서 list 아웃풋은 좋은 선택입니다. 하지만 vector로 나올법한 결과(ex> sum()같이 개별 리스트당 하나의 결과가 나오거나 하는 등)라면 vector로 아웃풋이 나와도 좋을 것 같습니다.\n그렇게 해주는 함수가 purrr::map_*()계열 함수입니다. * 에는 lgl, dbl, chr같이 자료형이 들어가 있죠. 당연한 설계입니다. vector는 모든 요소가 같은 자료형이어야 하니까요.\n그럼 data.frame 형태로 받을수는 없을까요? 찾아보니 purrr::map_df*()가 그 역할을 하더라구요. 그냥 df와 dfr, dfc 3개의 접미사를 제공합니다. dfr과 dfc는 각각 데이터를 row 방향과 col 방향으로 합치겠다는 뜻입니다.\nmap()함수는 data.frame 자료형에서 기본적으로 col을 list 처럼 받아서 처리합니다. 그럼 각 컬럼별로 개별 요소에 NULL이 있는지 확인하고 만약 NULL이라면 0으로 바꿔라 라고 해보겠습니다.\n... %>% \n  purrr::map_dfc(~ .x %>% purrr::map(is.null) %>% ifelse(0,.x) %>% unlist())\n이것도 조금 어렵네요… 우선 골치 아파지는 이유가 각 컬럼이 list이기 때문입니다. map()을 이중으로 써야 하는군요.\npurrr::map_dfc()는 위에서 충분히 설명한 것 같습니다. 그러면 익명함수 다음부터 확인해 볼 껀데요.\n각 컬럼내의 list요소가 각각 NULL인지 확인합니다. 이때! purrr:map()때문에, .x가 각 컬럼을 대표하지 않고, 각 셀을 대표하는 상태로 변합니다.\n\n\nmaps_party <- nulls_party %>% \n  tibble::as_tibble() %>% \n  dplyr::select_if(~ .x %>% unlist %>% is.null %>% all %>% !.)\nmaps_party\n\n\n# A tibble: 3 x 4\n  a         c         d         e        \n  <list>    <list>    <list>    <list>   \n1 <dbl [1]> <NULL>    <dbl [1]> <dbl [1]>\n2 <dbl [1]> <dbl [1]> <NULL>    <NULL>   \n3 <dbl [1]> <dbl [1]> <NULL>    <dbl [1]>\n\n그냥 purrr:map()을 사용해서 .x가 NULL인지 체크해보겠습니다.\n\n\nmaps_party %>% \n  purrr::map(~ .x %>% is.null)\n\n\n$a\n[1] FALSE\n\n$c\n[1] FALSE\n\n$d\n[1] FALSE\n\n$e\n[1] FALSE\n\n4개 컬럼에 FALSE라는 결과를 list로 출력해줬네요. 이건 슬프게도 컬럼이 NULL이냐 물어본 것이라 당연히 전부 FALSE가 나와야 합니다. 그럼 다시 map() in map()으로 작성해서 확인해 보겠습니다.\n\n\nmaps_party %>% \n  purrr::map(~ .x %>% purrr::map(is.null))\n\n\n$a\n$a[[1]]\n[1] FALSE\n\n$a[[2]]\n[1] FALSE\n\n$a[[3]]\n[1] FALSE\n\n\n$c\n$c[[1]]\n[1] TRUE\n\n$c[[2]]\n[1] FALSE\n\n$c[[3]]\n[1] FALSE\n\n\n$d\n$d[[1]]\n[1] FALSE\n\n$d[[2]]\n[1] TRUE\n\n$d[[3]]\n[1] TRUE\n\n\n$e\n$e[[1]]\n[1] FALSE\n\n$e[[2]]\n[1] TRUE\n\n$e[[3]]\n[1] FALSE\n\n2단 list로 결과를 주는데, 결국 전부 list이군요? 이제 ifelse() 함수로 is.null() 결과가 TRUE면 0을, FALSE면 원래 값 그대로 넣어보겠습니다.\n\n\nmaps_party %>% \n  purrr::map(~ .x %>% purrr::map(is.null) %>% ifelse(0,.x))\n\n\n$a\n$a[[1]]\n[1] 1\n\n$a[[2]]\n[1] 2\n\n$a[[3]]\n[1] 3\n\n\n$c\n$c[[1]]\n[1] 0\n\n$c[[2]]\n[1] 1\n\n$c[[3]]\n[1] 2\n\n\n$d\n$d[[1]]\n[1] 1\n\n$d[[2]]\n[1] 0\n\n$d[[3]]\n[1] 0\n\n\n$e\n$e[[1]]\n[1] 1\n\n$e[[2]]\n[1] 0\n\n$e[[3]]\n[1] 3\n\n이렇게 보니 ifelse()에 들어가는 .x는 처음에 사용한 .x가 아니라, 안쪽에 있는 purrr::map() 함수에서 사용하는 .x인듯합니다.\n\n\nmaps_party %>% \n  purrr::map(~ .x %>% purrr::map(~ifelse(is.null(.x),0,.x)))\n\n\n$a\n$a[[1]]\n[1] 1\n\n$a[[2]]\n[1] 2\n\n$a[[3]]\n[1] 3\n\n\n$c\n$c[[1]]\n[1] 0\n\n$c[[2]]\n[1] 1\n\n$c[[3]]\n[1] 2\n\n\n$d\n$d[[1]]\n[1] 1\n\n$d[[2]]\n[1] 0\n\n$d[[3]]\n[1] 0\n\n\n$e\n$e[[1]]\n[1] 1\n\n$e[[2]]\n[1] 0\n\n$e[[3]]\n[1] 3\n\n같은 결과인거 보니 맞네요.\n이제 리스트를 tibble로 다시 조합해 내야 합니다.\npurrr::map_*()으로 조합해볼까요.\n\n\nmaps_party %>% \n  purrr::map(~ .x %>% purrr::map_dbl(~ifelse(is.null(.x),0,.x)))\n\n\n$a\n[1] 1 2 3\n\n$c\n[1] 0 1 2\n\n$d\n[1] 1 0 0\n\n$e\n[1] 1 0 3\n\n컬럼 단위는 잘 진행된 것 같습니다. 헌데 지금 예시야 숫자만 있지만, 글자인 컬럼이 있거나 하면 에러가 날겁니다. list를 vector로 풀면 될 것 같은데… 우리는 이미 그런 동작을 해주는 함수를 알고 있습니다.\n\n\nmaps_party %>% \n  purrr::map(~ .x %>% purrr::map(~ifelse(is.null(.x),0,.x)) %>% unlist)\n\n\n$a\n[1] 1 2 3\n\n$c\n[1] 0 1 2\n\n$d\n[1] 1 0 0\n\n$e\n[1] 1 0 3\n\n같은 결과가 나왔군요! 패키지 코드에서는 이미 확인했지만, 컬럼이 여러 자료형이어도 잘 동작합니다. 그럼 이제 만들어진 개별 list를 컬럼으로 합치기만 하면 되군요! 드디어 처음에 설명했던 purrr::map_dfc()함수를 사용할 차례인가 봅니다.\n\n\nmaps_party %>% \n  purrr::map_dfr(~ .x %>% purrr::map(~ifelse(is.null(.x),0,.x)) %>% unlist)\n\n\n# A tibble: 3 x 4\n      a     c     d     e\n  <dbl> <dbl> <dbl> <dbl>\n1     1     0     1     1\n2     2     1     0     0\n3     3     2     0     3\n\n중간에 unlist()를 사용하면서, 이미 개별 컬럼이 list가 아니게 되었네요. 감사하게 여기서는 tidyr::unnest() 함수를 사용할 필요가 없어진 것 같습니다.\n마치며\n다시 한 번 {purrr} 패키지의 강력함과 어려움을 동시에 느낄 수 있었던 작업이었습니다. map()을 이 중으로 사용하면서 .x이 대표하는 대상이 달라진다는 점이 재밌었는데요. 앞으로 복잡한 list(json)를 다룰 때 더 수월하게 할 수 있을 것 같습니다.\n감사합니다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106561891-dc30ef80-656c-11eb-8f14-e25c99bc7f5a.png",
    "last_modified": "2021-05-05T05:37:08+00:00",
    "input_file": {}
  },
  {
    "path": "post/rtips-데이터-프레임-안의-json을-가져와보자/",
    "title": "[Rtips] 데이터 프레임 안의 json을 가져와보자.",
    "description": "최근의 noSQL, 웹 기술의 발달로 json을 처리해야 하는 상황이 많아졌다. 특별히 data.frame의 셀이 json 텍스트인 경우가 있는데, map + fromJSON 으로 해결할 수 있다. json 이 모두 같은 key를 가지고 있다면, 정리하는데 매우 유용하다.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2018-11-19",
    "categories": [
      "R",
      "purrr",
      "json",
      "map"
    ],
    "contents": "\n\n세줄요약\n최근의 noSQL, 웹 기술의 발달로 json을 처리해야 하는 상황이 많아졌다.\n특별히 data.frame의 셀이 json 텍스트인 경우가 있는데, map + fromJSON 으로 해결할 수 있다.\njson 이 모두 같은 key를 가지고 있다면, 정리하는데 매우 유용하다.\njson 자료형은 웹 시대에 교환 표준으로 자리잡고 있습니다. 여러 장점이 있겠지만, 휴먼 리더블하면서 머신 리더블하다는게 가장 큰 장점이지 않을까 싶네요. R도 데이터를 다루는데 json을 list자료형에 대응시켜서 적극적으로 활용하고 있습니다.\njson은 R에서 list다\n선언하듯 제목을 달았지만, json이 무엇인지 먼저 이해하면 조금 더 좋을 것 같습니다. json은 공식홈페이지에서 한국어 정의를 제공하고 있습니다. 가장 중요한 단어는 텍스트 형식인데요. 맞습니다. json은 텍스트를 작성하는 규칙입니다. 그러다보니 다양한 언어에서 json 형식에 따라 작성된 텍스트는 자체 자료형으로 잘 변환해서 불러옵니다. R에서는 그 자료형이 list 입니다. 매우 많은 패키지가 기능을 제공하지만 가장 유명하게 사용하는 것은 jsonlite입니다. 많은 패키지(대표적으로 httr)가 json을 다루기 위해 jsonlite을 사용하고 있습니다. 그리고 사용자입장에서는 그게 json은 list가 되는 것으로 보이게 처리되어 있죠. json 자체에 대해 더 공부하고 싶으시면 wiki가 매우 잘 되어 있습니다.\njson 양식의 텍스트를 처리해보자\n우선 예시를 할만한 텍스트를 가져와보겠습니다.\n\n\njson_text <- '{\n    \"이름\": \"홍길동\",\n    \"나이\": 25,\n    \"성별\": \"여\",\n    \"주소\": \"서울특별시 양천구 목동\",\n    \"특기\": [\"농구\", \"도술\"],\n    \"가족관계\": {\"#\": 2, \"아버지\": \"홍판서\", \"어머니\": \"춘섬\"},\n    \"회사\": \"경기 수원시 팔달구 우만동\"\n }'\njson_text\n\n\n[1] \"{\\n    \\\"이름\\\": \\\"홍길동\\\",\\n    \\\"나이\\\": 25,\\n    \\\"성별\\\": \\\"여\\\",\\n    \\\"주소\\\": \\\"서울특별시 양천구 목동\\\",\\n    \\\"특기\\\": [\\\"농구\\\", \\\"도술\\\"],\\n    \\\"가족관계\\\": {\\\"#\\\": 2, \\\"아버지\\\": \\\"홍판서\\\", \\\"어머니\\\": \\\"춘섬\\\"},\\n    \\\"회사\\\": \\\"경기 수원시 팔달구 우만동\\\"\\n }\"\n\n\\n는 뉴라인의 표현으로 엔터라고 이해하시면 되겠습니다. 규칙에 맞게 데이터를 가져오는 것을 파싱이라고 하는데, 이거 스스로 만들려고 하면 아주 골치 아프게 생겼습니다. json은 매우 광범위하게 사용하는 범용 양식이라, 많은 언어가 미리 파싱하는 패키지를 만들어 관리하고 있습니다. R에서는 jsonlite를 가장 많이 사용한다고 했구요.\n\n\nlibrary(jsonlite)\nfromJSON(json_text)\n\n\n$이름\n[1] \"홍길동\"\n\n$나이\n[1] 25\n\n$성별\n[1] \"여\"\n\n$주소\n[1] \"서울특별시 양천구 목동\"\n\n$특기\n[1] \"농구\" \"도술\"\n\n$가족관계\n$가족관계$`#`\n[1] 2\n\n$가족관계$아버지\n[1] \"홍판서\"\n\n$가족관계$어머니\n[1] \"춘섬\"\n\n\n$회사\n[1] \"경기 수원시 팔달구 우만동\"\n\nlist 자료형으로 잘 처리되었군요.\n그럼 이제 데이터 프레임 내에 있는 json 형식의 글자를 처리해봅니다. 우선 그런 형태로 만들어 볼까요?\n\n\nnested_json <- data.frame(a = 1:5, b = rep(json_text, 5), stringsAsFactors = F)\nnested_json\n\n\n  a\n1 1\n2 2\n3 3\n4 4\n5 5\n                                                                                                                                                                                                                                                 b\n1 {\\n    \"이름\": \"홍길동\",\\n    \"나이\": 25,\\n    \"성별\": \"여\",\\n    \"주소\": \"서울특별시 양천구 목동\",\\n    \"특기\": [\"농구\", \"도술\"],\\n    \"가족관계\": {\"#\": 2, \"아버지\": \"홍판서\", \"어머니\": \"춘섬\"},\\n    \"회사\": \"경기 수원시 팔달구 우만동\"\\n }\n2 {\\n    \"이름\": \"홍길동\",\\n    \"나이\": 25,\\n    \"성별\": \"여\",\\n    \"주소\": \"서울특별시 양천구 목동\",\\n    \"특기\": [\"농구\", \"도술\"],\\n    \"가족관계\": {\"#\": 2, \"아버지\": \"홍판서\", \"어머니\": \"춘섬\"},\\n    \"회사\": \"경기 수원시 팔달구 우만동\"\\n }\n3 {\\n    \"이름\": \"홍길동\",\\n    \"나이\": 25,\\n    \"성별\": \"여\",\\n    \"주소\": \"서울특별시 양천구 목동\",\\n    \"특기\": [\"농구\", \"도술\"],\\n    \"가족관계\": {\"#\": 2, \"아버지\": \"홍판서\", \"어머니\": \"춘섬\"},\\n    \"회사\": \"경기 수원시 팔달구 우만동\"\\n }\n4 {\\n    \"이름\": \"홍길동\",\\n    \"나이\": 25,\\n    \"성별\": \"여\",\\n    \"주소\": \"서울특별시 양천구 목동\",\\n    \"특기\": [\"농구\", \"도술\"],\\n    \"가족관계\": {\"#\": 2, \"아버지\": \"홍판서\", \"어머니\": \"춘섬\"},\\n    \"회사\": \"경기 수원시 팔달구 우만동\"\\n }\n5 {\\n    \"이름\": \"홍길동\",\\n    \"나이\": 25,\\n    \"성별\": \"여\",\\n    \"주소\": \"서울특별시 양천구 목동\",\\n    \"특기\": [\"농구\", \"도술\"],\\n    \"가족관계\": {\"#\": 2, \"아버지\": \"홍판서\", \"어머니\": \"춘섬\"},\\n    \"회사\": \"경기 수원시 팔달구 우만동\"\\n }\n\nfor으로 반복해서 하기\n예시 데이터 nested_json 에는 b 컬럼에 같은 json_text 5개가 들어간 형태입니다. 데이터 프레임의 컬럼을 다루려먼 어떤 방식이 가장 좋을까요? R이 아직 능숙하지 않으신 분들은 아마도 for문으로 컬럼내의 셀 한개씩 접근해서 고치는 방법을 생각해 볼 수 있을 것 같습니다. 데이터가 적다면 좋은 방법입니다! 코드가 조금 느리더라도, 코드 작성이 오래 걸리는 것 보다는 훨씬 좋은 방법입니다.\n\n\nfor (i in 1:nrow(nested_json)) {\n    nested_json[i,2] <- fromJSON(nested_json[i,2])\n}\nnested_json\n\n\n  a      b\n1 1 홍길동\n2 2 홍길동\n3 3 홍길동\n4 4 홍길동\n5 5 홍길동\n\n헐… json의 첫번째 데이터만 들어왔습니다. warnings 잔뜩인거 보니, 그 경고를 주는 것 같네요! 모든 데이터를 얻기는 힘들 것 같고… 그렇다면 선택적으로 데이터를 취할 수는 있을 것 같습니다.\n\n\nnested_json <- data.frame(a = 1:5, b = rep(json_text, 5), stringsAsFactors = F)\nresult <- nested_json\nfor (i in 1:nrow(nested_json)) {\n    result[i,2] <- fromJSON(nested_json[i,2])[[\"특기\"]][1]\n    result[i,3] <- fromJSON(nested_json[i,2])[[\"특기\"]][2]\n}\nresult\n\n\n  a    b   V3\n1 1 농구 도술\n2 2 농구 도술\n3 3 농구 도술\n4 4 농구 도술\n5 5 농구 도술\n\n바로 데이터를 덮지 않고, result 객체를 따로 만들어 결과를 저장했습니다. 이렇게 하지 않으면, 두 번째 특기를 가져올 때 문제가 생기더라구요. 어떤 문제가 생기는지는 직접 한번 실행해 보시면 좋을 것 같습니다.\n이거 for문으로 작성하는게 적당히 효율적일 수 있을 거는 같은데, 좀 더 수월한 방법이 없을까요?\n{dplyr} 패키지의 mutate() 함수\n{dplyr} 패키지의 mutate() 함수를 이용해서 fromJSON() 함수를 적용해 볼까요? mutate() 함수는 컬럼 기반의 연산을 지원하기 때문에 좋은 방법인 것 같습니다.\nlibrary(dplyr)\nnested_json %>% \n  mutate(b = fromJSON(b))\n## Error in mutate_impl(.data, dots) : \n##   Evaluation error: parse error: trailing garbage\n##           <U+0090>시 팔달구 우만동\"  } {     \"이름\": \"홍길동\",   \n##                      (right here) ------^\n이런 문제가 있군요?! 문제가 된다고 하는 곳을 살펴보니, } { 사이에 쉼표가 없습니다! 이름이라고 나오는 걸 보니 새로운 셀의 값인거 같은데, 왜 이게 하나의 데이터인 것처럼 인지하는 걸까요?ㅜㅠ\n얼른 떠오르기 좋은 방법이 안되는걸 확인했습니다. 그럼 어떻게 해야 할까요?\n현대적인 방법의 apply : map()\nR 언어는 vector 연산을 고려해서 만들었다고 합니다. 그래서 for문의 효율이 매우 떨어지죠. apply() 계열 함수를 사용하도록 권장하는데요. map() 함수는 Apply a function to each element of a list or atomic vector 라는 제목에 걸맞게 현대적인 방식의 apply 계열의 함수입니다. {purrr} 패키지를 설치해야 사용할 수 있습니다. {tidyverse} 패키지가 설치되어 있다면, 포함되어 있으니 다시 설치하지 않아도 됩니다.\ninstall.packages(\"purrr\")\n그럼 이제 mutate() 함수와 map() 함수를 조합해 볼까요?!\n\n\nlibrary(purrr)\n\nnested_json <- data.frame(a = 1:5, b = rep(json_text, 5), stringsAsFactors = F)\n\nnested_json %>% \n  mutate(b = map(b, fromJSON))\n\n\n  a\n1 1\n2 2\n3 3\n4 4\n5 5\n                                                                                               b\n1 홍길동, 25, 여, 서울특별시 양천구 목동, 농구, 도술, 2, 홍판서, 춘섬, 경기 수원시 팔달구 우만동\n2 홍길동, 25, 여, 서울특별시 양천구 목동, 농구, 도술, 2, 홍판서, 춘섬, 경기 수원시 팔달구 우만동\n3 홍길동, 25, 여, 서울특별시 양천구 목동, 농구, 도술, 2, 홍판서, 춘섬, 경기 수원시 팔달구 우만동\n4 홍길동, 25, 여, 서울특별시 양천구 목동, 농구, 도술, 2, 홍판서, 춘섬, 경기 수원시 팔달구 우만동\n5 홍길동, 25, 여, 서울특별시 양천구 목동, 농구, 도술, 2, 홍판서, 춘섬, 경기 수원시 팔달구 우만동\n\n드디어!! ,로 연결된거 같이 표시된 결과물이 나왔습니다. 보기 불편하니 tibble 자료형으로 바꿔서 확인해 볼까요?\n\n\nnested_json %>% \n  mutate(b = map(b, fromJSON)) %>% \n  as_tibble()\n\n\n# A tibble: 5 x 2\n      a b               \n  <int> <list>          \n1     1 <named list [7]>\n2     2 <named list [7]>\n3     3 <named list [7]>\n4     4 <named list [7]>\n5     5 <named list [7]>\n\n무려 list랍니다. 휴… 이게 생각하기 복잡할 수 있지만서도, 익숙해지면 좋은 구조입니다. 많은 데이터들이 2차원 테이블로만 구성하기가 어려운 구조를 가지고 있기 때문입니다. 위의 예시 데이터도 b 컬럼의 셀 안에 다 담기 어려운 구조이죠.\nR 최근 버전부터 이렇게 data.frame 자료형의 컬럼에 list를 지원하고 있습니다. 원래는 vector만 됬었죠. 지금의 선택이 data.frame의 2차원 테이블형의 직관적인 형태를 유지하면서, list의 자유도를 흡수하는 방법인 것 같습니다. 대신 저는 그동안 list 자체를 이해하길 포기하고 있었는데, 지금은 알아야만 하게 됬네요 ㅎㅎ\n마무리\nmap() 함수를 mutate() 함수와 함께 사용할 수도, 단독으로 사용할 수도 있어서 좀더 어떻게 동작하는지 알아야 할 것 같습니다. 다른 예시가 있을 때 한번 더 파볼께요. 감사합니다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106561761-983dea80-656c-11eb-8885-d7c0aa27cac8.png",
    "last_modified": "2021-05-05T05:35:13+00:00",
    "input_file": {}
  },
  {
    "path": "post/rtips-dplyr로-db-데이터를-다룰-때-여러-테이블을-union-해보자/",
    "title": "[Rtips] dplyr로 DB 데이터를 다룰 때 여러 테이블을 union 해보자",
    "description": "{dplyr}의 함수들은 `tbl()`과 `DBI::dbConnect()`를 사용해서 db table을 소스로 사용할 수 있다. 여러 테이블로 분산되어 있는 것을 `union()` 하는 것은 자주, 하지만 번거로운 일이다. table 이름을 받아와서 `map` 함수와 엮으면 짧은 코드로 한번에 많은 테이블들을 `union()` 해서 사용할 수 있다.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2018-11-16",
    "categories": [
      "R",
      "purrr",
      "map",
      "dbi",
      "dplyr",
      "postgres",
      "union"
    ],
    "contents": "\n\nContents\n{DBI} + {dplyr}\ndb내에서 테이블들을 rbind 하려면\n여러 테이블의 union\n여러 테이블의 union with reduce\n여러 테이블의 union with map and reduce\n마치며\n\n\n세줄요약\n{dplyr}의 함수들은 tbl()과 DBI::dbConnect()를 사용해서 db table을 소스로 사용할 수 있다.\n여러 테이블로 분산되어 있는 것을 union() 하는 것은 자주, 하지만 번거로운 일이다.\ntable 이름을 받아와서 map 함수와 엮으면 짧은 코드로 한번에 많은 테이블들을 union() 해서 사용할 수 있다.\n데이터를 다루는데 있어 기업 환경에서는 데이터베이스에 접근하는 것을 피할 수 없을 것입니다. R로 접근하여 다루는 것에 대해 자료가 많지 않아서, 제가 찾은 요령을 공유할 겸 글을 작성해보겠습니다. 이미 {tidyverse}에 길들여져 있다면, 좋아하실 만한 내용입니다.\n{DBI} 패키지\n{DBI} 패키지는 database interface 라는 뜻으로, perl의 DBI나 python의 DB-API 같은 db를 연결하기 위한 기반 패키지입니다. R의 {DBI} 패키지는 r-DBI 팀이 관리하고 있습니다. {DBI} 뿐만 아니라 여타 DB들의 드라이버 패키지들을 포함해 {odbc} 등도 제작, 관리하고 있죠. 제가 postgres 를 많이 쓰니까, 우선 R로 postgres db와 연결하는 방법을 소개해 보겠습니다.\nlibrary(DBI)\nlibrary(RPostgres)\n\nconn <- dbConnect(\n  Postgres(),             # RPostgres에서 지원하는 드라이버 함수 입니다.\n  host = HOST,            # postgres가 있는 주소 입니다. 'ec2-54-83-201-96.compute-1.amazonaws.com'거나 로컬일 수도 있습니다.\n  port = 5432,            # 접근하기 위한 포트넘버 입니다. 5432는 postgres의 기본값이고, db에 설정된 값을 입력하면 됩니다.\n  user = 'postgres',      # 권한을 받은 db 계정입니다.\n  password = 'password',  # 관한을 받은 db 계정의 암호입니다.\n  bigint = \"numeric\",     # db에 저장된 매우 큰 숫자들은 DBI 패키지가 int64를 기본으로 가져옵니다. 익숙하지 않으면 numeric으로 가져오라고 설정합니다.\n  sslmode = \"require\"     # ssl 통신에 대한 설정입니다.\n)\nconn\n<PqConnection> ec2-54-83-201-96.compute-1.amazonaws.com:5439\n이제 db에 연결하는 작업이 끝났습니다. R로, 정확히는 {dplyr} 패키지로 db의 테이블들을 소스로 사용하기 위해서는 한가지 작업을 추가해야 합니다.\n{DBI} + {dplyr}\nlibrary(dplyr)\ntar <- tbl(conn, \"table 이름\")\n{dplyr} 패키지의 tbl() 함수는 conn의 db 연결 정보를 바탕으로 db 내의 테이블을 R 객체처럼 다룰 수 있게 해줍니다. 예를 들어 위의 tar객체는 이제 R의 data.frame이나 tibble처럼 {dplyr} 문법으로 이리저리 처리 할 수 있죠.\ntar %>% \n  select(col_name1)\n신경 써야 할 차이라면, tar는 collect() 함수를 사용하지 않는 이상 DB에 있는 집계 결과 중 첫 몆줄만 보여주게 설계되어 있습니다. 연산을 local R에서 하는 것이 아니라 DB에서 진행하죠. 그러다 보니 지금 명령이 db에서 실행되는 것인지, R로 가져와서 실행하는 것인지 신경쓸 필요가 있습니다. 대부분의 명령이 호환되지만 db에서 지원하지 않는 함수는 동작하지 않기 때문에 잘 살펴봐야 합니다. 반대로 mutate나 summarise에서 R에는 없지만 db에서 지원하는 함수를 사용할 수도 있습니다. 이 문제는 다음 포스트에서 다루기로 하겠습니다.\ndb내에서 테이블들을 rbind 하려면\nrbind()는 R에서 data.frame을 행방향으로 합치는 기능을 수행합니다. {dplyr}에서는 bind_rows()함수로 제공합니다. db src인 상황에서는 둘다 동작하지 않습니다. 아래와 같은 에러를 뿜죠.\nError in bind_rows_(x, .id) : \n  Argument 1 must be a data frame or a named atomic vector, not a tbl_dbi/tbl_sql/tbl_lazy/tbl\n사실 bind_rows()함수는 데이터를 판단하지 않고, 겹치는 값에 상관없이 두 테이블을 위-아래 방향으로 합쳐줍니다. 반면에 union()함수는 겹치는 행이 있을 때 유일한 값만 두고 합칩니다.\nunion()\nbind_rows() %>% unique()\n이렇게가 같은 동작이라고 이해하면 좋을까요? {dplyr}에서 union() 함수를 지원하고 있습니다만, db에서도 같은 동작을 지원합니다. 그래서 db src 일때는 union() 함수를 사용해하죠.\ntar1 <- tbl(conn, \"table1\")\ntar2 <- tbl(conn, \"table2\")\n\ntarAll <- union(tar1, tar2)\n테이블 구조가 다르면 에러가 나는 걸로 알고 있습니다만, 확인해봐야 할 것 같습니다. 그래도 구조가 같다고 알고 있는 여러 테이블을 합치려면, union()함수가 꼭 필요합니다. 이때 그럼 테이블 갯수가 많아지면 어떻게 해야 할까요?\n여러 테이블의 union\n{DBI} 패키지에서는 dbListTables()라는 함수를 제공하기 때문에 테이블 이름을 가져올 수 있습니다. schema에 들어가 있는 테이블 리스트는 제가 방법을 찾지 못해 쿼리로 해결하였습니다.\nlibrary(DBI)\nlibrary(dplyr)\ntables <- dbGetQuery(conn,\n             \"SELECT table_name FROM information_schema.tables\") %>%\n    arrange(table_name)\ntables\n위 쿼리에 WHERE table_schema = \"schema_name\"를 추가하여 특정 스키마 내의 테이블만 확인할 수 도 있습니다. 아무튼 테이블 이름을 전부 가져왔다면, 필요한 테이블만 골라 봅시다. 같은 종류의 테이블을 합쳐야 하니 보통은 네이밍 규칙에 따라 같은 이름으로 작성된 부분이 있을 것 입니다. 예를 들어 커머스라면 판매 테이블이 거대한 한가지 일 수도 있지만, 카테고리나 여러 의미 단위로 잘라져 여러 테이블로 되어 있기도 합니다. 아마 category_name1_sales_recodes 같은 식이겠죠? 그럼 _sales_recodes로 끝나는 이름의 테이블들을 전부 가져오도록 합시다.\ntar_tables <- tables %>% \n  filter(grepl(\"_sales_recodes$\", table_name))\ntar_tables\n이제 이 테이블들을 연결해 보겠습니다. 간단히 생각해보면 for 문을 돌리면 되겠네요? 여기서 전략이 여러 가지로 갈리겠습니다만, 저는 리스트에 넣는 방식으로 진행해 보겠습니다.\ntar_list <- list()\nnum_of_tables <- nrow(tar_tables)\nfor(i in 1:num_of_tables) {\n  tar_list[[i]] <- \n    tbl(conn, tar_tables[i, 1])\n}\nunion(tar)\nError in base::union(x, y, ...) : \n  argument \"y\" is missing, with no default\n아 이런! union() 함수가 리스트 내의 db src 들을 인지하지 못하는군요. 저는 처음에 그래서 최대한 필터링, 전처리 하고 collect() 함수로 불러온 결과를 tar_list에 저장한 후 bind_row()하는 선택을 했었습니다.\ntar_list <- list()\nnum_of_tables <- nrow(tar_tables)\nfor(i in 1:num_of_tables) {\n  tar_list[[i]] <- \n    tbl(conn, tar_tables[i, 1]) %>% \n    filter(exampe) %>% \n    group_by(col_1) %>% \n    summarise(n = n()) %>% \n    collect()\n}\nbind_rows(tar)\n이러면 동작은 잘 하는데, collect() 할 때 연산 시간이 너무 많이 걸린다는 문제가 있습니다. 이미 거대 데이터를 다루는 건 db에게 넘기기로 한 이상, 최대한 db에서 연산하도록 하고 한번만 가져오는 것이 효율적이죠. 그럼 아예 전부 union()하고 그 db src 객체를 다뤄서 가져오면 좋겠군요?!\n여러 테이블의 union with reduce\nreduce() 함수는 list 자료형의 데이터를 다음에 지정하는 함수로 합쳐주는 기능을 합니다. {purrr}라는 패키지에 속해있죠. list 자료형을 다루는데 매우 효과적이며 익명 함수 같은 방식으로 작성하기 좋게 되어 있습니다.\nlibrary(purrr)\ntar_list <- list()\nnum_of_tables <- nrow(tar_tables)\nfor(i in 1:num_of_tables) {\n  tar_list[[i]] <- \n    tbl(conn, tar_tables[i, 1])\n}\nreduce(tar_list, function(x,y) union(x,y))  %>% \n  filter(exampe) %>% \n  group_by(col_1) %>% \n  summarise(n = n()) %>% \n  collect()\n저도 찾아서 작성한 코드라 왜 익명 함수로 작성해야 동작하는지 아직 이해하지 못했습니다만, 어쨌든 합치고 한번만 collect() 할 수 있게 되었습니다! 물론 저렇게 다 합치고 연산을 했을 때 기대한 결과물이 나오는 것인지는 세심히 확인해야 할 것 같습니다.\n그런데 {purrr} package는 map()이라는 함수도 제공합니다.\n여러 테이블의 union with map and reduce\nmap() 함수는 base R 에서 apply가 담당하는 벡터 연산의 현대적인 부분을 담당합니다. {purrr}가 {tidyverse}에 속해 있는 걸로 충분한 설명이 되는 것 같네요. 제가 map() 함수 이야기를 꺼내는 이유는 for를 없애고 싶기 때문입니다. 리스트 자료형에 저장하고, i 신경 쓰고 하는 일련의 것들을 버리고 싶은거죠.\n우선 코드를 작성하고 살펴볼까요?\ntar_tables %>% \n  .$table_name %>% \n  map(~ tbl(conn, .x)) %>% \n  reduce(function(x,y) union(x,y)) %>% \n  filter(exampe) %>% \n  group_by(col_1) %>% \n  summarise(n = n()) %>% \n  collect()\n음? 아까 for로 짜던 부분이 한줄(???!??!!?)이 되었군요? (물론 map()이 받을 수 있게 character vector로 변환한 줄까지 하면 2줄입니다.) 이렇게 하면 테이블 이름을 map()함수가 받아서 tbl()로 연결 객체를 만들고, reduce() + union()으로 하나의 테이블로 합쳤습니다. 이제 필요한 테이블 전체를 하나의 테이블로 합친 후 필요한 작업을 하고, collect()하면 끝입니다.\n마치며\nR에서 for 가 느리기 때문에 사용을 자제하며, dplyr의 column-wise mutate나 apply 계열 함수들을 추천해왔는데요. 이제 purrr::map()로 더 다양한 조건에서 for를 배제하고 코드를 작성할 수 있게 되었습니다. 물론 처음 시작할 때부터 이렇게 작성하는 것은 매우 위험합니다. 자신이 보고 읽어서 이해할 수 있는 코드가 좋은 코드인 것이죠. 극단적으로 저는 namespace 문제와 여러 함수가 패키지의 겹침 문제가 있어서 가능하면 namespace를 지정하는 방식으로 코드를 짭니다. 물론 제가 skimming 할때는 아니지만, 스크립트를 저장할 때 말이죠.\n마지막 코드의 장점은 같은 구조의 테이블이 얼마나 늘어나던지 상황하지 않고 전부 합쳐준다는 점입니다. 구조의 변경이 없다는 가정하에 매우 강건한 코드라고 할 수 있죠.\n그럼 모두 {purrr}의 세계에 한번 깊게 빠져보시기 바랍니다. 감사합니다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106561491-1ea5fc80-656c-11eb-8b86-055653bef9f7.png",
    "last_modified": "2021-05-05T05:35:00+00:00",
    "input_file": {}
  },
  {
    "path": "post/번역-폴더안의-csv-파일들을-purrr-와-readr-을-이용해서-한방에-불러오기/",
    "title": "[번역]폴더안의 csv 파일들을 {purrr}와 {readr}을 이용해서 한방에 불러오기",
    "description": "{purrr}의 `map_dfr()` 함수로 폴더내의 파일 리스트를 한번에 불러올 수 있습니다.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2018-10-27",
    "categories": [
      "R",
      "purrr",
      "readr",
      "csv",
      "read"
    ],
    "contents": "\n\n본 번역은 원글을 대상으로 CC-BY 라이선스를 사용하고 있어 마음껏 번역하였습니다.\n요약 : {purrr}의 map_dfr() 함수로 폴더내의 파일 리스트를 한번에 불러올 수 있다.\n\n이번 포스트는 tidyverse 패키지에 속한 두 패키지(purrr&readr)를 사용해서 csv 파일 리스트를 하나의 data.frame으로 불러오는 방법을 설명합니다. 또한 fs라는 새로운 파일 시스템 대응 패키지를 사용합니다.\n\n\n# 필요한 패키지를 설치합니다. \n# install.packages(c(\"tidyverse\", \"fs\"))\n\nlibrary(tidyverse)  # purrr와 readr을 불러옵니다.\nlibrary(fs)\n\n\n\n문제 상황 설정\n규칙적인 데이터를 포함하는 CSV 파일들이 한 디렉토리에 있다고 가정합니다. 즉, 각 데이터 세트의 열이 모두 동일하거나 적어도 중복되는 열이 동일하다는 것을 의미한다고 가정합니다.\n우리는 디렉토리 안의 모든 CSV 파일을 읽어서 각각의 파일을 불러온 작은 데이터셋을 합쳐 하나의 큰 데이터셋으로 만들고 싶습니다.\n예제 데이터\n예를 좀 더 구체적으로 설명하기 위해 아일랜드 정부가 제공한 데이터셋을 사용하겠습니다. 이 데이터셋은 병원 부서별 연간 온라인 추천수로, 각 년도별로 파일이 구분되어 있습니다.\n데이터는 data.gov.ie에서 개별 csv 파일들을 다운로드 받거나, 미리 준비한 압축 파일을 다운 받을 수 있습니다.\n한 폴더 내에 csv 파일들을 다운로드 받았거나, 압축 파일을 풀어놓은 후에 data_dir 객체에 경로를 지정합니다.\n\n\ndata_dir <- \"ie-general-referrals-by-hospital\"\n\n\n\nfs::dir_ls() 함수를 사용해서 폴더내의 파일 리스트를 가져올 수 있습니다.\n\n\nfs::dir_ls(data_dir)\n\n\nie-general-referrals-by-hospital/README.txt\nie-general-referrals-by-hospital/general-referrals-by-hospital-department-2015.csv\nie-general-referrals-by-hospital/general-referrals-by-hospital-department-2016.csv\nie-general-referrals-by-hospital/general-referrals-by-hospital-department-2017.csv\nie-general-referrals-by-hospital/general-referrals-by-hospital-department-2018.csv\n\n리스트를 보니 README.txt 파일이 추가로 있습니다. 이 파일은 우리가 불러오고자 하는 파일이 아닙니다. 그렇기 때문에 폴더 내의 파일 리스트를 불러올 때 csv 파일 형식으로만 제한할 필요가 있습니다. 파일명이 .csv로 끝나는 것들만 조건을 주면 좋겠습니다.\n\n\ncsv_files <- fs::dir_ls(data_dir, regexp = \"\\\\.csv$\")\ncsv_files\n\n\nie-general-referrals-by-hospital/general-referrals-by-hospital-department-2015.csv\nie-general-referrals-by-hospital/general-referrals-by-hospital-department-2016.csv\nie-general-referrals-by-hospital/general-referrals-by-hospital-department-2017.csv\nie-general-referrals-by-hospital/general-referrals-by-hospital-department-2018.csv\n\n파일 전체를 불러오기\n우선 한 파일을 불러오기\n각 csv 파일들을 readr::read_csv() 함수를 이용해서 각각 불러올 수 있습니다. 한 파일만 먼저 예시로 불러와 보겠습니다.\n\n\nreadr::read_csv(csv_files[1])\n\n\n# A tibble: 837 x 6\n   Month_Year Hospital_Name Hospital_ID Hospital_Depart… ReferralType\n   <chr>      <chr>               <dbl> <chr>            <chr>       \n 1 Aug-15     AMNCH                1049 Paediatric ENT   General Ref…\n 2 Aug-15     AMNCH                1049 Paediatric Gast… General Ref…\n 3 Aug-15     AMNCH                1049 Paediatric Gene… General Ref…\n 4 Aug-15     Bantry Gener…         704 Gastroenterology General Ref…\n 5 Aug-15     Bantry Gener…         704 General Medicine General Ref…\n 6 Aug-15     Bantry Gener…         704 General Surgery  General Ref…\n 7 Aug-15     Bantry Gener…         704 Medicine for th… General Ref…\n 8 Aug-15     Bantry Gener…         704 Outreach Dermat… General Ref…\n 9 Aug-15     Bantry Gener…         704 Outreach Orthop… General Ref…\n10 Aug-15     Bantry Gener…         704 Outreach Surgic… General Ref…\n# … with 827 more rows, and 1 more variable: TotalReferrals <dbl>\n\n전체 파일 불러오기로 확장하기\n\n디렉토리의 모든 파일을 읽으려면 purrr::map()을 사용하여 read_csv()를 파일 목록에 매핑(map)합니다. 그러나 각 list() 내의 요소가 tibble(또는 data.frame)이 될 것이고 각 데이터 프레임이 동일한 열을 가짐을 알고 있으니, purrr의 타입 지정 함수인 purrr::map_dfr()를 사용하여 가져온 CSV 파일 각각을 포함하는 단일 data.frame으로 가져와 보겠습니다. *_dfr()가 추가로 달려있는 함수들은 각 요소를 행결합(row-binding)하여 data.frame을 반환하도록 합니다.(이것은 map() %>% bind_rows() 를 호출하는 것과 같습니다.)\n\n\ncsv_files %>% \n  map_dfr(read_csv)\n\n\n# A tibble: 12,278 x 6\n   Month_Year Hospital_Name Hospital_ID Hospital_Depart… ReferralType\n   <chr>      <chr>               <dbl> <chr>            <chr>       \n 1 Aug-15     AMNCH                1049 Paediatric ENT   General Ref…\n 2 Aug-15     AMNCH                1049 Paediatric Gast… General Ref…\n 3 Aug-15     AMNCH                1049 Paediatric Gene… General Ref…\n 4 Aug-15     Bantry Gener…         704 Gastroenterology General Ref…\n 5 Aug-15     Bantry Gener…         704 General Medicine General Ref…\n 6 Aug-15     Bantry Gener…         704 General Surgery  General Ref…\n 7 Aug-15     Bantry Gener…         704 Medicine for th… General Ref…\n 8 Aug-15     Bantry Gener…         704 Outreach Dermat… General Ref…\n 9 Aug-15     Bantry Gener…         704 Outreach Orthop… General Ref…\n10 Aug-15     Bantry Gener…         704 Outreach Surgic… General Ref…\n# … with 12,268 more rows, and 1 more variable: TotalReferrals <dbl>\n\n전체 파일을 불러올 때 추가 설정하기\nMonth_Year 컬럼이 날짜/시간 자료형이 아니라 글자로 불러와져 있는 것을 알 수 있습니다. read_csv() 함수의 인자를 read_csv()함수에서 사용하는 것 처럼 map_dfr() 안에서 사용할 수 있습니다.(역자 주: read_csv() 함수에서 컬럼의 자료형을 지정하는 형태의 인자를 뜻합니다. 개인적으로는 다음 방법인 불러온 후 수정하는 방식을 선호합니다.)\n\n\ncsv_files %>% \n  map_dfr(read_csv, col_types = cols(\"Month_Year\" = col_date(format = \"%b-%y\")))\n\n\n# A tibble: 12,278 x 6\n   Month_Year Hospital_Name Hospital_ID Hospital_Depart… ReferralType\n   <date>     <chr>               <dbl> <chr>            <chr>       \n 1 2015-08-01 AMNCH                1049 Paediatric ENT   General Ref…\n 2 2015-08-01 AMNCH                1049 Paediatric Gast… General Ref…\n 3 2015-08-01 AMNCH                1049 Paediatric Gene… General Ref…\n 4 2015-08-01 Bantry Gener…         704 Gastroenterology General Ref…\n 5 2015-08-01 Bantry Gener…         704 General Medicine General Ref…\n 6 2015-08-01 Bantry Gener…         704 General Surgery  General Ref…\n 7 2015-08-01 Bantry Gener…         704 Medicine for th… General Ref…\n 8 2015-08-01 Bantry Gener…         704 Outreach Dermat… General Ref…\n 9 2015-08-01 Bantry Gener…         704 Outreach Orthop… General Ref…\n10 2015-08-01 Bantry Gener…         704 Outreach Surgic… General Ref…\n# … with 12,268 more rows, and 1 more variable: TotalReferrals <dbl>\n\n날짜 자료형 문제를 불러오기 이후에 처리하기\nread_csv() 함수의 인자를 설정하면, 대부분의 파일에서 잘 동작합니다. 하지만, 2016년에 Month_Year의 양식이 Jan-15에서 Jan-2016로 바뀌어서 2016년과 2017년 데이터가 NA로 불러와지고 말았습니다.\n이것을 고치는 가장 쉬운 방법은, 글자 자료형 그대로 불러온 후에 lubridate 패키지의 날짜 변환 함수를 사용하는 것입니다. readr의 col_date() 함수는 하나의 포멧만 허용하기 때문입니다.\n\n\nlibrary(lubridate)\n\ncsv_files %>% \n  map_dfr(read_csv) %>%\n  mutate(Month_Year = myd(Month_Year, truncated = 1))\n\n\n# A tibble: 12,278 x 6\n   Month_Year Hospital_Name Hospital_ID Hospital_Depart… ReferralType\n   <date>     <chr>               <dbl> <chr>            <chr>       \n 1 2015-08-01 AMNCH                1049 Paediatric ENT   General Ref…\n 2 2015-08-01 AMNCH                1049 Paediatric Gast… General Ref…\n 3 2015-08-01 AMNCH                1049 Paediatric Gene… General Ref…\n 4 2015-08-01 Bantry Gener…         704 Gastroenterology General Ref…\n 5 2015-08-01 Bantry Gener…         704 General Medicine General Ref…\n 6 2015-08-01 Bantry Gener…         704 General Surgery  General Ref…\n 7 2015-08-01 Bantry Gener…         704 Medicine for th… General Ref…\n 8 2015-08-01 Bantry Gener…         704 Outreach Dermat… General Ref…\n 9 2015-08-01 Bantry Gener…         704 Outreach Orthop… General Ref…\n10 2015-08-01 Bantry Gener…         704 Outreach Surgic… General Ref…\n# … with 12,268 more rows, and 1 more variable: TotalReferrals <dbl>\n\n파일명 컬럼 추가하기\n데이터를 사용하다보면 보고 있는 값이 어느 파일에서 나온 것인지 확인하고 싶을 떄가 있습니다(역자주: 지금의 구조에서는 년도로 구분되어 있기 때문에 날짜 컬럼을 확인하면 됩니다만, .id 인자는 bind_rows() 함수에서도 유용하게 사용하는 것이니 알아두면 좋습니다.). map_dfr() 함수의 .id 인자를 지정하고 싶은 컬럼명(지금은 source)을 작성하는 것으로 사용하면, source 컬럼이 해당 파일이름이 추가되어 최종 데이터셋에 반영됩니다.\n\n\ncsv_files %>% \n  map_dfr(read_csv, .id = \"source\") %>%\n  mutate(Month_Year = myd(Month_Year, truncated = 1))\n\n\n# A tibble: 12,278 x 7\n   source Month_Year Hospital_Name Hospital_ID Hospital_Depart…\n   <chr>  <date>     <chr>               <dbl> <chr>           \n 1 ie-ge… 2015-08-01 AMNCH                1049 Paediatric ENT  \n 2 ie-ge… 2015-08-01 AMNCH                1049 Paediatric Gast…\n 3 ie-ge… 2015-08-01 AMNCH                1049 Paediatric Gene…\n 4 ie-ge… 2015-08-01 Bantry Gener…         704 Gastroenterology\n 5 ie-ge… 2015-08-01 Bantry Gener…         704 General Medicine\n 6 ie-ge… 2015-08-01 Bantry Gener…         704 General Surgery \n 7 ie-ge… 2015-08-01 Bantry Gener…         704 Medicine for th…\n 8 ie-ge… 2015-08-01 Bantry Gener…         704 Outreach Dermat…\n 9 ie-ge… 2015-08-01 Bantry Gener…         704 Outreach Orthop…\n10 ie-ge… 2015-08-01 Bantry Gener…         704 Outreach Surgic…\n# … with 12,268 more rows, and 2 more variables: ReferralType <chr>,\n#   TotalReferrals <dbl>\n\n마무리\n본 포스트는 fs 패키지, purrr 패키지, readr 패키지를 활용해서 폴더 내의 파일들 리스트를 가져와서 tidyverse 패키지의 도구들도 분석하기 좋은 상태인 하나의 data.frame으로 불러오는 작은 예제를 제공한다.\n한번에 동작하는 코드 전체는 아래와 같다.\ndata_dir %>% \n  dir_ls(regexp = \"\\\\.csv$\") %>% \n  map_dfr(read_csv, .id = \"source\") %>% \n  mutate(Month_Year = myd(Month_Year, truncated = 1))\ndir_ls() 함수로 data_dir 폴더내의 파일 리스트를 가져와서, read_csv() 함수를 map_dfr() 함수와 함께 리스트의 파일들을 한번에 불러옵니다. .id 인자로 source 컬럼을 추가하여 어느 파일에서 나온 데이터인지 최종 데이터셋에서 확인할 수 있습니다. 이제 dplyr 패키지로 데이터를 처리 할 준비가 되었습니다.\n코드는 조금만 바꿔서 SAS 파일이나 Excel 파일 같은 다른 파일 형식을 위한 형태로 고칠 수 있습니다. read_csv() 함수를 haven::read_sas()나 readxl::read_xlsx()로 바꾸고 regexp 인자를 해당 확장자명으로 고치는 것입니다.\nIn future posts, we’ll also look at other ways we merge a folder of data files besides “stapling” them together row-wise with map_dfr(). (역자주: stapling이 어떤 의미인지 이해하지 못해서 마지막 문장은 원문으로 두었습니다.)\n역자 의견\npurrr 패키지는 저도 아직 이해를 잘 못하고 있지만, 제대로 쓰기를 기대하는 패키지 중 하나 입니다. R이 for문의 성능이 떨어지기 때문에 apply계열 함수를 잘 사용해야 한다는 이야기들을 하지만, 모던 R 프로그래밍에서는 purrr 패키지의 map_*() 계열 함수를 잘 사용해야 하는 것 같습니다.\nKRUG에서 언뜻 map()으로 어떤 처리코드보다도 빠르게 동작하는 코드를 공유해주신 분을 기억합니다. 덕분에 관심만 두고 있었는데, 빨리 더 살펴봐야 겠네요.\n글의 내용과는 무관하게 본 포스트는 총 4줄의 코드를 설명하고 있습니다. 반성을 많이 하게 되네요.\n\n\n\n",
    "preview": {},
    "last_modified": "2021-05-05T05:36:17+00:00",
    "input_file": {}
  },
  {
    "path": "post/r과-python-중에-어떤-것을-공부해야-할까/",
    "title": "R과 Python 중에 어떤 것을 공부해야 할까",
    "description": "우선 뭐든지 시작하세요!",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2018-10-10",
    "categories": [
      "R",
      "python",
      "study",
      "discuss"
    ],
    "contents": "\n\nContents\n어디에 사용할 것인가?\npython이 왜 이렇게 인기인가?\n뭘 기준으로 선택하면 좋을까?\n왜 이런 기준을 세웠는가?\n그럼 IDE는 R은 Rstudio, python은 jupyter | pycharm 을 써야 하나?\n다시 돌아가서 결론은?\n다른 기준이 또 있나?\n각각의 생태계가 다르다던데\n\n\n한줄요약\n뭐든지 우선 시작하세요!\n이미 한물가고 필요없는 논의일 수도 있지만, 개인적을 생각을 정리한다고 생각하고 글을 시작해보겠습니다. R을 충분히 사용하고 있는 사용자로서, python은 뭐 1년 이상은 쓴 사용자로서 느끼는 점을 공유하고자 합니다. 개인적인 의견이므로 토론 대환영, 제가 모르는 정보 제공 대환영입니다.\n어디에 사용할 것인가?\n물론 데이터를 분석하는데 사용할 것입니다. R과 python은 지위가 매우 비슷합니다. 물론 python은 좀더 본격적인 범용 개발언어이고, R은 다 할 수 있지만, 통계쪽으로 특화된 패키지가 많습니다. C, Cpp, fortran 등 저수준 언어로 만들었고, 문법이 쉽습니다. 여러 외부의 리소스를 잘 활용하는 편입니다. 데이터 분석이라는 분야에서 유명합니다.\n뭐가 다른가?\n터미널, bash, 쉘 이라는 단어를 모르신다면 배워야 하는 것이 python, 몰라도 되는 것이 R입니다. 물론 Unix 계열에서 사용하시면 어짜피 그걸 쓰신다는건 안다는 소리니 패스입니다. OOP가 뭔지 알아야 python은 좀 잘 쓸 수 있고, R을 몰라도 됩니다. 이 차이는 제가 느끼기엔 python은 뭔가 사용자가 개발자이어서 만드는 소스 모두가 패키지이기를 기대하는 것 같았습니다. R은 패키지 사용자가 개발을 잘 모르기 때문에 쉽게 만들어주어야 한다는 느낌이 있습니다. 패키지 수 등을 보면 python 생태계가 10배쯤 큰데요. 물론 범용이기 때문이기도 하지만, R은 패키지 제작자도 많지 않고 좀 어려운 느낌이 있습니다.\npython이 왜 이렇게 인기인가?\n저는 딥러닝 때문이라고 봅니다만, 잘 모르겠습니다. 건너 듣기로는 python 배우는 건 어렵다는 걸 사람들이 알기 시작했다고 하기도 하고. 그렇다고 그 사람들이 사용하기에 R이 좋은가 하면 그렇지도 않은 것 같습니다. 암튼 제 생각은 python이 R보다 좋다기 보단, 그냥 유행인거 라고 생각해봅니다. (물론 제가 R 사용자니 사견이 많이 담긴 해석일 수 있습니다.)\n뭘 기준으로 선택하면 좋을까?\n저는 고독한 R 사용자(?)로 거의 영어 문서에 기반해서 독학했습니다. 물론 덕분에 패키지 개발등 좀더 유틸리티 패키지 개발자로 역할을 할 수 있었겠지요. 제 작은 희망이 있다면, R 사용자와 함께 회사일을 하는 것입니다. 그렇기에 직장인과 학생으로 나누어 조언을 하자면, 학생은 컴공 베이스라면 python을, 아니라면 R을 추천드립니다. 요즘은 워낙 기본서도 많이 나와있는 편이라, 어느 정도의 삽질을 통해 독학하거나 공부하실 수 있습니다. 직장인이라면, 직접 물어볼 수 있는 사람중에 python과 R 사용자가 있는지를 기준으로 보면 좋을 것 같습니다. 뭐가 다른가? 에서 파이썬이 더 많이 공부해야 하는 것처럼 묘사했지만, 봐줄 사람이 있다면 넘지 못할 공부도 아닙니다. 숫자 시작이 0이라는 건 익숙해지면 될 일인거죠. 물론 제가 OOP를 작성하거나 사용하는 법을 이해하는데 2년쯤 걸렸습니다만….(…)\n왜 이런 기준을 세웠는가?\npython과 R은 사실 공생관계입니다. python의 pandas는 R의 기본 자료형인 data.frame을 모방한 패키지입니다. R에는 reticulate 패키지가 python의 native-wrapper 패키지로 동작합니다. 덕분에 python 패키지 모두를 R에서 사용할 수 있죠. python에서도 마찬가지로 rpy2 패키지로 R을 모두 사용할 수 있습니다.\n그럼 IDE는 R은 Rstudio, python은 jupyter | pycharm 을 써야 하나?\n저도 상황에 따라 사용하긴 합니다만, 처음 배운 도구에서 벗어날 수 없는 것처럼 저는 jupyter가 너무 싫습니다. rstudio에서 이제 python을 지원하기 때문에 마음껏 rstudio 사용하면 됩니다. 기다린 보람이 있어서, python에서 만든 객체를 R에서 사용하는 등 호환이 좋네요. jupyter는 반대로 꽤 일찍 R을 사용할 수 있었습니다. 원체 범용 repl 도구로 개발되었었고, 최근 jupyter hub 같이 좀더 ide 같아지면서 좀 쓸만해졌다고는 합니다. pycharm은 제가 잘 안쓰게 되서 잘 모르겠습니다. 더욱 개발자들인 분들이 쓰기 좋은 기능들을 많이 가지고 있는 인상이었습니다. 제가 쓰는 수준에서는 Rstudio로 충분했습니다. 이것도 한번 소개해야 겠네요. 저는 rstudio server 버전이 있어서 docker랑 호환이 좋은게 너무 좋네요.\n다시 돌아가서 결론은?\n저만 봐도 R을 주력으로 쓰지만, Python, node 등 가리지 않고 사용하는 편입니다. (물론 Java는 정말 싫어해서 처다보고 있지도 않습니다만, 사용자층이 두터운데는 이유가 있겠죠.) 한줄 요약에도 있지만, 뭐가 되었든 우선 시작하세요. 하루라도 빨리 배우시는게 자신의 미래의 위해서 좋은 것 같습니다. 자신이 무엇을 모르는지 모르는 단계에서 벗어나셔야 성장할 수 있습니다.\n다른 기준이 또 있나?\n상황을 개인만으로 한정해 보자면, 개발과 비개발로 나누어 자신의 성향이 좀더 개발쪽이면 python, 비개발쪽이면 R을 하라고 이야기해준 적이 있습니다. 또 범용 개발 언어라는 특성이 있어, 좀 더 일반적인 개발을 함께 할 계획이라면 python을, 아니라면 R을 추천했었습니다. 다양한 일을 해야 된다고 하면 저라면 단연 R을 추천드리겠습니다만, python이 조금 더 나은 선택일 수 있습니다. 단적인 예로 마우스 오토메이션 관련된 패키지가 python에는 5개 이상인데, R에는 2개(모두 기능이 제한적임) 뿐입니다.\n각각의 생태계가 다르다던데\n맞습니다. python은 단연코 개발자 생태계입니다. 우리 나라에도 회사에서 주변을 보면(it 회사라면) python 하시는 분들이 참 많습니다. R은 해외의 통계학자들과 생물통계학자들을 위한 도구로 성장했기 때문에 학계 생태계입니다. 놀랍게도 C++을 함께 사용하는 것이 당연한 분들이 많습니다.(저는 아직 멀었습니다. 흑흑) 최근에는 비즈니스로 사용하시는 분들이 많아지는 추세이긴 합니다.\n위에서도 이야기했지만, 저의 “인상”을 작성한 것이기 때문에 사실과 괴리가 매우 클 수 있습니다. 언제든 내용 수정, 토론, 의견, 대환영입니다. 감사합니다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106514604-d2c96800-6517-11eb-8766-1641b8626a6e.png",
    "last_modified": "2021-05-05T05:35:35+00:00",
    "input_file": {}
  },
  {
    "path": "post/업무자동화-r로-마우스를-조작하려면-rmouse/",
    "title": "[업무자동화] R로 마우스를 조작하려면 rMouse",
    "description": "java 의존성이 없는 KeyboardSimulator패키지가 소개되었습니다. Windows 에서만 동작합니다.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2018-10-08",
    "categories": [
      "R",
      "rmouse",
      "automation",
      "mouse"
    ],
    "contents": "\n\nContents\n업데이트\n\n\n업데이트\njava 의존성이 없는 KeyboardSimulator 패키지가 소개되었습니다. Windows 에서만 동작합니다.\n한줄요약\nR 스크립트로 키보드/마우스를 다루는 rMouse 패키지를 사용할 수 있다.\n메일을 보내는 포스트를 작성하고 아니 업무자동화 키워드에 해당하는 패키지에 관심이 생겼습니다. 많은 업무가 웹에서 이루어진다면, 웹 api로 제공해주거나 브라우저 자동화 등을 사용할 텐데요. 어쩔 수 없이 브라우저 밖의 프로그램 들을 자동화할 일들이 있습니다. 이때 사용하는 것이 키보드/마우스 메크로 입니다.\nR 스크립트로 동작하는 것이 없는지 찾아봤는데요. 놀랍게도 있었습니다! 바로 rMouse 패키지입니다. 무려 작년 중순께 나온 싱싱한(?) 패키지입니다. 놀라운건 코드 공개를 안하셔서 문의를 메일로 해야 하네요 ㅎㅎ\n설치\n자바 의존성이 있는 패키지라 자바와 rJava 패키지가 필요합니다. 지난 포스트에 설명이 잘 나와있어서 이제 자바 의존성 패키지가 두렵지 않습니다!\ninstall.packages(\"rMouse\")\nlibrary(rMouse)\nsetAutoDelay()\n처음에 패키지가 실행되는 시간이 필요해서 setAutoDelay() 함수를 제공해준다고 합니다. library(rMouse) 다음에 연속으로 붙여 놓으면 좋겠네요!\n기능 설명\nrMouse 패키지는 크게 3가지 기능과 한 가지 중요한 옵션을 제공합니다.\n딜레이\n마우스 입력\n키보드 입력\n긴급 중단 옵션\n딜레이 먼저 볼까요?\n딜레이\nSys.sleep() 함수와 같은 기능을 제공하는 delay() 함수가 있습니다. 이건 설명이 별로 필요없겠네요.\ndelay(1000) \n긴급 중단 옵션\n이제 다른 것들을 설명하기 전에 긴급 중단 옵션을 먼저 볼까 합니다. rMouse 패키지에서 제공하는 거의 모든 함수는 failSafe 파라미터를 가지고 있습니다. 기본 값은 T인데요. 마우스를 화면 왼쪽 위 끝(x = 0, y = 0)으로 옮기면 스크립드를 중단하겠다는 뜻입니다. 키보드/마우스 자동화 단계에서 얼마나 긴급 중단이 중요한지는 아마 사용해보셨다면 잘 아실겁니다. 자기 마음대로 움직이는데, 중간에 뭘 할 수 없으면 엄청 답답하거든요.ㅎㅎ\n키보드 입력\n키보드 입력은 총 2가지 함수를 제공합니다. type() 함수와 specialKey() 함수입니다. 직접 키를 입력하는 함수와 기능 키를 입력하는 함수군요 키 입력 함수는 자바와 R의 키값이 달라서 많은 특수 문자들(+한글)이 동작하지 않는다고 합니다. 엉엉\ntype(\"This is a sentence.\")  # 대부분의 특수 문자를 제외한 글자들로 영어만 가능\ntype(\"!\")                    # 에러가 발생함\nspecialKey(\"ESC\")            # ESC 키 사용\nspecialKey(\"ENTER\")          # ENTER 키 사용\n마우스 입력\n마우스 입력은 어떤 좌표로 움직이고, 오른쪽/왼쪽 클릭을 수행하는 함수를 제공합니다.\nmove(0,0)       # 모니터 가장 왼쪽 위(0,0)로 이동\nmove(50,30)     # 좌표 x = 50, y = 30 로 이동\nleft()          # 왼쪽 클릭\nright()         # 오른쪽 클릭\n마우스의 위치를 잡아주는 coord() 함수와 pos() 함수도 제공합니다. coord() 함수는 list 자료형으로 x, y 위치를 제공하구요. pos() 함수는 x, y 위치를 콘솔에 출력해줍니다. pos() 함수가 coord() 함수로 만든 cat()(출력 함수) 함수인 것으로 보아 편한 방식으로 사용하시면 좋을 것 같습니다.\ncoord()       # 리스트 자료형으로 결과 제공\npos()         # 콘솔에 출력\n#> move(x,y)\n안타깝게도 rMouse 패키지가 사용하는 자바 패키지에는 마우스 클릭 동작을 기록하는 기능을 제공하지 않는답니다. 보통 마우스 메크로에서 recode라고 하면 클릭 할 때 딜레이와 위치, 어느 쪽 클릭인지를 기록해주는데요. 대신 비슷하게 동작을 흉내내는 recode() 함수를 제공한다고 합니다.\n# 3초 간격으로 3번 기록\nrecord(n = 3, timeInterval = 3) \n#> delay(2000); move(412,668); left()\n#> delay(2000); move(155,636); left() \n#> delay(2000); move(387,697); left()\n옵션에 n과 timeInterval 이 있는데요. n은 기록하는 갯수라는 뜻입니다. 이게 아마도 클릭하는 횟수를 흉내내려는 것 같네요. timeInterval 은 클릭을 잡지 못하니 위치를 캐치하기 위해서 어느 시간 마다 동작함같은 방식을 사용한 것 같습니다. 아래 이미지를 보시면 조금 감이 오실 것 같습니다.\n\n\n\n사용평\n간단한 자동화를 위해서는 제공하는 기능도 단순하고 이해하기 쉬워서 좋을 것 같습니다. 하지만 드래그를 지원하지 않는다던가, 제대로된 기록 기능을 제공하지 않는 점이 아쉬운 것 같습니다.\n매크로 프로그램들\n윈도우로만 한정하면 GUI까지 잘 제공하는 무료 프로그램이 몇 개 있습니다.\nG Macro\nG Macro은 2버전이 2003년에 나오고 지금도 관리자 권한으로 실행하면 win10에서 잘 동작한다고 합니다. 나무위키에 자세하게 설명이 잘 나와있네요.\n\n\n키보드/마우스 매크로\n키보드/마우스 매크로라는 이름으로 v1, v2, 비활성화 윈도우 버전 총 3개를 제공합니다. v1은 단순 버전, v2는 고급 버전이라고 하네요.\n\n\n이것도 12년 정도에 제작하시고 이후에 업데이트가 없긴 하군요. 그래도 무리없이 작동하는 것 같습니다.\n기타\n오토 마우스류라고 불리는 프로그램들이 게임 쪽에서 많이 사용되었습니다. 대표적으로는 졸라빨라 같은 프로그램이 있는데요. 이것도 개발이 중간에 중지된 모양입니다. 그리고 게임 광클에 맞게 개발된 프로그램이라 업무자동화에는 조금 맞지 않습니다.\n맥용은 없는가?\n맥은 검색해보면 몇 가지 나오기는하는데, 제가 시도해보지를 못하고 있네요. 맥은 AppleScript와 Automator를 자체적으로 지원합니다. 뭔가 다른 세상 이야기 같네요. 혹시 잘 정리된 글이 있으면 추가, 공유하도록 하겠습니다. 사실 한국에서 화면 자동화 니즈는 윈도우 전용 클라이언트들(은행의 기업용 프로그램이라던가..)이기 때문에 필요성을 못 느끼겠네요.\n언제나처럼, 오타 질문 등등 대환영입니다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106513782-bbd64600-6516-11eb-8dd2-ed780e8ee85a.png",
    "last_modified": "2021-05-05T05:36:25+00:00",
    "input_file": {}
  },
  {
    "path": "post/업무자동화-r로-이메일을-보내려면-sendgridr/",
    "title": "[업무자동화] R로 이메일을 보내려면 sendgridr",
    "description": "메일 보내기는 업무 자동화를 위해서 꼭 필요한 기능이다. 기존의 패키지인 mailR, sendmailR은 자바 의존성이 있거나 smtp 서버를 활용하는 형태이다. sendgrid 서비스가 매일 100건 평생 무료로 준대서 패키지를 만들어봤다.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2018-10-02",
    "categories": [
      "R",
      "automation",
      "email",
      "gmail",
      "sendgridr"
    ],
    "contents": "\n\nContents\nsendgridr\ngmail로 받을 때\n업무자동화에서 메일 보내기란\n\n\n세줄요약\n메일 보내기는 업무 자동화를 위해서 꼭 필요한 기능이다.\n기존의 패키지인 mailR, sendmailR은 자바 의존성이 있거나 smtp 서버를 활용하는 형태이다.\nsendgrid 서비스가 매일 100건 평생 무료로 준대서 패키지를 만들어봤다.\n업무 자동화는 매우 매력적인 키워드입니다. 세상에 내가 하는 일을 컴퓨터가 대신 하게 해준다니! 여러 가지 작업을 코딩할 수 있겠지만, R의 장점은 결과에 대한 보고서 딜리버리라고 생각합니다. 전달의 완성은 역시 이메일이죠! 물론 최근에는 슬랙같은 도구도 많이 사용하기 때문에 slackr같은 도구가 더 좋을 수 도 있을 것 같습니다.\n그래도 역시 이메일이지! 라고 생각하는 분들을 위해 R로 이메일을 보내는 법을 좀 찾아봤습니다. 대체 최근 스타일의 메일 보내는 도구가 없더군요. 가장 잘 관리되고 있는 패키지는 mailR 이었습니다. 문제는 두 가지 허들이 있더군요.\n하나는 아파치 지원 프로젝트인 commons을 사용한다는 점 이었습니다. 이게 java라 rJava가 필요하죠. rJava는 지난 포스트인 Windows에서 rJava 스트레스 없이 설치하기를 참고해주세요. 이곳에 훌륭한 튜토리얼이 있습니다.\n다른 문제는 smtp 서버를 사용한다는 점입니다. 많이 사용하는 gmail의 smtp 서버를 사용하려면 위의 튜토리얼에서도 google 서비스 접근에 대한 보안 수준을 낮춰야 한다고 알려주고 있습니다. 그렇다고 smtp 서버를 직접 구축할 수 도 없는 노릇인거죠.\n\n보안 수준을 낮춰야 한다니… 불안하기만 하다\n대신 안정적으로 동작하는 패키지라는 걸 아파치의 지원 프로젝트를 활용하기 때문에 신뢰할 수 있습니다. 2016년이 마지막 업데이트인데요. 메일 기능이 더 업데이트 할 만한게 뭐가 있을까 싶기도 합니다.\n두 번째로 조금 더 오래됬지만, 매달 5,000 다운로드가 발생하는 대중적인 패키지로 sendmailR이 있습니다. 거의 같은 사용성을 보여주고 있는데요. 이건 감사하게도 java 의존성 같은게 없는 훨씬 단순한 구조입니다. 역시나 허들은 smtp 메일 서버가 있어야 한다는 점입니다.\n그래서 뭔가 api로 메일 전송 서비스를 제공해주는 곳이 어디 없나 찾아봤습니다.\n\n메일 전송 api를 제공해주는 서비스들\nmailchimp는 세상 유명한 서비스입니다. 이메일 마케팅을 하시는 분들이라면 잘 활용하면 좋을 서비스이지요. sendinblue, sendgrid 모두 경쟁사입니다.\n제가 찾는 api는 이메일을 보낼 수 있으면 충분합니다. 세 서비스 중에 가장 일별 무료 전송량이 적지만(일 100건), api가 단순한 서비스는 sendgrid 였습니다.\n\n낙점!\nsendgridr\n이제 sendgrid api의 wrapper 패키지인 sendgridr을 소개합니다.\n\nsendgridr은 크게 2가지 기능을 담당합니다.\n1. sendgrid api 키 등록 및 확인\n우선 sendgrid를 이용에 메일을 보내기 위해서는 당연히도 회원가입을 해야 합니다.\nsendgrid 회원가입\n\n우선 sendgrid 홈페이지로 가주세요. Sign up 버튼을 누르면 어떤 플랜을 선택할지 물어봅니다.\n\n우리는 당연히 free 플랜을 선택합니다.\n\n이제야 익숙한 아이디, 비번, 이메일을 입력하라고 하는군요.\n\n기업 고객 유치를 위해서 추가 정보를 요구합니다.\n\n서비스에겐 미안하지만 아무 정보나 입력했습니다.\n\n드디어 회원가입을 끝냈습니다.\n\n서비스를 사용하기 위해서는 이메일을 확인해야 합니다. 가입때 사용한 이메일에 들어가보면 확인 메일이 와있을 텐데요.\n\nConfirm Email Address 버튼을 눌러서 계정을 활성화해 주세요.\napi key 발급\n우선 패키지를 설치해보겠습니다.\n\n\n# remotes::install_github(\"mrchypark/sendgridr\")\nlibrary(sendgridr)\n\n\n\n이제 api 서비스를 사용하기 위해 api key를 발급받아 보겠습니다. sendgridr 패키지는 auth_set() 함수를 이용해 키를 등록합니다.\n\n영어로 질문이 나오면서 3가지 선택지가 나오는데요. No에 해당하는 것 2개와 Yes에 해당하는것 1개가 다양한 표현으로 나옵니다. 생각없이 선택하는 걸 방지하려고 이런 설계를 한 모양이네요.(읭? usethis 함수를 사용한 겁니다. ㅋㅋ)\n\n이미 api key가 있냐고 물어보네요. 저는 아니오에 해당하는 1을 입력하겠습니다.\n\n그럼 api key를 신청할 수 있는 페이지를 열어줍니다! 제 스크린샷에는 이미 2개의 키가 만들어져 있지만, 여러분은 아마도 비어있을 것입니다. 우선 rstudio에서의 작업을 마저하도록 할까요?\n\n2번째 질문이 나옵니다. 이제 등록해야 할 api key를 R 사용 환경 전체에서 쓸 것인지, 현재 프로젝트에서만 사용할 것인지 물어봅니다. rstudio는 project라는 관리 단위를 나누는 기능을 제공합니다. 잘 모르신다면 yes를 선택하시고, 아신 다면 상황에 맞게 선택해주세요. 저는 yes에 해당하는 3번을 입력했습니다. 계속 yes의 위치가 바뀌니 화면을 따라 3을 입력하지 마시고, 선택지를 잘 확인해주세요.\n\nsendgridr 패키지는 api key를 .Renviron 파일에 관리하는 것을 권장합니다. .Renviron 파일은 R의 환경 변수를 기록하고 Sys.getenv() 함수로 값을 사용할 수 있게 해줍니다. 변수명은 SENDGRID_API로 기록하면 되는군요. 이제 다시 브라우저로 돌아가서 key를 만들어 볼까요?\n\n오른쪽 위에 Create API Key를 클릭합니다.\n\nkey를 관리할 이름을 정합니다. 저는 그냥 test라고 작성했습니다. 권한는 Full Access로 설정해주세요.\n\napi key를 발급받았습니다! 매우 긴 문자열로 이걸 복사해서 아까 .Renviron 파일에 저장하면 되겠네요. 글자를 클릭하면 자동으로 복사를 수행해 줍니다.\n\n복사를 해야만, 다음 화면으로 넘어갈 수 있군요. 참고로 지금 한번 알려주고 끝입니다. 복구고 뭐고 아예 없어요. 대신 지우고 새로 만들면 됩니다. ㅎㅎ 저도 맘편히 스크린샷에 공개했는데요. 진작에 지웠습니다.\n\n.Renviron 파일에 저장한 모습입니다. 이 파일을 저장하고 나면 적용하기 위해서 R session을 재시작해야 합니다. rstudio를 껏다가 켜도 좋고, Ctrl+Shift+F10을 입력해도 됩니다. 저는 rstudioapi::restartSession() 함수로 재시작했습니다. 이제 잘 동작하는지 확인해 볼까요?\n\nauth_check() 함수는 api key가 잘 등록되어 있는지, 동작하는 키인지 서비스에 확인하는 작업을 합니다. 잘 동작한다니 드디어 key 설정을 완료했습니다!\n2. mail 작성 및 보내기\nsendgrid는 mail에 대한 정보를 json 형태로 받습니다. 막상 양식에 맞는 형태로 작성하려고 하면 불편한 부분이 있더라구요. sendgridr 패키지는 mail(), to(), cc(), from 등 메일을 보내기 위한 정보를 구성하는 함수들을 제공하고 있습니다. 여기에서 어떤 것을 제공하는지 확인해보세요.\n파이프 연산자%>%를 지원할 수 있게 작성하려고 노력했습니다.\n\n\nlibrary(sendgridr)\nmail() %>% \n  from(\"example1@mail.com\", \"example name for display\") %>% \n  to(\"example2@mail.com\", \"example name for display 2\") %>% \n  subject(\"test mail title\") %>% \n  content(\"hello world!\")  %>% \n  ## attachments is optional\n  attachments(\"report.html\") %>% \n  send()\n\n\n\n테스트 할 때는 한글도 문제없이 동작하는 것을 확인했습니다. 전송이 잘 이루어진다면 위 코드를 수행했을 때 NULL이 출력될 것입니다. 혹시 NULL이외의 출력(대부분 에러 메세지입니다.)이 나오면 여기에 알려주세요.\ngmail로 받을 때\n회사에서 G Suits를 사용하고 있다보니 회사 메일이 gmail 입니다. 메일의 body 부분(패키지에서는 content)에 html로 전송을 지원하길래 시도해봤는데요. rmd로 만든 html 파일을 사용하니, 삽입된 그림은 막고, 여러 스타일을 제거해서 보여주는 것을 확인했습니다. 아직은 사용하기 어렵겠네요.ㅜㅠ 우선은 첨부파일로 해결이 가능할 것 같기는 한데요. 메일 본문에 요약된 내용을 추가하는 방법을 찾아봐야 할 것 같습니다.\n첨부하는 파일 확장자를 rmd로 받고, rendering과 후처리를 패키지내에 포함하는 것이 좋겠네요.\n업무자동화에서 메일 보내기란\n업무 자동화는 데이터 소스의 접근, 처리, 보고서 생성, 전달, 스케줄러 등 다양한 기능을 해야 합니다. 그 중에 메일 보내기는 최종 단계로 꼭 필요하다고 할 수 있죠. 회사에서 smtp 서버를 운용하는 중이라면 sendmailR 패키지가 좋은 선택일 것입니다. 스케줄러로 정기적으로 메일을 보내게도 할 수 있을 것이구요. 이렇게 업무자동화에 도움이 되는 패키지들을 만들거나 소개하는 것을 좀 해봐야 겠습니다.\n언제나처럼 문의, 오타 제보 등 대환영입니다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106548932-49d02200-6553-11eb-9afd-aa6b97a11c13.png",
    "last_modified": "2021-05-05T05:36:37+00:00",
    "input_file": {}
  },
  {
    "path": "post/rtips-tbl-자료형에서-소수점을-출력해보자/",
    "title": "[Rtips] tbl 자료형에서 소수점을 출력해보자",
    "description": "options(pillar.sigfig=10) 함수는 tibble 자료형에서 소수점 자리수를 조절하는 기능을 제공합니다.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2018-08-22",
    "categories": [
      "R",
      "tbl",
      "tibble",
      "digit",
      "options"
    ],
    "contents": "\n\n한줄요약\noptions(pillar.sigfig=10)\ntidyverse 생태계는 R의 현재 부흥기를 이끌고 있습니다. magrittr 패키지가 쏘아올린 %>%(파이프 연산자)가 이렇게 될꺼라고 상상이나 했을까요. 해들리 위컴이 발표한 tidy data와 함께 tidyverse에서는 없는게 상상도 할 수 없는 것이 많습니다.\n이런 tidyverse에서 data를 담당하는 패키지가 tibble입니다.\n\ntibble은 tbl, tbl_df 등등의 자료형으로 표현됩니다. 위에 그림에도 보이는 것처럼 data.frame과 같은 역할을 하면서, 더 세련됬다고 할까요.\n그 와중에 tibble의 출력을 담당하는 패키지가 pillar입니다.\n\n\n# install.packages(\"pillar\")\nlibrary(pillar)\nx <- 123456789 * (10 ^ c(-3, -5, NA, -8, -10))\nx\n\n\n[1] 1.234568e+05 1.234568e+03           NA 1.234568e+00 1.234568e-02\n\npillar(x)\n\n\n      <dbl>\n123457.    \n  1235.    \n    NA     \n     1.23  \n     0.0123\n\n마크다운에는 디테일이 표현되지 않아 사진을 첨부합니다. \n3자리 마다 쉼표로 표시하는 관행을 출력해주기 위해, pillar 패키지는 밑줄을 사용합니다. 보기 참 좋아진거 같습니다!\n그러다 보니… 소수점 표기의 출력 옵션이 기존의 data.frame과 다릅니다. 찾아보니 options(pillar.sigfig)를 조절하면 된다는군요!\noptions(pillar.sigfig)\n## Error in options(pillar.sigfig) : object 'pillar.sigfig' not found\n기본 값이 없는거 같습니다….(;;;) 패키지에는 3이 기본값이라고 하는데 어떻게 보는지 모르겠네요;;; 이젠 tibble에서 확인해 볼까요?\n\n\nmy_numbers <-  c(233, 486, 565, 785)\ntbl_num <- tibble::tibble(\n  big = 1000 * my_numbers + 23,\n  stradle = my_numbers / 1000 + 100,\n  small = my_numbers / 100000\n)\ntbl_num\n\n\n# A tibble: 4 x 3\n     big stradle   small\n   <dbl>   <dbl>   <dbl>\n1 233023    100. 0.00233\n2 486023    100. 0.00486\n3 565023    101. 0.00565\n4 785023    101. 0.00785\n\n출력을 보면 stradle 컬럼의 첫번째 데이터가 100.라고 되어 있습니다. 100이 아니고 100.이라고 출력해주면서 소수점 숫자가 있음을 알려주는데요. 관련 이슈도 있으니 읽어보시면 좋을 것 같구요.\n\n\noptions(pillar.sigfig = 7)\ntbl_num\n\n\n# A tibble: 4 x 3\n     big stradle       small\n   <dbl>   <dbl>       <dbl>\n1 233023 100.233 0.00233    \n2 486023 100.486 0.00486    \n3 565023 100.565 0.00565    \n4 785023 100.785 0.007850000\n\npillar의 sigfig 옵션은 사실 소수점에 해당하는 옵션이 아닙니다. 유효숫자에 대한 옵션이죠. 유효숫자는 또 큰 주제니까 다음에 다루기로 하구요.\npillar에서는 출력에 대한 옵션을 제공하고 있습니다.\n\n한번 읽어보시면 취향껏 고치는데 도움이 되지 않을까요?ㅎㅎ\n감사합니다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106503266-c4278480-6508-11eb-9ef3-67adb5ed64ce.png",
    "last_modified": "2021-05-05T05:35:05+00:00",
    "input_file": {}
  },
  {
    "path": "post/패키지-소개-nosql-데이터베이스를-다루는-nodbi/",
    "title": "[패키지 소개]NoSQL 데이터베이스를 다루는 nodbi",
    "description": "이제 R로 MongoDB, Redis(server based), CouchDB, Elasticsearch, etcd를 다룰 수 있습니다.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2018-08-08",
    "categories": [
      "R",
      "nosql",
      "dbi",
      "package"
    ],
    "contents": "\n\n한줄요약\n이제 R로 MongoDB, Redis(server based), CouchDB, Elasticsearch, etcd를 다룰 수 있습니다.\nR에는 여러가지 데이터 베이스를 다루는 도구들이 있습니다. MS의 표준 SQL 드라이버인 ODBC를 사용하는 odbc 패키지(r-dbi 팀), java의 표준 SQL 드라이버인 JDBC를 사용하는 RJDBC 패키지(rJava 개발자 Simon Urbanek), r-dbi팀이 직접 관리하는 DBI 패키지가 대표적입니다.\n이외에도 개인들이 개발하거나 각 데이터베이스에 맞춰 만든 도구들이 있는데요. 대부분 위의 패키지들을 사용해서 연결 부분을 쉽게하거나, 데이터 베이스가 통신 프로토콜을 지원해서 wrapper를 만든다거나 하는 경우인거 같습니다.\n아무튼!\n데이터베이스는 관계형이라고 말하는 RDB 계열과 문서형이라고 부르는 NoSQL 계열이 있습니다. 특별히 NewSQL 계열이라고 말하는 부류도 있습니다. 위에서 이야기한 DBI 등등의 드라이버는 표준 SQL 문법을 지원하는 관계형 DB들을 다룰 때 사용합니다. 이제 그에 대응하는 NoSQL을 다루기 위한 R 패키지가 등장했는데요. 바로 nodbi 패키지입니다.\n문서에 따르면 nodbi 패키지는 대표적인 NoSQL 데이터베이스인 mongoDB에서부터 엘라스틱서치까지 총 5개의 NoSQL 데이터베이스를 지원합니다. ropensci 팀이 r-dbi 팀이 부러웠는지 공통으로 사용할 수 있는 패키지를 제작하기 시작했네요. 이제 0.1.0 버전으로 초기 단계라고 볼 수 있습니다. 그동안 각 디비 api에 맞춰 개별로 관리되고 있는 패키지들이 있었습니다. 현재 유지관리가 되고 있는 패키지들은\nMongoDB : mongolite\nRedis : redux\nCouchDB : sofa\nElasticsearch : elastic\netcd : etseed\n각자 쉬운 문법을 사용하기 위해 노력했지만 가장 큰 문제점은 dplyr 패키지와의 호환성이었습니다. Elasticsearch의 경우는 파이프 연산자를 지원하는 elasticdsl 패키지가 있지만, 자신의 특수한 문법만 사용할 수 있습니다.\n위의 개별 패키지들과는 다르게 nodbi는 dplyr 패키지와의 호환성을 목표로 개발이 시작되었습니다. 갈길이 구만리이긴 하겠지만, dplyr로 대동단결하면 할 수록 R 사용자들는 추가적인 공부없이 많은 패키지들을 다룰 수 있게 되겠지요.\nsparklyr도 써봐야 하는데, 새로 생기는 것만 늘어가는 군요.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106499231-b02d5400-6503-11eb-8995-40307c1ace35.png",
    "last_modified": "2021-05-05T05:36:43+00:00",
    "input_file": {}
  },
  {
    "path": "post/패키지-소개-암호화폐-시세와-인덱스를-제공하는-ubci-패키지를-소개합니다/",
    "title": "[패키지 소개] 암호화폐 시세와 인덱스를 제공하는 ubci 패키지를 소개합니다",
    "description": "ubci 패키지 개발을 시작하였습니다.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2018-05-18",
    "categories": [
      "R",
      "ubci",
      "crypto",
      "package"
    ],
    "contents": "\n\nContents\n함수 예\n라이선스 문제\n패키지 계획\n\n\n세줄요약\n암호화폐 관련 시세와 인덱스 정보를 제공하는 ubci 패키지를 공개함.\nubci는 upbit에서 제공하는 데이터로 비영리 배포는 자유라고 해서 개발함.\n데이터 라이선스는 또 다른 문제이니 ubci 가서 확인바람.\n암호화폐는 2017년의 붐을 기점으로 사회 곳곳에 그 존재감을 드러내고 있습니다. 여러 이슈가 있긴 하지만 국내에는 4대 거래소(빗썸, 업비트, 코빗, 코인원)외에도 새로운 거래소들이 속속 나타고 있는 중입니다. 이외에도 카카오와 라인(네이버)이 각각 암호화폐 전문 자회사를 세우는 등 기업의 관심이 그 어느때보다 높습니다.\n아직 이슈가 안정적인 분야가 아니다 보니 이슈 파이팅이 그 어느 분야보다 중요한데요. 현시간 코인마켓캡 기준 전세계 거래량 6위쯤 되는 upbit가 코인 인텍스를 들고나왔습니다. 바로 UBCI입니다. 저도 관심이 가는 내용이라 사이트를 둘러보았는데, 데이터를 깨끗하게 제공하더라구요. 그래서 간단하게 R 패키지화 해보았습니다. 놀랍게도 패키지 이름은 ubci입니다.\n## github에서 패키지 설치\nremotes::install_github(\"mrchypark/ubci\")\n한글 데이터가 포함되어 있으니 인코딩이 UTF-8인지 확인해 주세요.\n\n\nSys.getlocale()\n\n\n[1] \"en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\"\n\n함수 예\n패키지가 리드미와 설명서를 제공하고 있지만 저도 다시 사용해 보겠습니다.\n인덱스 코드 가져오기\nubci_index_options() 함수는 인덱스를 가져오기에 앞서 인덱스의 이름과 설명을 알려줍니다.\n\n\nlibrary(ubci)\nubci_index_options()\n\n\n# A tibble: 26 x 4\n   index   name               cate     smry                           \n   <chr>   <chr>              <chr>    <chr>                          \n 1 UBMI    UBMI(Upbit Market… Market … \"It is calculated for all digi…\n 2 UBMI_ST UBMI BTC quote(Up… Market … \"It is the index that is conve…\n 3 UBAI    UBAI(Upbit Altcoi… Market … \"It is calculated for all digi…\n 4 UBAI_ST UBAI BTC quote(Up… Market … \"It is the index that is conve…\n 5 UTTI    UBMI 10(Upbit Top… Market … \"It is an index that comprises…\n 6 UTHI    UBMI 30(Upbit Top… Market … \"It is an index that comprises…\n 7 THMIDX… NFT & Collectibles Theme I… \"\"                             \n 8 THMIDX… Oracles            Theme I… \"\"                             \n 9 THMIDX… IoT                Theme I… \"\"                             \n10 THMIDX… Smart Contracts    Theme I… \"\"                             \n# … with 16 more rows\n\n자료형은 tbl로 되어 있네요. 주식 분석 패키지의 최강자인 tidyquant와 상성을 고려한 선택이었습니다. ubci_index_options() 함수는 lang 인자로 언어를 변경할 수 있습니다.\n\n\nubci_index_options(lang=\"ko\")\n\n\n# A tibble: 26 x 4\n   index   name               cate    smry                            \n   <chr>   <chr>              <chr>   <chr>                           \n 1 UBMI    UBMI(Upbit Market… 시장 인덱스… 업비트 거래소에 상장된 모든 디지털 자산을 대상으로 산출…\n 2 UBMI_ST UBMI BTC quote(Up… 시장 인덱스… UBMI 인덱스를 비트코인 기준으로 환산한 인덱스…\n 3 UBAI    UBAI(Upbit Altcoi… 시장 인덱스… 업비트 거래소에 상장된 모든 디지털 자산에서 비트코인을 …\n 4 UBAI_ST UBAI BTC quote(Up… 시장 인덱스… UBAI 인덱스를 비트코인 기준으로 환산한 인덱스…\n 5 UTTI    UBMI 10(Upbit Top… 시장 인덱스… 업비트에 상장된 디지털 자산 중, 시가총액 상위 10개 …\n 6 UTHI    UBMI 30(Upbit Top… 시장 인덱스… 업비트에 상장된 디지털 자산 중, 시가총액 상위 30개 …\n 7 THMIDX… 대체불가능 토큰    테마 인덱스… NFT 자산을 생성, 탐색 및 거래 등이 가능한 플랫폼을…\n 8 THMIDX… 오라클             테마 인덱스… 오라클을 활용하는 디지털 자산으로 구성된 테마 인덱스…\n 9 THMIDX… 아이오티           테마 인덱스… 사물인터넷 기술을 활용하여 시간 단축 및 정보의 보안성을…\n10 THMIDX… 스마트컨트랙       테마 인덱스… 스마트컨트랙을 활용하는 디지털 자산으로 구성된 테마 인덱…\n# … with 16 more rows\n\n인덱스 데이터\nubci_index() 함수는 인덱스의 일별 시가, 고가, 저가, 종가, 거래량을 제공합니다. from,to 인자로 기간을 조절할 수 있습니다.\n\n\nloi<-ubci_index_options()\nloi$index[1]\n\n\n[1] \"UBMI\"\n\nubci_index(loi$index[1])\n\n\n# A tibble: 1,000 x 6\n   index date           open     high      low    close\n   <chr> <date>        <dbl>    <dbl>    <dbl>    <dbl>\n 1 UBMI  2021-05-05 12503.34 13120.09 12413.45 12979.69\n 2 UBMI  2021-05-04 12931.43 13128.44 12308.55 12497.18\n 3 UBMI  2021-05-03 12178.94 12956.16 12158.04 12929.46\n 4 UBMI  2021-05-02 12234.26 12298.73 11792.78 12175.49\n 5 UBMI  2021-05-01 11833.61 12231.74 11724.41 12231.69\n 6 UBMI  2021-04-30 11251.11 11914.70 11193.33 11835.06\n 7 UBMI  2021-04-29 11207.69 11335.42 10943.80 11249.82\n 8 UBMI  2021-04-28 11232.85 11431.43 10765.95 11212.11\n 9 UBMI  2021-04-27 10987.28 11241.48 10821.94 11232.15\n10 UBMI  2021-04-26 10162.51 11002.85 10007.99 10989.07\n# … with 990 more rows\n\ntail(ubci_index(loi$index[1], from=\"2018-05-15\"))\n\n\n# A tibble: 6 x 6\n  index date           open     high      low    close\n  <chr> <date>        <dbl>    <dbl>    <dbl>    <dbl>\n1 UBMI  2018-08-15 1288.161 1366.845 1287.839 1307.427\n2 UBMI  2018-08-14 1325.461 1325.461 1217.292 1288.603\n3 UBMI  2018-08-13 1374.802 1413.461 1313.919 1325.559\n4 UBMI  2018-08-12 1366.355 1400.096 1357.355 1374.140\n5 UBMI  2018-08-11 1383.252 1410.888 1332.595 1365.806\n6 UBMI  2018-08-10 1456.362 1465.306 1365.788 1382.457\n\nubci_index(loi$index[1], to=\"2018-05-15\")\n\n\n# A tibble: 0 x 6\n# … with 6 variables: index <chr>, date <date>, open <dbl>,\n#   high <dbl>, low <dbl>, close <dbl>\n\nubci_index(loi$index[1], from=\"2018-05-10\", to=\"2018-05-15\")\n\n\n# A tibble: 0 x 6\n# … with 6 variables: index <chr>, date <date>, open <dbl>,\n#   high <dbl>, low <dbl>, close <dbl>\n\n암호화폐 코드\nubci_get_options() 함수는 취급하는 암호화폐의 종류를 이름과 코드로 제공합니다.\n\n\nubci_get_options()\n\n\n# A tibble: 793 x 5\n   code           name             exchange tradeStatus marketState\n   <chr>          <chr>            <chr>    <chr>       <chr>      \n 1 UPBIT.KRW-BTC  Bitcoin          UPBIT    ACTIVE      ACTIVE     \n 2 UPBIT.KRW-DASH Dash             UPBIT    DELISTED    DELISTED   \n 3 UPBIT.KRW-ETH  Ethereum         UPBIT    PREVIEW     ACTIVE     \n 4 UPBIT.BTC-NEO  NEO              UPBIT    DELISTED    DELISTED   \n 5 UPBIT.BTC-ETH  Ethereum         UPBIT    PREVIEW     ACTIVE     \n 6 UPBIT.BTC-LTC  Litecoin         UPBIT    PREVIEW     ACTIVE     \n 7 UPBIT.BTC-XRP  Ripple           UPBIT    PREVIEW     ACTIVE     \n 8 UPBIT.BTC-ETC  Ethereum Classic UPBIT    PREVIEW     ACTIVE     \n 9 UPBIT.BTC-OMG  OmiseGo          UPBIT    PREVIEW     ACTIVE     \n10 UPBIT.BTC-CVC  Civic            UPBIT    PREVIEW     ACTIVE     \n# … with 783 more rows\n\nubci_get_options() 함수 역시 한글 옵션을 제공합니다.\n\n\nubci_get_options(lang=\"ko\")\n\n\n# A tibble: 793 x 5\n   code           name           exchange tradeStatus marketState\n   <chr>          <chr>          <chr>    <chr>       <chr>      \n 1 UPBIT.KRW-BTC  비트코인       UPBIT    ACTIVE      ACTIVE     \n 2 UPBIT.KRW-DASH 대시           UPBIT    DELISTED    DELISTED   \n 3 UPBIT.KRW-ETH  이더리움       UPBIT    PREVIEW     ACTIVE     \n 4 UPBIT.BTC-NEO  네오           UPBIT    DELISTED    DELISTED   \n 5 UPBIT.BTC-ETH  이더리움       UPBIT    PREVIEW     ACTIVE     \n 6 UPBIT.BTC-LTC  라이트코인     UPBIT    PREVIEW     ACTIVE     \n 7 UPBIT.BTC-XRP  리플           UPBIT    PREVIEW     ACTIVE     \n 8 UPBIT.BTC-ETC  이더리움클래식 UPBIT    PREVIEW     ACTIVE     \n 9 UPBIT.BTC-OMG  오미세고       UPBIT    PREVIEW     ACTIVE     \n10 UPBIT.BTC-CVC  시빅           UPBIT    PREVIEW     ACTIVE     \n# … with 783 more rows\n\n암호화폐 시세 정보\nubci_get() 함수 또한 암호화폐의 일별 시가, 고가, 저가, 종가, 거래량을 제공합니다.\n\n\nloc<-ubci_get_options()\nloc$code[1]\n\n\n[1] \"UPBIT.KRW-BTC\"\n\nubci_get(loc$code[1])\n\n\n# A tibble: 400 x 7\n   code       date           open     high      low    close    volume\n   <chr>      <date>        <dbl>    <dbl>    <dbl>    <dbl>     <dbl>\n 1 UPBIT.KRW… 2021-05-05 66828000 69751000 66500000 68889000  3523.890\n 2 UPBIT.KRW… 2021-05-04 69996000 70490000 66500000 66829000 12631.45 \n 3 UPBIT.KRW… 2021-05-03 68452000 70999000 68281000 69996000  9426.098\n 4 UPBIT.KRW… 2021-05-02 69041000 69297000 66803000 68452000  7970.058\n 5 UPBIT.KRW… 2021-05-01 67956000 69386000 67557000 69049000  9860.608\n 6 UPBIT.KRW… 2021-04-30 63816000 68540000 63500000 67939000 18322.27 \n 7 UPBIT.KRW… 2021-04-29 64060000 64900000 63000000 63814000  9270.475\n 8 UPBIT.KRW… 2021-04-28 64759000 65899000 62608000 64100000  8304.377\n 9 UPBIT.KRW… 2021-04-27 64198000 65000000 63375000 64767000  8003.356\n10 UPBIT.KRW… 2021-04-26 59850000 64300000 59075000 64198000 10197.96 \n# … with 390 more rows\n\ntail(ubci_get(loc$code[1], from=\"2018-05-15\"))\n\n\n# A tibble: 6 x 7\n  code          date          open    high     low   close    volume\n  <chr>         <date>       <dbl>   <dbl>   <dbl>   <dbl>     <dbl>\n1 UPBIT.KRW-BTC 2020-04-06 8198000 8800000 8183000 8786000  8571.071\n2 UPBIT.KRW-BTC 2020-04-05 8248000 8280000 8100000 8198000  2884.409\n3 UPBIT.KRW-BTC 2020-04-04 8149000 8333000 8100000 8249000  3955.733\n4 UPBIT.KRW-BTC 2020-04-03 8160000 8434000 8041000 8156000  7822.877\n5 UPBIT.KRW-BTC 2020-04-02 8065000 8505000 7989000 8174000 12240.95 \n6 UPBIT.KRW-BTC 2020-04-01 7799000 8096000 7529000 8074000  6726.180\n\nubci_get(loc$code[1], to=\"2018-05-15\")\n\n\n# A tibble: 0 x 7\n# … with 7 variables: code <chr>, date <date>, open <dbl>,\n#   high <dbl>, low <dbl>, close <dbl>, volume <dbl>\n\nubci_get(loc$code[1], from=\"2018-05-10\", to=\"2018-05-15\")\n\n\n# A tibble: 0 x 7\n# … with 7 variables: code <chr>, date <date>, open <dbl>,\n#   high <dbl>, low <dbl>, close <dbl>, volume <dbl>\n\n라이선스 문제\nubci와 시세는 라이선스가 다를텐데요. ubci는 메인 페이지에서 데이터 라이선스와 법적 이슈에 대해 고지하고 있습니다. 시세는 제가 못찾은건지 데이터관런 라이선스 고지를 찾을 수가 없네요.\nubci는 비영리 배포에 대해 허용하고 있어 마음껏 작성하였구요. 시세는 하는김에 라는 느낌이라서 업비트에서 뭐라고 하면 내릴 계획입니다.\n패키지 계획\n만들다 보니 ubci의 세부 정보(ex> 구성 화폐시세와 비율, 추가 설명 등)가 함께 있으면 좋겠다 싶어서 추가하려고 계획하고 있습니다. 시세쪽은 지금은 데일리만 있는데, 분단위 정보를 제공하기는 하더라구요. 비정상 이용에 대해 막을 가능성이 높긴 하지만, 제한적으로나마 분단위나 15분 단위의 데이터를 제공하는 함수를 만들 수 있을 것 같습니다.\n깃헙주소는 https://github.com/mrchypark/ubci 입니다. 재밌게 보신 분들은 별이라도 한번 눌러주시구요. 설명의 추가나 위에 예정중인 함수 작성, 테스트 케이스 작성등 패키지 개발을 위해서 아직 남은 일이 많은데요. 도움 주시는 분이 계시면 정말 감사할 것 같습니다.\n언제나처럼 문의나 잘못된 점 등 알려주시면 반영하겠습니다. 감사합니다.\np.s 간단한 분석을 포함한 영문 포스팅을 해주실 용자분을 찾습니다. 해외에서도 관심가질만한 주제라고 생각해서 소개하고 싶은데, 제가 능력이 안되네요. 감사합니다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106495895-9558e080-64ff-11eb-9fd5-9d5ffeea0fcc.png",
    "last_modified": "2021-05-05T05:37:03+00:00",
    "input_file": {}
  },
  {
    "path": "post/패키지-소개-네이버-뉴스와-다음-뉴스의-댓글-가져오기/",
    "title": "[패키지 소개] 네이버 뉴스와 다음 뉴스의 댓글 가져오기",
    "description": "DNH4가 댓글 수집을 드디어 지원합니다. 덕분에 N2H4도 함께 홍보합니다.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2018-05-14",
    "categories": [
      "R",
      "N2H4",
      "DNH4",
      "comment",
      "forkonlp"
    ],
    "contents": "\n\n한줄요약\nDNH4가 드디어(!) 댓글 수집을 지원합니다.\n처음 naverNewsParser를 습작처럼 시작하고, N2H4 패키지로 이전하면서 여러 경험을 했습니다. naverNewsParser는 기가막히게도 책에 실린 모양이더군요. 고학력자들에게 석사 논문 낭독이 거대한 괴롭힘이듯 naverNewsParser가 약간 저에게 그런 역할을 해주는 것 같습니다. (물론 사용해 주시는 모든 분들 감사드립니다.)\n이렇게 저렇게 패키지를 뭐라도 만들어 보고, 그 이후로도 많은 일들이 있었습니다. N2H4 패키지는 저에게 많은 생각을 하게 만들어주었죠.\n조금 익숙해지고 난 이후에는 다음 뉴스를 대상으로 하는 비슷한 패키지를 만들어야 겠다는 생각을 했습니다. 그래서 몇 시간만에 N2H4 패키지의 골격을 가져와 모양만 갖춘게 DNH4 패키지입니다. 날짜를 보니 2016년 11월이네요. 이것저것 되게 하려고 노력하다가 의외의 장애물이 댓글 수집이었습니다. 방법을 몰라 방치한지 2년 가까이 된 패키지를 포스트에 올리는 이유는 드디어(!) 댓글 수집을 지원합니다.\n다음 뉴스 수집 패키지 DNH4\nDNH4 패키지는 N2H4처럼 github에서 호스팅하고 있습니다. 아래의 코드로 설치 & 로드하여 사용할 수 있습니다.\n\n\n# remotes::install_github(\"forkonlp/DNH4\")\nlibrary(DNH4)\n\n\n\nN2H4 패키지와 함수명이 같기 때문에 library()는 조심해 주셔야 합니다. DNH4 패키지는 6개의 함수를 우선 지원합니다.참조\ngetContent() 함수는 역시 기사 url을 입력으로 받아 관련 내용을 크롤링해 옵니다. getMainCategory() 함수는 기사의 대분류 항목을 가져옵니다. getSubCategory() 함수는 기사의 소분류 항목을 가져옵니다. 다음 뉴스는 카테고리가 대분류와 소분류만 있습니다. getUrlListByCategory() 함수는 뉴스 리스트 페이지에서 기사의 제목과 링크를 가져옵니다. getMaxPageNum() 함수는 뉴스 리스트 페이지의 마지막 페이지 번호를 가져옵니다. getComment() 함수는 기사 url을 입력으로 받아 그 기사의 댓글 정보를 가져옵니다.\n말씀드린 것처럼, 다음 뉴스의 댓글 수집은 여러 권한 단계를 거쳐 제 짧은 실력으로는 그 동안 가져오지 못했습니다. 물론 셀레늄을 사용하면 이런 고민을 하지 않습니다만, 역시 속도 문제를 무시할 수 없는 것 같습니다. 그럼 이제 getComment() 함수를 사용해 보겠습니다.\n댓글 수집 함수\n우선 댓글이 많은 뉴스를 하나 골라봅시다. 제가 작성하는 시점으로 댓글이 3,000개가 넘는 기사로 해보겠습니다.\n\n\ncomments <- DNH4::getComment(\"http://v.media.daum.net/v/20180513202105651\")\ncomments\n\n\n# A tibble: 10 x 24\n          id   postId forumId parentId type  status flags rating\n       <int>    <int>   <int>    <int> <chr> <chr>  <int>  <int>\n 1 250018474 31383325     -99        0 COMM… S        256      0\n 2 250018687 31383325     -99        0 COMM… S        256      0\n 3 250019139 31383325     -99        0 COMM… S          0      0\n 4 250023503 31383325     -99        0 COMM… S        256      0\n 5 250021353 31383325     -99        0 COMM… S        256      0\n 6 250020406 31383325     -99        0 COMM… S        256      0\n 7 250022883 31383325     -99        0 COMM… S        256      0\n 8 250019409 31383325     -99        0 COMM… S        256      0\n 9 250019687 31383325     -99        0 COMM… S          0      0\n10 250022914 31383325     -99        0 COMM… S        256      0\n# … with 16 more variables: content <chr>, createdAt <chr>,\n#   updatedAt <chr>, childCount <int>, likeCount <int>,\n#   dislikeCount <int>, user_id <int>, user_status <chr>,\n#   user_type <chr>, user_flags <int>, user_username <chr>,\n#   user_roles <chr>, user_providerId <chr>,\n#   user_providerUserId <chr>, user_displayName <chr>,\n#   user_commentCount <int>\n\ngetComment() 함수는 몇 가지 옵션이 있습니다. limit은 가져오는 댓글의 갯수로 기본 10개로 설정되어 있습니다. 전체 댓글수를 가져오는 함수가 필요하다는 것을 확인하는 시점이네요. parentId는 대댓글등을 가져올 때 사용하는 옵션으로, 기본값 0에서 바꾸실 일이 거의 없을 겁니다. sort는 역시 추천순와 최신순 두 가지 옵션을 제공합니다. type은 결과값을 주는 형태를 의미합니다. 옵션은 df와 list가 있으며 원래 제공하는 자료형이 json이기 때문에 list가 익숙하진 분들은 list 자료형을 권장합니다. 기본값은 df 입니다. 댓글의 상황에 따라 Warning messages가 나오는데 무시하셔도 좋습니다. 내용상 신경이 쓰이시면 list를 직접 다루어 보시는 것도 좋은 공부가 될 것입니다.\n네이버 뉴스 댓글 가져오기\n네이버 뉴스 수집 패키지 역시 같은 함수를 가지고 있습니다. 우선 아래 코드로 패키지를 설치하고 로드합니다.\n\n\n# remotes::install_github(\"forkonlp/N2H4\")\nlibrary(N2H4)\n\n\n\n대상이 될만한 기사를 선정하려고 하다보니, 기왕 같은 뉴스면 좋겠다 싶어 가져왔습니다.\n\n\ncomments <- N2H4::getComment(\"http://news.naver.com/main/read.nhn?mode=LSD&mid=sec&sid1=101&oid=214&aid=0000833933\")\ncomments\n\n\n# A tibble: 10 x 79\n   ticket objectId categoryId templateId  commentNo parentCommentNo\n   <chr>  <chr>    <chr>      <chr>           <int>           <int>\n 1 news   news214… *          default_e… 1343597525      1343597525\n 2 news   news214… *          view_econ… 1343595725      1343595725\n 3 news   news214… *          default_e… 1343589535      1343589535\n 4 news   news214… *          view_econ… 1343536845      1343536845\n 5 news   news214… *          view_econ… 1343407745      1343407745\n 6 news   news214… *          view_econ… 1343332545      1343332545\n 7 news   news214… *          view_econ… 1343313585      1343313585\n 8 news   news214… *          view_econ… 1343200155      1343200155\n 9 news   news214… *          view_econ… 1343185745      1343185745\n10 news   news214… *          view_econ… 1343146585      1343146585\n# … with 73 more variables: replyLevel <int>, replyCount <int>,\n#   replyAllCount <int>, replyPreviewNo <lgl>, replyList <lgl>,\n#   imageCount <int>, imageList <lgl>, imagePathList <lgl>,\n#   imageWidthList <lgl>, imageHeightList <lgl>, commentType <chr>,\n#   stickerId <lgl>, sticker <lgl>, sortValue <dbl>, contents <chr>,\n#   userIdNo <chr>, exposedUserIp <lgl>, lang <chr>, country <chr>,\n#   idType <chr>, idProvider <chr>, userName <chr>,\n#   userProfileImage <chr>, profileType <chr>, modTime <chr>,\n#   modTimeGmt <chr>, regTime <chr>, regTimeGmt <chr>,\n#   sympathyCount <int>, antipathyCount <int>, hideReplyButton <lgl>,\n#   status <int>, mine <lgl>, best <lgl>, mentions <lgl>,\n#   toUser <lgl>, userStatus <int>, categoryImage <lgl>, open <lgl>,\n#   levelCode <lgl>, grades <lgl>, sympathy <lgl>, antipathy <lgl>,\n#   metaInfo <lgl>, extension <lgl>, audioInfoList <lgl>,\n#   translation <lgl>, report <lgl>, middleBlindReport <lgl>,\n#   spamInfo <lgl>, userHomepageUrl <lgl>, defamation <lgl>,\n#   hiddenByCleanbot <lgl>, score <dbl>, managerLike <lgl>,\n#   visible <lgl>, manager <lgl>, deleted <lgl>, expose <lgl>,\n#   exposeByCountry <lgl>, virtual <lgl>, secret <lgl>,\n#   profileUserId <lgl>, idNo <chr>, blindReport <lgl>, blind <lgl>,\n#   serviceId <lgl>, containText <lgl>, userBlocked <lgl>,\n#   maskedUserId <chr>, maskedUserName <chr>, validateBanWords <lgl>,\n#   anonymous <lgl>\n\n네이버 뉴스의 댓글은 훨씬 풍부한 정보를 제공하여(구조가 복잡해서…) df를 기능상 제공하지 않습니다. 대신 댓글만 보는 부분을 안내해 드리고 있습니다.\n\n\ncomments$result$commentList[[1]]\n\n\nNULL\n\n그냥 위 모양으로라도 제공하는게 맞는가 싶어 급하게 업데이트 했습니다. N2H4 패키지의 getComment() 함수도 type을 지원하며, 기본값은 df이고 모든 데이터를 확인하기 위해서 list를 선택하시면 좋을 것 같습니다.\n\n\nN2H4::getComment(\"http://news.naver.com/main/read.nhn?mode=LSD&mid=sec&sid1=101&oid=214&aid=0000833933\",\n                 type = \"list\")\n\n\n  success code                           message lang country\n1    TRUE 1000 요청을 성공적으로 처리하였습니다.   ko      KR\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      result.commentList\n1 news, news, news, news, news, news, news, news, news, news, news214,0000833933, news214,0000833933, news214,0000833933, news214,0000833933, news214,0000833933, news214,0000833933, news214,0000833933, news214,0000833933, news214,0000833933, news214,0000833933, *, *, *, *, *, *, *, *, *, *, default_economy, view_economy, default_economy, view_economy, view_economy, view_economy, view_economy, view_economy, view_economy, view_economy, 1343597525, 1343595725, 1343589535, 1343536845, 1343407745, 1343332545, 1343313585, 1343200155, 1343185745, 1343146585, 1343597525, 1343595725, 1343589535, 1343536845, 1343407745, 1343332545, 1343313585, 1343200155, 1343185745, 1343146585, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, txt, txt, txt, txt, txt, txt, txt, txt, txt, txt, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, 1526301193506, 1526301073422, 1526300678769, 1526297019573, 1526288199784, 1526283570906, 1526282249099, 1526276078855, 1526275163246, 1526272157197, 정말 가난한 사람들이구나 마음이~~~~, 주민들 다바보냐 ㆍ대표 감사 다한통속이고 ᆢ비리밝혀야지, 헐~~~, 그냥 옛날 귀족과 뭐가 다름?\\n아 아니다. 귀족이 아니라 왕이나 다름 없다고 봐야 겠네.\\n내가 뭐 잘못 말했나?, 와........대단하다 대단해...., 갑질로 시작해서 여기까지 올줄은 몰랐지? 전문경영인 세우고 오너일가 싹 물러나라, 식탁도 글로벌하네..그럼 감방도 글로벌하게 세계3대 감옥으로가자..국내감방에서도 갑질할거니, 그냥 다없애주세요!얼마나 무고한 사람들이 힘들었을까\\n국외로 추방했으면 합니다!!, 공물 갖다 바치는거냐. 왕조네 왕조., 법개정해서 걍 평생 옥살이 시켜라 저런건 나와도 사회도움 절대 안된다, 37nsJ, 5HzPo, 37nsJ, 1YJyu, 7dGi7, 2mS6W, 3mIMN, 4aKKm, Q7ZE, 6f8ZY, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, ko, ko, ko, ko, ko, ko, ko, ko, ko, ko, IT, KR, IT, KR, KR, KR, KR, KR, KR, KR, naver, naver, naver, naver, naver, naver, naver, naver, naver, naver, naver, naver, naver, naver, naver, naver, naver, naver, naver, naver, elen****, unb1****, elen****, pcw1****, iluv****, ywj2****, 77gu****, tntj****, c32h****, betl****, , , , , , , , , , , naver, naver, naver, naver, naver, naver, naver, naver, naver, naver, 2018-05-14T21:33:13+0900, 2018-05-14T21:31:13+0900, 2018-05-14T21:24:38+0900, 2018-05-14T20:23:39+0900, 2018-05-14T17:56:39+0900, 2018-05-14T16:39:30+0900, 2018-05-14T16:17:29+0900, 2018-05-14T14:34:38+0900, 2018-05-14T14:19:23+0900, 2018-05-14T13:29:17+0900, 2018-05-14T12:33:13+0000, 2018-05-14T12:31:13+0000, 2018-05-14T12:24:38+0000, 2018-05-14T11:23:39+0000, 2018-05-14T08:56:39+0000, 2018-05-14T07:39:30+0000, 2018-05-14T07:17:29+0000, 2018-05-14T05:34:38+0000, 2018-05-14T05:19:23+0000, 2018-05-14T04:29:17+0000, 2018-05-14T21:33:13+0900, 2018-05-14T21:31:13+0900, 2018-05-14T21:24:38+0900, 2018-05-14T20:23:39+0900, 2018-05-14T17:56:39+0900, 2018-05-14T16:39:30+0900, 2018-05-14T16:17:29+0900, 2018-05-14T14:34:38+0900, 2018-05-14T14:19:23+0900, 2018-05-14T13:29:17+0900, 2018-05-14T12:33:13+0000, 2018-05-14T12:31:13+0000, 2018-05-14T12:24:38+0000, 2018-05-14T11:23:39+0000, 2018-05-14T08:56:39+0000, 2018-05-14T07:39:30+0000, 2018-05-14T07:17:29+0000, 2018-05-14T05:34:38+0000, 2018-05-14T05:19:23+0000, 2018-05-14T04:29:17+0000, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, TRUE, TRUE, TRUE, TRUE, FALSE, TRUE, TRUE, TRUE, FALSE, TRUE, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, 37nsJ, 5HzPo, 37nsJ, 1YJyu, 7dGi7, 2mS6W, 3mIMN, 4aKKm, Q7ZE, 6f8ZY, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, elen****, unb1****, elen****, pcw1****, iluv****, ywj2****, 77gu****, tntj****, c32h****, betl****, el****, un****, el****, pc****, il****, yw****, 77****, tn****, c3****, be****, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE\n  result.pageModel.page result.pageModel.pageSize\n1                     1                        10\n  result.pageModel.indexSize result.pageModel.startRow\n1                         10                         1\n  result.pageModel.endRow result.pageModel.totalRows\n1                      10                       2508\n  result.pageModel.startIndex result.pageModel.totalPages\n1                           0                         251\n  result.pageModel.firstPage result.pageModel.prevPage\n1                          1                         0\n  result.pageModel.nextPage result.pageModel.lastPage\n1                         2                        10\n  result.pageModel.current result.pageModel.threshold\n1                       NA                         NA\n  result.pageModel.moveToLastPage result.pageModel.moveToComment\n1                           FALSE                          FALSE\n  result.pageModel.moveToLastPrev result.exposureConfig.reason\n1                           FALSE                           NA\n  result.exposureConfig.status result.count.comment\n1                   COMMENT_ON                 2508\n  result.count.reply result.count.exposeCount\n1                237                     2540\n  result.count.delCommentByUser result.count.delCommentByMon\n1                          1115                           11\n  result.count.blindCommentByUser result.count.blindReplyByUser\n1                               0                             0\n  result.count.total result.listStatus result.sort\n1               2745           current         NEW\n  result.config.useSnsLogin result.config.lineFeedOn\n1                     FALSE                    FALSE\n  result.config.useBest result.config.useVote\n1                 FALSE                  TRUE\n  result.config.useVoteSelf result.config.useVoteGoodOnly\n1                     FALSE                         FALSE\n  result.config.useReport result.config.useCommonReport\n1                    TRUE                         FALSE\n  result.config.reportAuthority\n1                           ALL\n  result.config.useDeleteOnManagerReport\n1                                  FALSE\n  result.config.useReportSecret result.config.useSort\n1                         FALSE                  TRUE\n  result.config.sortTypes result.config.defaultSort\n1                     NEW                       NEW\n  result.config.useByteLength result.config.useReply\n1                       FALSE                   TRUE\n  result.config.useReplyOnReply result.config.pageAfterReply\n1                         FALSE                 TO_LAST_PAGE\n  result.config.maxReplyWriteBoxCount result.config.useAutoRefresh\n1                                   0                        FALSE\n  result.config.useMention result.config.min result.config.max\n1                    FALSE                 1               300\n  result.config.useSticker result.config.stickerOnly\n1                    FALSE                     FALSE\n  result.config.stickerSupportedCategories\n1                                       NA\n  result.config.stickerDefaultCategory result.config.stickerCategory\n1                                   NA                            NA\n  result.config.stickerContentsUrl result.config.stickerKeyUrl\n1                               NA                          NA\n  result.config.stickerTabUrl result.config.stickerType\n1                          NA                        NA\n  result.config.stickerText result.config.stickerMarketUrl\n1                     FALSE                             NA\n  result.config.stickerMobileResize result.config.useProfile\n1                             FALSE                    FALSE\n  result.config.dynamicProfile result.config.profileImageAreas\n1                        FALSE                            LIST\n  result.config.profileEmptyImage result.config.displayMaskedUserId\n1                              NA                             FALSE\n  result.config.useManager result.config.managerDelete\n1                    FALSE                       FALSE\n  result.config.managerBlock result.config.managerNotice\n1                      FALSE                       FALSE\n  result.config.contentsManagerIcon result.config.secretComment\n1                             FALSE                       FALSE\n  result.config.exposureConfig result.config.deleteAllAfterBlock\n1                        FALSE                             FALSE\n  result.config.useFold result.config.replyPreviewCount\n1                  TRUE                               0\n  result.config.maxImageUploadCount\n1                                 0\n  result.config.maxImageUploadFileSize result.config.imageAutoRotate\n1                                    0                         FALSE\n  result.config.autoRefreshTime result.config.autoRefreshDefaultOff\n1                             0                               FALSE\n  result.config.autoRefreshChat result.config.maxChatFPS\n1                         FALSE                        0\n  result.config.commentModify result.config.useCommentModify\n1                       FALSE                          FALSE\n  result.config.useViewAll result.config.useSnsComment\n1                     TRUE                       FALSE\n  result.config.snsCommentDefaultOn result.config.useUserLevel\n1                              TRUE                      FALSE\n  result.config.anyUseImageExpose result.config.useImageComment\n1                            TRUE                         FALSE\n  result.config.useUrlLink result.config.useCommentListIncludeDelete\n1                    FALSE                                     FALSE\n  result.config.useStats result.config.statsMinCount\n1                   TRUE                         100\n  result.config.useUserEnvStats result.config.countryStatsMinCount\n1                         FALSE                                  0\n  result.config.useConcurrentStats result.config.useVoteStats\n1                            FALSE                      FALSE\n  result.config.useGpopCache result.config.useEnterSubmit\n1                      FALSE                        FALSE\n  result.config.useListReverse result.config.useTranslation\n1                        FALSE                        FALSE\n  result.config.useDeletedList result.config.useAudio\n1                         TRUE                  FALSE\n  result.config.combinedDeletedList result.config.displayDeletedList\n1                              TRUE                             TRUE\n  result.config.applyChangedNotice result.config.useUserCommentUi\n1                            FALSE                           TRUE\n  result.config.useUserCommentProfileUi\n1                                  TRUE\n  result.config.userRecentStatsStartDate result.config.userSortTypes\n1                           1.584544e+12   FAVORITE, NEW, OLD, REPLY\n  result.config.useMentionLegacyFormat result.config.useMentionWrite\n1                                FALSE                         FALSE\n  result.config.mentionMaxCount result.config.useSecret\n1                             0                   FALSE\n  result.config.useIdPenaltyLayer result.config.useRestrictWriteBySns\n1                            TRUE                               FALSE\n  result.config.photoInfraUploadDomain\n1                                   NA\n  result.config.photoInfraSelectDomainHttp\n1                      g-cbox.dv.phinf.net\n  result.config.photoInfraSelectDomainHttps\n1                        g-cbox.pstatic.net\n  result.config.pcTempThumbnailType\n1                           ff80_80\n  result.config.mobileTempThumbnailType\n1                               ff50_50\n  result.config.realnameVerificationBlock\n1                                   FALSE\n  result.config.realnameVerificationMessage\n1                                        NA\n  result.config.useBlindByReport\n1                           TRUE\n  result.config.keepTextareaOnRestriction\n1                                      NA\n  result.config.displayIndividualBlindOnly\n1                                    FALSE\n  result.config.hashtagMaxLength result.config.useDualPagination\n1                             20                           FALSE\n  result.config.reportReasonList result.config.displayReportLayer\n1                             NA                            FALSE\n  result.config.useHideAfterReport result.config.useCleanbot\n1                            FALSE                      TRUE\n  result.config.cleanbotEnforced result.config.cleanbotServiceStepUI\n1                          FALSE                                   2\n  result.config.useCommentLinkToken result.config.useUserBlock\n1                              TRUE                       TRUE\n  result.config.useUserBlockNaverIdType\n1                                  TRUE\n  result.config.useUserBlockNeoIdType\n1                               FALSE\n  result.config.useUserBlockProifleImageUi result.config.useChoice\n1                                     TRUE                   FALSE\n  result.config.useNcc result.config.useScore\n1                FALSE                  FALSE\n  result.config.scoreScale result.config.scoreSelectorCount\n1                        0                                0\n  result.config.useManagerLike result.config.blindReportReasonList\n1                        FALSE                                  NA\n  result.bestList result.graph.gender.male result.graph.gender.female\n1            NULL                       63                         37\n                                                                                                                                                        result.graph.old\n1 10, 20, 30, 40, 50, 60, 1, 6, 29, 42, 18, 4, exact, exact, exact, exact, exact, over, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, TRUE, FALSE, FALSE\n  result.graph.client result.graph.country result.graph.empty\n1                  NA                   NA              FALSE\n  result.notice.noticeNo                          result.notice.title\n1                     40 5/13 부터 기사댓글에 프로필사진이 제공됩니다\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    result.notice.content\n1 안녕하세요, 네이버 뉴스입니다.\\r<br> \\r<br>네이버 뉴스 댓글에서는 지난해 3월 19일부터 댓글모음 페이지를 통해 설정하신 프로필 정보를 제공하고 있습니다.\\r<br> \\r<br>댓글모음 페이지를 통해 프로필 정보가 제공되면서 댓글 사용자를 더 쉽게 인지할 수 있지만\\r<br>기사 댓글에는 프로필 대신 마스킹 처리된 아이디 앞 4자리만 남겨져 있어 댓글 목록에서 사용자 인지가 여전히 어렵다는 의견이 있어 왔습니다.  \\r<br>  \\r<br>댓글모음 페이지로 매번 이동하지 않고도 댓글 사용자를 쉽게 알 수 있도록, 사용자간 소통이 더 활성화 될 수 있도록 \\r<br>5월 13일부터 기사 댓글목록에서도 내가 설정한 프로필 사진을 함께 서비스합니다.  \\r<br> \\r<br>[ ※ 5월 13일 15시 이후 작성한 댓글과 답글 부터 적용 ] \\r<br> \\r<br>앞으로도 댓글 공간을 더욱 건강하게 활성화시킬 수 있도록 댓글 서비스를 지속적으로 개선해 가겠습니다.  \\r<br> \\r<br>감사합니다.\n     result.notice.regTime                     date\n1 2021-04-30T15:15:09+0900 2021-05-05T05:36:51+0000\n\n드디어 다음 댓글을 가져올 수 있게 된 만큼, 많은 분들이 DNH4 패키지도 찾아주시리라 기대합니다. DNH4 패키지는 ForkonLP 프로젝트의 일부입니다.\n언제나 그렇듯, 잘못된 내용이 있거나 문제가 생기면 언제든지 알려주세요. 감사합니다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106492737-9daf1c80-64fb-11eb-8739-beb6c28e89e0.png",
    "last_modified": "2021-05-05T05:36:53+00:00",
    "input_file": {}
  },
  {
    "path": "post/rtips-windows에서-rjava-스트레스-없이-설치하기/",
    "title": "[Rtips] Windows에서 rJava 스트레스 없이 설치하기",
    "description": "`installr::install.java()`",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2018-05-08",
    "categories": [
      "R",
      "rJava",
      "KoNLP",
      "java",
      "installr",
      "windows"
    ],
    "contents": "\n\nContents\n업데이트 2019-08-10\ninstallr\ninstall.java()\n따라하기\n\n\n업데이트 2019-08-10\nWindows와 MacOS 에서 동작하는 방법을 설명하는 포스트를 작성하였습니다.\nhttps://mrchypark.github.io/post/correttor-r을-위해서-java를-설치해보자/\n한줄요약\ninstallr::install.java()\nrJava 패키지는 java의 풍부한 생태계를 R에서 사용하기 위해 꼭 필요한 인터페이싱 패키지입니다. 비슷한 부류로 python의 reticulate, C++의 Rcpp 등이 있죠. 모두 각각의 언어를 설치하고 경로 설정을 해줘야 하는 단계를 가지고 있습니다. 막상 진행해보면 쉬운 일이 아닙니다. 그래서 해결책을 좀 찾아봤는데요. windows 환경에서 R에 관련된 설치와 R과 함께 많이 사용하는 외부 프로그램 설치를 함수로 제공하는 installr 패키지를 소개하겠습니다.\ninstallr\ninstallr 패키지는 R의 업데이트 함수인 updateR()을 제공합니다. R과 함께 사용하는 외부 프로그램 중 설치가 까다로운 ImageMagick이나 MikTeX 같은 것도 제공합니다. 지금은 rstudio에서 함께 제공하여 문제가 없지만, 저도 pandoc과 Tex 계열을 설치할 때 도움을 받았습니다. 아무튼 installr 패키지에서 제공하는 install.java()를 살펴보겠습니다.\ninstall.java()\nDownloads and set path openjdk\n\nDescription:\n\n     Downloads and set path the latest version of openjdk for Windows.\n\nUsage:\n\n    install.java(version = 10,\n                 page_with_download_url = \"http://jdk.java.net/java-se-ri/\",\n                 path = \"C:/java\")\n     \nArguments:\n\n    version: 9 or 10 is passible. Default is 10.\n\n    page_with_download_url: where to download. Default is <URL:http://jdk.java.net/java-se-ri/>\n\n    path: where to set java. Defulat path is C:/java\n\nDetails:\n\n    install openjdk 9 or 10 version for windows 10 64x.\n\nValue:\n\n    TRUE/FALSE - was the installation successful or not.\n\nAuthor(s):\n\n    Tal Galili and A. Jonathan R. Godfrey\n\nExamples:\n\n    ## Not run:\n    \n    install.java() \n    install.java(version = 10)\n    install.java(10)\n    ## End(Not run)\ninstall.java()는 3개의 인자를 제공합니다. version,page_with_download_url,path이네요. 현재는 windows 10 64x에서 jdk9와 jdk10만 지원한답니다.\nversion은 jdk 버전을 의미하는 것이군요. page_with_download_url은 바꿀 수 있어 보이지 않네요. openjdk 프로젝트의 최근 결과물인 것 같습니다. path는 컴퓨터의 설치 경로를 뜻합니다. 기본값이 이해하기 쉬운 곳에 있으니 저는 그냥 두겠습니다.\n따라하기\n조건을 잘 따져보겠습니다.\n1. windows 10 64비트를 사용하고 있다.\n2. 기존에 설치된 java가 없다.\n그럼 이제 R 콘솔을 실행해서 에러없이 동작하는지 확인하면 됩니다.\ninstall.packages(\"rJava\")\nsource(\"https://install-github.me/talgalili/installr\")\ninstallr::install.java()\nlibrary(rJava)\n실제로 잘 동작하는 것인지 결과물로 확인하고 싶으시다면 KoNLP를 사용해보시면 좋을 것 같습니다.\ninstall.packages('KoNLP')\nsource(\"https://install-github.me/talgalili/installr\")\ninstallr::install.java()\nlibrary(KoNLP)\n\n## Checking user defined dictionary!\n문제 없이 실행되셨나요?\n언제나 그렇듯, 잘못된 내용이 있거나 문제가 생기면 언제든지 알려주세요. 감사합니다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106492503-53c63680-64fb-11eb-9522-f09beac39a25.png",
    "last_modified": "2021-05-05T05:35:09+00:00",
    "input_file": {}
  },
  {
    "path": "post/kospacing-한글-띄어쓰기-패키지를-사용해보자/",
    "title": "[KoSpacing] 한글 띄어쓰기 패키지를 사용해보자",
    "description": "KoSpacing은 한글 띄어쓰기를 해주는 딥러닝 모델 패키지이다. python이 함께 필요한 패키지 기반으로 만들어서 python도 설치해야 한다. windows는 conda만 지원하므로 conda를 설치하여 사용해보자.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2018-05-02",
    "categories": [
      "R",
      "KoSpacing",
      "installr",
      "keras",
      "conda",
      "reticulate"
    ],
    "contents": "\n\nContents\n업데이트\n\n\n업데이트\n패키지의 설치 문제가 보고되어 확인하였습니다. 새롭게 설치를 진행하시고, 0.1.1 버전인 것을 확인하시면 문제없이 동작할 것입니다. 0.1.1 버전에서는 conda 명령이 실행가능한 상태여야 합니다.\nconda를 설치하는 conda4r 패키지를 소개하는 포스트를 작성하였습니다.\n세줄요약\nKoSpacing은 한글 띄어쓰기를 해주는 딥러닝 모델 패키지이다.\npython이 함께 필요한 패키지 기반으로 만들어서 python도 설치해야 한다.\nwindows는 conda만 지원하므로 conda를 설치하여 사용해보자.\n한글 띄어쓰기 API 이용하는 포스트에서 소개했던 API가 R & Python 패키지로 탄생하였습니다. (R 패키지 바로가기, Python 패키지 바로가기) 이같은 멋진 패키지를 개발해주신 전희원님님 감사합니다.\nKoSpacing 패키지는 전례가 없는 딥러닝 모델로 결과를 만드는 패키지로 본인의 포스트에서 Model as a Program 이라고 소개한바 있습니다. R에는 tensorflow와 keras가 reticulate 패키지를 이용해서 python 패키지를 기반으로 최신 딥러닝 프레임워크를 사용할 수 있습니다. KoSpacing은 keras로 작성된 모델을 사용하기 때문에, 패키지 사용을 위해서 reticulate 설치가 필요합니다. KoNLP 역시 java 기반의 라이브러리를 R에서 사용하기 위해 rJava 설치가 필요했습니다. java의 경로 설정에 비해 간편하긴 하지만 python을 또 설치해야 한다는 압박이 있을 수 있다고 생각이 들었습니다. 간편하게 R에서 사용하는 도구들의 설치를 도와주는 installr를 이용해서 miniconda를 설치해 보겠습니다.\ninstallr\ninstallr 패키지는 windows 환경에서 R에서 사용하는 여러 외부 프로그램들(pandoc, latex, 등등)을 콘솔 명령으로 설치해주고, R의 버전 업데이트 등을 할 수 있는 함수를 제공합니다. 완전히 Rphabetic(알파베틱)하죠. unix 계열(mac 포함)은 완전히 같은 기능을 제공하는 패키지가 없다는 점이 조금 아쉽습니다.\nRtools를 설치하지 않으셨다면 아래 두 줄을 콘솔에서 실행해주세요.\ninstall.packages('installr')\ninstall.Rtools()\n이제 devtools를 설치하고 최신 버전의 installr를 설치하도록 하겠습니다.\nif (!require('devtools')) install.packages('devtools')\ndevtools::install_github('talgalili/installr')\n최신 버전의 installr 패키지는 install.conda() 함수를 제공합니다. 이를 이용해서 KoSpacing 환경을 설치해보겠습니다.\nlibrary(installr)\ninstall.conda()\ninstall.conda() 함수는 windows 환경에 miniconda의 설치 파일을 다운 받아 실행해 줍니다. 다운로드 페이지에서 자신에게 맞는 설치 파일을 다운로드 받아 실행하셔도 같은 동작을 하는 것입니다. 기본 옵션들을 유지한 채로 계속 다음을 눌러 설치를 완료해 주세요.\n이제 KoSpacing을 설치해 보겠습니다.\nif (!require('remotes')) install.packages('remotes')\nremotes::install_github('haven-jeon/KoSpacing')\nlibrary(KoSpacing)\n잘 되셨나요? 저와는 조금 다른 메세지들이 보이실 수도 있습니다만, 마지막 library(KoSpacing)이 잘 수행되면 성공인 겁니다! loaded KoSpacing model! 메세지를 확인하셨나요?\n이제 패키지를 사용해볼까요?\nspacing(\"김형호영화시장분석가는'1987'의네이버영화정보네티즌10점평에서언급된단어들을지난해12월27일부터올해1월10일까지통계프로그램R과KoNLP패키지로텍스트마이닝하여분석했다.\")\nR에서 keras를 사용하기 위해서 python이 설치되어 있어야 합니다. windows는 conda만 사용할 수 있습니다. macOS와 linux 계열은 pip, virtualenvs도 사용할 수 있습니다. installr 패키지는 windows 설치용 패키지라는 것을 잊지 마세요.\n잘못된 내용이 있거나 문제가 생기면 언제든지 알려주세요. 감사합니다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106488771-6474ad80-64f7-11eb-8ef2-6c3d41e24898.png",
    "last_modified": "2021-05-05T05:34:26+00:00",
    "input_file": {}
  },
  {
    "path": "post/r로나만의-웹페이지-만들기-2탄-github-pages/",
    "title": "[R로나만의] 웹페이지 만들기 2탄 Github pages",
    "description": "github pages로 나만의 웹페이지를 만들 수 있다. `.Rmd` 파일로 웹개발 지식없이 웹페이지를 만들자. 파일 이름이 곧 주소이고, index는 관례적으로 생략이 가능하다.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2018-03-24",
    "categories": [
      "R",
      "github",
      "web",
      "R로나만의",
      "Rmd",
      "github pages"
    ],
    "contents": "\n\n세줄요약\ngithub pages로 나만의 웹페이지를 만들 수 있다.\n.Rmd 파일로 웹개발 지식없이 웹페이지를 만들자.\n파일 이름이 곧 주소이고, index는 관례적으로 생략이 가능하다.\n드디어 blogdown을 사용하기 위한 필수 내용을 설명하는 포스트를 작성하네요. 제 느린 속도를 생각하면 감개가 무량합니다. ㅎㅎㅎ 그럼 시작해 볼까요?\n\nGithub pages는 <계정이름>.github.io라는 주소를 제공하는 정적 웹 호스팅 서비스입니다. Jekyll을 기본 엔진으로 하여 마크다운 문서로 블로그나 홈페이지를 운영할 수도 있죠. 아무튼 오늘은 .html 파일과 .md 파일로 <계정이름>.github.io의 하위주소로 웹에 공개하는 방법을 소개하겠습니다.\n설명드릴 내용은 아래 세 가지입니다.\n<계정이름>.github.io의 주소와 <계정이름>.github.io/<저장소이름> 주소로 웹페이지를 게시하는 것\n.md 파일과 .html 파일\n파일을 저장해야 하는 위치(root, docs, gh-pages branch)\n우선, 가장 간단한 조합인 폴더의 root 위치에 .md 파일로 <계정이름>.github.io/<저장소이름>에 게시를 해보겠습니다. 지난 포스트에서 만들었던 myfirestrepo를 사용해 보겠습니다.\n\n지난 포스트를 따라 오셨다면 저처럼 https://github.com/<계정이름>/myfirestrepo가 있을겁니다. 이걸로 페이지를 만들 준비가 끝났습니다. 페이지 설정을 같이 따라가 볼까요?\n\nCode, Issues, Pull requests 가 있는 탭의 오른쪽 마지막에 Settings가 있습니다. 자신의 저장소에서만 보이는 옵션이니 회원가입하고 저장소를 만드셔야 따라오실 수 있습니다.\n\n스크롤을 조금 내리면 드디어 GitHub Pages가 나옵니다. Source와 Theme Chooser가 있는데, Theme Chooser는 나중에 설명하고, Source를 같이 보시죠. 현재 None으로 되어있는데요, 클릭을 한 번 해볼까요?\n\nNone 말고 다른 옵션이 2개 더 있네요. 하나는 master branch, 다른 하나는 master branch /docs folder 입니다. 각 옵션은 설정이 가능할 때, 즉 호스팅할 파일이 있을 때 선택할 수 있습니다. 지금 /docs 폴더가 저장소내에 없기 때문에 2번째 옵션은 선택할 수 없어요. 우선 기본 위치를 사용하는 master branch를 설정해 보겠습니다. 첫 번째 옵션을 선택하고 오른쪽에 Save 버튼을 클릭해주세요.\n\n설정이 저장되었다는군요.\n\n다시 GitHub Pages로 가보면 많은 것이 변해있습니다. 우선 https://mrchypark.github.io/myfirestrepo/ 주소로 사이트가 게시 준비가 되었다네요!\n\n조금 기다려보면 이렇게 사이트가 게시되었다고 변한 녹색 알림을 볼 수 있습니다. 새로고침을 해서 확인해보세요! 그럼 주소를 따라 이동해볼까요?\n파란색 주소를 클릭하시면 됩니다.\n\n와! 드디어 github pages로 웹페이지를 게시했습니다! 이 간단한 페이지가 뭘로 만들어진거냐 하면…\n\n처음 프로젝트 만들 때 체크로 만들었던 README.md 파일로 만들어진 겁니다. 그렇다면 마크다운 문법으로 README.md 파일을 바꾸면 웹 페이지 내용을 바꿀 수 있겠군요. 그래도 우리는 R로 만들꺼니까, .Rmd로 .md를 만들어 봅시다.\n새로 시작해봅시다.\n이전 포스트와 같이 할건데 라이선스는 지정하지 말고, 저장소 이름은 마음대로 해보겠습니다. 어떤 보고서를 업로드할 꺼라면, 주소가 그 내용을 반영하고 있으면 좋을 것 같네요. 저는 rmdhosting이라고 해보겠습니다.\n\nRstudio로 프로젝트를 시작하면서 위 저장소로 시작해볼까요?\n\n위 화면의 오른쪽 아래처럼 파일이 3개가 있다면 잘 따라오신겁니다. 혹시 잘 안되시면 댓글로 질문주시거나 이전 포스트를 다시 확인해주세요. 그럼 이제 Rpubs 소개 포스트에서 한 것처럼 .Rmd 파일을 만들겠습니다. 대신 선택을 다른걸 할껀데요.\n\n위처럼 R markdown...을 만드는 팝업창을 켜고, From Template 탭을 확인하겠습니다.\n\n반가운 이름이 보이는군요! GitHub Document (Markdown)을 선택하고 OK를 눌러 만들어보겠습니다.\n\n.Rmd 파일이 만들어졌습니다. 저장을 해주세요. 물론 필요한 내용으로 수정해야겠죠?\n\n저는 우선 index 라고 저장하겠습니다. 모두 같은 이름으로 따라해주세요. 처음에 .Rmd로 설정해서 새로 만들었기 때문에 확장자를 지정하지 않아도 됩니다.\n\n그럼 이제 Knit 버튼을 눌러볼까요!?!\n\nRpubs 소개 포스트에서는 여기서 Publish 버튼을 누르는 것으로 진행했었습니다. 선택도 기본 html이었던것 같군요.\n이번에는 창을 닫고 다시 파일들을 확인해보겠습니다.\n\nindex.Rmd 파일은 제가 만든건데, Knit 버튼을 누름으로써 index.md로 변환이 되었군요. index_files 폴더도 새로 생겼습니다. index_files 폴더는 보통 .md 파일로 변환하는 과정에서 생기는 그림 파일들을 저장하는 곳입니다. 자동으로 일이 진행되니 자세히 알고 있을 필요는 없습니다.\ngithub에 업로드\n이제 git을 이용해서 github에 push 해볼껀데요. 저희 입장에서는 업로드와 같지만, git의 방법을 따라할겁니다.\n우선 오른쪽 위 창에서 git 탭을 클릭해보세요. 없다면 github 저장소를 이용해서 프로젝트를 만든 것이 아닙니다. 이전 포스트를 확인해주세요.\n\n저 같이 여러 리스트가 나올 건데요. 내용은 git에 대한 것이므로 (언제가 될지 모르는) 나중에 다루도록 하구요. Commit 버튼을 눌러보겠습니다.\n\n또 새로운 창이 뜹니다. 여기는 Commit을 하는 곳입니다. 파일들이 변경된 상태를 저장하는 것이라고 이해하면 좋을 것 같아요. 전부 저장해 볼까요?\n\n파일을 전부 선택합니다.\n\n그리고 파일 위에 Stage 버튼을 눌러 Staged 박스를 전부 체크합니다.\n\n방금 과정 말고 Staged 박스를 하나씩 클릭해도 됩니다.\n\n\n오른쪽에 Commit message 칸에 지금 저장하는 상태에 대해 간단한 설명글을 씁니다. 이건 git의 기능으로 필수이기 때문에 뭐라도 적어주세요.\n그리고 Commit 버튼을 눌러볼까요?\n\nCommit을 어떻게 했다는 이러저러한 설명이 나오네요. 잘 된거 같으니 확인 버튼을 누르겠습니다.\n다음 버튼은 오른쪽 가장 위에 있는 push 버튼입니다. push는 Commit된 내용들을 원격 저장소에 보낸다는 뜻입니다. 업로드랑 비슷하죠? 그럼 클릭해볼까요.\n\n뭐라고 뭐라고 하다가…\n\n이렇게 master -> master라는 메세지가 뜨면 잘 push(업로드)가 된 것입니다. github 웹 페이지로 가서 잘 진행이 됬는지 확인해보죠.\n\n잘 된거 같습니다! 처음에는 만들지 않았던 파일들이 보이구요. 다행히도 Rstudio에서 만들어서 push 한 것들이네요!\n그럼 위에서 한 것처럼, setting으로 가서 github pages를 설정해볼까요? 지금 파일들이 master branch에 있으니 선택해서 저장해보겠습니다.\n\n사이트가 호스팅할 준비가 되었다고 하네요.\n\n이제 다 되었습니다!\n한번 주소를 클릭해서 잘 호스팅되고 있는지 확인해볼까요?\n\n이렇게 허탈한 화면을 볼 수도 있습니다. 새로고침을 좀 해보셔도 안되면 README.md 파일을 한번 지워보세요. 지우는 방법은 2가지가 있는데, 하나는 Rstudio에서 지운후 Commit하고 Push하는 것이구요. 다른 하나는 Github 웹 페이지에서 바로 지우는 겁니다. 간단한 동작들은 Github 웹 페이지에서 기능을 제공합니다.\n\n이 창에서 README.md 파일을 클릭해주세요.\n\n이 화면이면 맞습니다. 오른쪽 끝에 보니 모니터, 펜, 쓰레기통 버튼이 보이는군요. 더 말하지 않아도 느낌이 오시죠?!\n\n역시 쓰레기통 버튼이었습니다. 클릭해볼께요!\n\n역시 git의 관리를 받는 파일들이라 파일을 지우는 것도 어떤 상태인 모양입니다. 파일이 지워진 상태를 Commit하는 창이 나오는군요.\n\n스크롤을 내려서 초록색 버튼인 Commit changes를 클릭합니다. Commit message는 기본값이 있어서 알아서 저장이 되는데요. 바꾸고 싶으시면 다르게 작성하셔도 됩니다. 지금은 기본값으로 Delete READM.md가 들어가 있네요. 저는 마음에 드니까 그냥 두겠습니다.\n\n파일이 성공적으로 지워졌다고 합니다.\n\nREADME.md 파일은 Github에서 관심가지는 것이라고 설명드렸었나요? 파일이 없으니까 만드는게 어떻겠냐고 제안하네요. 어쨌든 무시하고 우리의 웹 페이지 주소로 다시 가보겠습니다.\n\nhttps://mrchypark.github.io/rmdhosting/\n\n각자의 웹 페이지 주소의 구조는 https://<계정명>.github.io/<저장소명>/ 입니다. 제것과 비교해서 어떻게 다른지 한번 확인해보세요.\n이제 들어가면 우리가 보고 싶은 화면이 나옵니다.\n\n수고하셨습니다!\n앞으로도 설명드릴 내용이 많지만 이번 포스트는 여기서 마무리해야겠네요.ㅎㅎ\nP.S 혹시 만약에라도 파일을 만드실 때 index.Rmd로 하지 않으셔서 index.md 파일이 없으시다면 아직도 이 화면을 보지 못하고 계실겁니다. 이 때는 https://<계정명>.github.io/<저장소명>/<파일명> 주소를 확인해주세요.\n\n제가 만든건 https://<계정명>.github.io/<저장소명>/<파일명> 으로도 동작하는군요?!? try.md같은 파일이라면 <파일명> 부분을 try라고 해주시면 됩니다. 제 경우라면 https://mrchypark.github.io/rmdhosting/try가 되겠죠. 감사합니다.\nP.S2 질문, 오타 지적, 내용 지적, 외모 지적(응?), 와드용 공유 등 모두 모두 환영합니다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106488428-0f389c00-64f7-11eb-8f44-692566f62dfd.png",
    "last_modified": "2021-05-05T05:35:58+00:00",
    "input_file": {}
  },
  {
    "path": "post/rqna-git을-설치했는데-rstudio에서-프로젝트-만들기-진행이-안되요/",
    "title": "[RQnA] git을 설치했는데 Rstudio에서 프로젝트 만들기 진행이 안되요",
    "description": "blogdown으로 옮겨서 시작합니다.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2018-03-19",
    "categories": [
      "R",
      "RQnA",
      "git",
      "github",
      "project",
      "rstudio",
      "setting"
    ],
    "contents": "\n\nContents\n본 포스트는 windows 사용자 중 git 설치에 어려움이 있는 분들을 대상으로 합니다.\n\n\n본 포스트는 windows 사용자 중 git 설치에 어려움이 있는 분들을 대상으로 합니다.\n한줄요약\nGit을 설치했는데도 안되면 Rstudio의 Tools > Global Options… > Git/SVN의 경로를 확인해라.\n지난 포스트를 작성할 때 간단하게 넘어간 부분에 질문이 있어서 A/S 느낌으로 급하게 포스트를 작성합니다. Rstudio에 github을 연결해 사용하기 위해서는 git을 설치해야 합니다. 지난 포스트에서는 다른 블로그의 포스트를 소개해드렸습니다. 상세히 설명된 포스트라 소개했는데, 아무래도 Rstudio에 대한 설정 내용이 없어서 추가합니다.\ngit이 없습니다 팝업\n우선 프로젝트를 만드는 순서를 다시 따라가 볼까요?\n\n새 프로젝트를 만들기 위해 시작하면,\n\nVersion Control을 선택해서 진행했습니다.\n\n이제 이 화면입니다. Git과 Subversion을 선택하는 부분에서 Git을 설치하지 않고 Git을 선택하면 아래와 같은 화면이 나옵니다.\n\n캡쳐 협찬해주신 이부일님 감사합니다.\n보통은 위의 포스트를 따라 설치하시고, 다시 위 프로젝트를 만드는 과정을 진행하면 다음 화면으로 잘 넘어갑니다.\n\n이게 다음화면 인데요. 잘 안되셔서 재시작도 해봤는데, 여전히 진행이 안되는 문제가 있었습니다. 그러면 Rstudio의 설정을 확인하여 해결할 수 있습니다.\n\nTools > Global Options… 를 찾아 클릭합니다.\n\n옵션화면입니다. 아래에서 세번째에 Git/SVN 탭을 클릭합니다.\n\nGit executable: 이라고 되어있는 부분을 한 번 볼까요? 제 컴퓨터에 설치된 Git은 C:/Program Files/Git/bin/git.exe에 위치하고 있고, 그걸 사용한다고 Rstudio에 설정되어 있네요. 설치를 했는데도 진행이 안되시는 분들은 이 곳의 경로를 확인해보시면 좋을 것 같습니다.\n\n아마도 이렇게 되어 있을 것 같습니다.\n\n다른 설정 변경 없이 Git을 설치하셨다면 저와 같은 경로를 설정해주시면 됩니다. 혹시 모르니 탐색기에서 경로에 파일이 있는지 확인해주세요!\n경로를 수정해도 진행이 안되시는 분들은 댓글로 알려주세요. 감사합니다!\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106488004-9a656200-64f6-11eb-96b0-ad045e371d5a.png",
    "last_modified": "2021-05-05T05:34:49+00:00",
    "input_file": {}
  },
  {
    "path": "post/github-rstudio로-github-프로젝트-시작하기/",
    "title": "[github] rstudio로 github 프로젝트 시작하기",
    "description": "github은 git의 공개 remote repo를 제공하는 서비스다. 그래서 git 사용법을 알아야 한다. Rstudio의 project를 사용하면 좀 쉽다.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2018-03-15",
    "categories": [
      "R",
      "rstudio",
      "github",
      "project"
    ],
    "contents": "\n\n세줄요약\ngithub은 git의 공개 remote repo를 제공하는 서비스다.\n그래서 git 사용법을 알아야 한다.\nRstudio의 project를 사용하면 좀 쉽다.\nGithub은 이제 코드 관리와 공유 플랫폼의 대명사입니다. R도 개발 언어로써 Github을 많이 사용할 기회가 있는데요. 코드 공유, 패키지 공유, 분석 결과 공유 정도로 쓰임새를 정리할 수 있을 것 같습니다. 이 때 많은 분들의 필요은 아마 분석 결과 공유이지 않을까 싶습니다.\n분석 결과를 공유하기 위해서 github을 사용하실 때, R의 IDE로 많이 사용하는 RStudio와 함께 사용하는 법을 소개해드릴까 합니다.\n우선 github에 repository를 만들어 시작하는 다양한 방법이 있습니다. 단적으로는 웹브라우저에서 파일 만들기나 업로드로 진행하셔도 됩니다. 각각의 방법을 설명하기 전에, github의 개념을 간단하게만 짚고 넘어가겠습니다.\n코드의 저장 상태 백업과 공유를 위해서 git은 작업하는 나의 컴퓨터 공간인 로컬 저장소(local repository)와 원격 저장소(remote repository)라는 개념으로 구분하여 사용합니다. local을 개인이 일하고 작업하는 공간, remote는 백업하고 공유하는 공간입니다.\n\n그런데 remote를 누가 그냥 주는 것도 아니고, 필요한 사람이 따로 구축해야 합니다. 큰일인거죠. 이걸 SNS처럼 인터넷 서비스로 만든 것이 바로 Github입니다. Github은 원격 저장소를 회원 가입한 사람 모두에게 무료로 나눠준거죠. 조건이 있다면 저장소를 공개(public)해야 합니다. 비공개(private)로 만들려면 돈을 내야 합니다. 이런 Github의 유료정책을 파고 들어서 [Gitlab][Gitlab]이나 Bitbucket은 무료 비공개 repo를 제공하고 있습니다. 사용법이 좀 다르지만 git과 subvesion을 모두 사용할 수 있으니 선택지가 넓은 셈이죠. 우리는 분석 결과 공유를 목적으로 저장소(repository)를 사용할 계획이니 Github을 사용하겠습니다. 시작해볼까요?\n로컬과 원격, 프로젝트의 시작\n무언가 작업이 발생하면 아주 작거나 간단한 것이 아니라면 프로젝트라고 정의합니다. 원래 분석 프로젝트라고 하면 문제정의 - 데이터 확보 - 분석 - 결과 공유의 과정을 거칩니다. 각각의 세부항목도 많지만 우선은 넘어갈께요. 저 모든 과정을 프로젝트라고 볼 수도 있지만, 우리는 결과 공유만 프로젝트라고 합시다. 더 쉽게 하기 위해서 결과물이 .Rmd 파일로 되어 있다고 해보겠습니다. 그렇게 하면 해야할 일은\ngithub에 새 저장소 만들기\n새 저장소에 결과물 업로드하기\n이제 여기서 몇 가지 분기가 발생하는데요.\ngit을 사용할 것인가 말것인가\n결과물을 어떤 파일 형식으로 저장할 것인가\n입니다.\ngit을 사용하지 않는다면 그냥 github에서 제공하는 upload files 버튼으로 업로드 하는 방법이 있습니다. 예를 들어 .pdf는 엄청 큰 파일이 아닌 이상 업로드하면 바로 웹에서 보여주기도 합니다.\n\n이 주소로 확인하실 수 있습니다. 예쁘지는 않을 수…\n우리는 R을 사용하니 파일 형식은 다양할 수 있습니다. .Rmd만 사용하면 이론적으로는 rpubs 포스트에서 보여드린 만큼이나 가능하죠. 대표적으로 많이 사용하는 형식으로는 .docx같이 MS 오피스 계열의 결과물이 있습니다. 그리고 Github 친화적으로는 .md와 .html을 꼽을 수 있을 것 같습니다.\n.md는 GFM이란게 있을 정도로 Github이 사랑하는 파일 형식입니다. 오픈소스 저장소로써 많이 사용하는 관례인 README.md는 파일을 보지 않아도 프로젝트 페이지에서 출력도 해줍니다.\n.html은 Github pages 서비스를 통해서 사용할 수 있습니다. 아마 다음 포스트를 Github pages를 이용해서 웹페이지를 만들거나 하는 방법을 소개할 수 있을 거라 기대하고 있습니다.\n위 두 파일 형식은 Github 친화적이기도 하면서 변환 동작에 다른 외부 의존성이 없어서 작업환경을 만들기 쉽다는 장점이 있습니다. 예를 들어 .pdf는 Latex 엔진을 추가로 설치해야 합니다. 한글을 지원하는 엔진을 선정해야 해서 KTUG에서 관련 정보를 찾으실 수 있습니다.\n서문이 너무 길었네요. Rstudio를 사용해서 Github 프로젝트를 시작해보겠습니다.\ngit의 워크플로우\n\nGithub!\n위에서 Github이 git의 원격 저장소라는 설명을 드렸습니다. git을 사용해 시작하는 상황은 두 가지입니다.\n처음 폴더를 만들어 로컬 저장소를 초기화하며 시작하기\n기존에 있는 프로젝트를 원격 저장소에서 클론하여 시작하기\n초기화하면서 시작하면 원격 저장소를 연결하는 과정이 추가로 필요합니다. 원격 저장소를 연결하여 파일들을 업로드하는 행위를 푸쉬(push)라고 하는데, 천천히 할 것이라면 초기화로 시작하는 것도 좋은 선택입니다. 원격 저장소를 바로 사용할 것이라면, 원격 저장소를 먼저 만들어 클론하면서 시작하는게 조금 더 제가 생각하는 쉬운 방법입니다. 저는 원격 저장소를 바로 사용할 것이니 클론으로 시작하는 방법을 소개하겠습니다.\n클론(git clone)으로 시작하기\n클론으로 시작하려면 원격 저장소를 먼저 만들어야 한다고 말씀드렸습니다.\n\n로그인을 하고\n\n메인화면에\n\n오른쪽 위 + 버튼을 누르면 메뉴가 나옵니다.\n\n우린 새 저장소 만들어야 하니 New repository를 선택해주세요.\n\n저장소 이름을 myfirstrepo 라고 했습니다. 옵션을 좀 살펴볼까요?\nOwner\n계정입니다. 보통 자기 것만 있는데, 그룹 계정같은 것이 더 있을 수 있습니다.\nRepository name\n저장소 이름입니다. 자신의 계정 내에만 겹치치 않으면 되니 편하게 만들어 주세요.\nDescription\n저장소를 간단히 설명하는 곳입니다. 한 줄 정도로 설명문을 작성하면 검색같은 곳에 같이 보여집니다.\n공개 범위\n공개 범위는 Public과 Private이 있습니다. 우리는 Public은 선택하죠. Private은 비용을 사용해야 합니다.\nREADME\n오픈소스 프로젝트는 관례적으로 root 위치에 README 파일을 두고 있습니다. 여기서 선택하면 저장소 이름을 작성한 README.md 파일을 같이 만들어줍니다. 우리는 선택해서 시작하겠습니다.\n.gitignore\ngit 시스템이 관리하지 않을 파일들의 리스트를 담고 있는 텍스트 파일입니다. 파일명 앞에 .로만 되어 있는 건 숨김 파일이라는 뜻입니다.\n\ngithub에서는 각 언어에서 관례적으로 필요한 .gitignore 리스트를 템플릿으로 제공합니다. 우리도 R로 선택해 볼까요?\nlicense\n저장소의 코드들에 대한 라이선스를 지정할 수 있습니다. 정확히는 .gitignore 파일처럼 주요 라이선스들의 템플릿을 제공합니다.\n\n\n우리는 사용에 제약이 없고 대신 출처만 좀 써달라는 MIT 라이선스로 하겠습니다.\n원격 저장소 만들기\n\n이제 초록 버튼을 눌러 원격 저장소를 만들어 보겠습니다.\n\n우리가 설정했던 .gitignore, LICENSE, README.md 파일 3개가 기본으로 만들어지면서 원격 저장소가 생겼습니다. 이제 이 이 원격 저장소를 이용해 로컬 저장소를 만들겠습니다.\nRstudio 프로젝트 만들기\n\n이제 Rstudio를 켜볼까요?\n\n오른쪽 위에 Project 버튼을 누르면 맨 위에 New Project 버튼이 있습니다. File > New Project 로 진행하실 수도 있어요.\n\n새 프로젝트를 만들면 3가지 버튼이 나옵니다. 하나하나 살펴보죠.\nNew Directory : 새 폴더를 만들면서 프로젝트를 시작합니다. 새 폴더를 만들면서 시작하기 때문에 같은 이름의 폴더가 있으면 에러가 납니다.\nExsting Directory : 기존에 있는 폴더를 프로젝트로 만듭니다. 저는 사용할 일이 많이 없었습니다.\nVersion Control : 버전 관리 시스템으로 프로젝트를 시작합니다.\n\nVersion Control을 선택하겠습니다.\n\ngit과 subversion이 있는데 저희는 git을 사용할껍니다.\n\n아마 git이 설치가 안되어 있는 windows이신 분들은 다음으로 진행이 안됩니다. 링크를 참고해서 git을 설치해주세요.\n\n여기서 다운로드할 수 있습니다.\n\nGit을 설치했는데도 진행이 안되시면 이 포스트를 참고하세요.(업데이트 - 2018.03.19)\n\n\n다시 github으로 돌아와서, 만든 원격 저장소의 URL을 복사합니다. 저는 주소창을 애용하는 편인데, 오른쪽에 초록색 버튼을 눌러도 됩니다.\n\n그러면 주소 오른쪽 버튼이 URL 주소를 복사하는 버튼입니다. 그 버튼을 클릭하고 Rstudio로 돌아오겠습니다.\n\n요 장면으로 다시 오시면 되구요.\n\n이렇게 주소를 Reposigory URL에 붙여넣으시면, 알아서 폴더 이름도 설정됩니다. 보통 저장소 이름과 같게 설정합니다. 생성되는 폴더의 위치를 지정해 줄 수 있는데요. ~/가 문서 폴더를 뜻하구요. 저 같은 경우는 문서 폴더 밑에 project 폴더를 만들어서 그 안에 프로젝트들을 만들어 관리하고 있습니다. 이제 Create project를 눌러보겠습니다.\n\n자 git 명령어를 우리는 모르지만, 저 과정이 git clone https://github.com/mrchypark/myfirestrepo.git을 수행한 것과 같습니다. 명령을 수행한 폴더 위치에 myfirestrepo(오타났네요;;)라는 폴더를 만들고, 그곳에 원격 저장소의 git history와 파일들을 다운로드합니다.\n\n드디어 과정이 끝났습니다. Rstudio의 오른쪽 아래를 보시면 파일 4개(github에서 만든 3개 + .Rproj 파일)가 있는 것을 확인하시면 과정이 잘 끝난겁니다. 몇 가지가 원래랑 좀 다른데요. 하나는 콘솔창의 가장 위에 보이는 작업공간(working directory)이 바뀌었구요. 그냥 프로젝트를 만들 때와 달리 오른쪽 위 패널에 Git 탭이 추가된 것입니다.\ngithub과 연결된 프로젝트\n축하합니다! 드디어 github의 원격 저장소와 연결된 Rstudio 프로젝트를 성공적으로 만들었습니다. 여기까지 따라하셨으면 새로운 프로젝트를 Git으로 관리하면서 원격 저장소로 Github을 사용하는 상태가 되신겁니다. 이제 git으로 버전관리를 하거나 Github에 관련 내용을 올리는 내용을 포스팅해야겠네요.ㄷㄷㄷ 따라 오시는 동안 궁금한 점이나 이상한 점, 잘 안되거나 하는 부분이 있으면 댓글로 알려주세요. 블로그 글이 도움이 되셨다면, 블로그에 도움을 주실 많은 방법이 있습니다. 감사합니다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106487787-61c58880-64f6-11eb-8ec6-e210d8403e71.png",
    "last_modified": "2021-05-05T05:34:13+00:00",
    "input_file": {}
  },
  {
    "path": "post/번역-haproxy와-docker를-이용한-로드밸런싱/",
    "title": "[번역]Haproxy와 Docker를 이용한 로드밸런싱",
    "description": "load-balancing-applications-with-haproxy-and-docker 라는 제목의 글을 저자의 허락하에 번역하였습니다.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2018-03-12",
    "categories": [
      "docker",
      "haproxy",
      "swarm",
      "load balance"
    ],
    "contents": "\n\nContents\n실제 도커(Docker) 사용 사례에 대한 예제\n\n\n본 번역은 원글을 대상으로 저자의 허락을 받았습니다. 저와 같은 문제에 직면한 분들에게 도움이 되었으면 좋겠습니다.\n\n\n본 글에서 사용하는 이미지인 dockercloud-haproxy에서 확인해보면 기능 추가는 없이 유지보수만 하는 이미지인 것을 알 수 있습니다. 제품에 사용할 때는 참고해주세요.\n\n\n요약 : 도커(Docker)와 도커 스웜(Swarm), 스택(Stack)을 이용해서 여러 개의 컨테이너를 추가 설정없이 연결하고 업데이트(컨테이너 갯수 추가/축소, 버전업 등)하는 실전 예제를 수행해봄.\n\n실제 도커(Docker) 사용 사례에 대한 예제\n최근에 일때문에 Docker, Docker Compose 및 Docker Swarm으로 로드 밸런싱을 하는 글들을 많이 보았습니다. 몇백 개의 인스턴스가 있으며 인스턴스를 관리하고 인스턴스간에 로드 밸런싱을 맞춰야하는 일입니다.\n이 주제를 다루는 많은 글들이 있지만, 정말 쉽고 간단한 사례만 다루기 때문에 도움이 되지 않았습니다. 실제로 필요한 상황을 몇 가지 예로 살펴보면,\n\n수백개의 컨테이너를 수동으로 생성하는 것\n그 수백개의 컨테이너 포트를 각각 다르게 수동으로 설정하는 것\nnginx conf 파일에 각 컨테이너의 ip와 포트를 일일이 작성하는 것\n\n그래서 우리가 현재 사용하고 있는 방법으로 예시 포스트를 작성하기로 결정했습니다. 이것이 “올바른” 방법이나 유일한 방법은 아니지만, 지금 당장 우리가 일하는 방법입니다. 포스트 작성은 Docker, Docker Compose 및 Docker Swarm을 알고 있다고 가정했습니다.\n\n시작해볼까요! :)\n예시를 위한 간단한 어플리케이션\n간단한 Node.js 애플리케이션을 만들어 보겠습니다. 다음 코드를 사용하여 index.js라는 파일을 만듭니다.\nvar http = require('http');\nvar os = require('os');\nhttp.createServer(function (req, res) {\n    res.writeHead(200, {'Content-Type': 'text/html'});\n    res.end(`<h1>I'm ${os.hostname()}<\/h1>`);\n}).listen(8080);\n이제 Dockerfile이라는 이름의 파일을 만들어 아래 코드를 저장합니다. 도커라이즈(Dockerize)1라고 합니다.\nFROM node\nRUN mkdir -p /usr/src/app\nCOPY index.js /usr/src/app\nEXPOSE 8080\nCMD [ \"node\", \"/usr/src/app/index\" ]\n예시로 작성한 간단한 어플리케이션(이하 멋진 Node.js 앱) 도커 이미지를 빌드(build)하기 위해서 터미널에서 docker build -t awesome .이라고 입력합니다. 물론 Dockerfile과 index.js 파일이 한 공간에 있어야 하고 Dockerfile이 있는 곳에서 실행해야 합니다.\n이제 간단하고 (그리고 멋진) Node.js 앱의 도커 이미지가 생겼습니다. 이미지에서 컨테이너를 만들 수 있습니다. 해당 애플리케이션의 20 개 컨테이너가 필요하다고 가정하면 해당 컨테이너를 만들고 관리하는 자동화 된 방법이 필요합니다. 또한 요청을 라우팅하고 Node.js 컨테이너로 로드 밸런싱하기 위해 HTTP 서버가 있는 컨테이너가 필요합니다.\nDocker Compose 사용하기\nHTTP 서버는 HAProxy를 사용합니다. 즉, 포트 80을 수신하고 요청을 포트 8080의 다른 Node.js 컨테이너에 로드 밸런싱하는 HAProxy가 있는 컨테이너를 만들어야 함을 의미합니다. Docker Compose를 사용할 컨테이너 (Node.js 앱 및 HAProxy)를 만들려면 docker-compose.yml 파일을 작성해 보겠습니다.\nversion: '3'\n\nservices:\n  awesome:\n   image: awesome\n   ports:\n     - 8080\n   environment:\n     - SERVICE_PORTS=8080\n   deploy:\n     replicas: 20\n     update_config:\n       parallelism: 5\n       delay: 10s\n     restart_policy:\n       condition: on-failure\n       max_attempts: 3\n       window: 120s\n   networks:\n     - web\n\n  proxy:\n    image: dockercloud/haproxy\n    depends_on:\n      - awesome\n    environment:\n      - BALANCE=leastconn\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock\n    ports:\n      - 80:80\n    networks:\n      - web\n    deploy:\n      placement:\n        constraints: [node.role == manager]\n\nnetworks:\n  web:\n    driver: overlay\n도대체 무슨 일이 일어나는 건지 설명하겠습니다. 우리는 2 가지 서비스를 만들겁니다.\n첫 번째 서비스는 awesome으로 부를 멋진 Node.js 앱입니다. 조금 전에 빌드한 awesome 이미지로 만들겁니다. 8080 포트를 외부에 연결하고, 환경 변수로 SERVICE_PORTS로 작성해두었습니다. HAProxy가 사용하는 설정으로 뒤에서 설명하겠습니다. deploy 옵션으로 20개의 리플레카(replicas)2를 만들고 업데이트 설정과 재시작 설정을 추가했습니다. 파일의 마지막에 작성한 network인 web 네트워크에 모든 컨테이너를 연결해둔 것이 가장 중요한 포인트입니다.\n두 번째 서비스는 Docker 팀의 haproxy 이미지로 만든 HAProxy입니다. 이미 Docker 팀에서 만들어 두었기 때문에 우리는 이미지를 빌드할 필요 없이 가져다 사용하면 됩니다. depends_on 옵션으로 awesome 서비스가 부팅이 완료된 이후에 실행을 시작합니다. 또한 volumes 옵션으로 docker.sock 파일을 공유합니다. HAProxy 컨테이너가 네트워크에 이미 있거나 새롭게 들어오는 컨테이너들을 찾고 확인할 수 있어야 하기 때문입니다. 우리는 80 포트는 외부에 연결했습니다. 그리고 web 네트워크에도 연결했습니다. 마지막으로 deploy 설정에서 manager node에서 항상 실행하도록 설정하였습니다. 이건 Docker Swarm의 설정으로, node가 여러 개라면 volumes 옵션 때문에 필요합니다.\n마지막으로 web이라는 이름의 network를 생성하였습니다.\n\n진행하고 있는 프로젝트가 점점 멋져지고 있습니다. 그리고 거의 끝나갑니다!\nDockerCloud HAProxy 소개\n위에서 언급한대로 HTTP 서버로 HAProxy를 사용할 겁니다. 일반적인 버전이 아니라 Docker 팀이 자신들의 클라우드에서 사용하는 버전을 선택했습니다. awesome 서비스에서 SERVICE_PORTS 환경변수를 사용한 이유이기도 합니다. SERVICE_PORTS 환경변수로 설정한 포트는 HAProxy에 연결됩니다. 쉼표로 구분하여 여러 포트를 연결할 수도 있습니다. 파일을 보면 BALANCE 환경변수도 확인할 수 있습니다. 이것은 로드 밸런싱 알고리즘을 선택하는 것인데요. 기본값인 roundrobin를 선택한 것이 아니라 leastconn으로 설정했습니다.\nDocker Swarm 사용하기\n이제는 Swarm을 만들어 보겠습니다. (지금은 하나의 컴퓨터로 만들었지만 Swarm에 더 많은 컴퓨터를 쉽게 추가 할 수 있음) 이렇게 하기 위해 우리는 docker swarm init을 입력하고 우리는 Swarm을 만들었습니다!! 컴퓨터를 Swarm에 추가했으며, 지금 컴퓨터가 처음이기 때문에 Swarm의 관리자이기도 합니다.\n네트워크, 서비스, 그리고 모든 컨테이너들을 스택(stack)이라고 부릅니다. 스택을 생성하기 위해서는 docker stack 명령어를 사용해야 하지만 스택을 docker-compose.yml 파일로 수행하기를 원합니다. 그래야 우리가 설계한대로 진행해줄테니까요. docker stack deploy --compose-file=docker-compose.yml prod 라고 실행하면 될 것 같습니다. deploy 명령으로 새로운 스택을 배포하고, docker-compose.yml을 사용해 수행하기 위해서 --compose-file 플래그(flag)를 사용했습니다. 물론 이미 있는 스택을 업데이트할 때에도 명령을 사용할 수 있습니다. 마지막으로 우리는 스택을 prod라고 부르기로 했습니다. (이걸 작성할 때 겨우 생각한 이름이 이거라서 죄송합니다. :p)\nhttp://localhost 주소로 요청을 날리면, 우리는 응답으로 컨테이너 ID를 받을 수 있습니다. 그러면 지금 상황에서는 매 요청마다 다른 ID를 받겠죠.\n\n요청마다 다른 컨테이너 ID를 받음\ndocker service ls 명령으로 우리 서비스들을 확인할 수 있습니다. 어떤 서비스가 동작하고 있는지, 몇개의 복사본이 있는지 등을 확인할 수 있죠.\n\n모든 도커 서비스 리스트\n이제 두번째 버전의 awesome 앱을 작성해보겠습니다. 코드를 약간 바꿔서 응답의 마지막에 느낌표를 추가해보겠습니다.\nvar http = require('http');\nvar os = require('os');\nhttp.createServer(function (req, res) {\n    res.writeHead(200, {'Content-Type': 'text/html'});\n    res.end(`<h1>I'm ${os.hostname()}!!!<\/h1>`);\n}).listen(8080);\n이제 다시 빌드를 해야됩니다. 이번에 빌드할 때는 docker build -t awesome:v2 . 라고 이미지에 태그를 추가해보겠습니다. awesome 이미지 이지만 태그가 v2인 이미지를 만드는 것이지요. 서비스의 중단없이 prod 스택에 awesome 서비스를 v2로 교체하기 위해서는 docker service update --image awesome:v2 prod_awesome 명령을 사용합니다. 그러면 docker-compose.yml에 명시한 업데이터 설정과 같이 각 5개의 컨테이너가 순차적으로 업데이트를 할 것입니다.\n도커가 차근차근 하지만 확실히 오래된 컨테이너를 제거하고 새로운 v2 태그의 컨테이너를 실행하는 것을 확인할 수 있습니다. 그 와중에 http://localhost에 요청해도 다운타임 없이 응답을 받을 수 있습니다.\n\n몇몇 컨테이너는 다운타임 없이 두번째 버전을 응답\n만약 20개의 컨테이너보다 더 많이 필요하여 스케일을 키우고 싶다면, docker service scale prod_awesome=503 명령을 수행하면 됩니다. 도커는 awesome:v2 이미지로 30개의 컨테이너를 추가로 실행할 것입니다.\n마무리\n이제 수백 개의 컨테이너를 수동으로 만들 필요가 없습니다. 우리는 앱의 모든 컨테이너를 다른 포트에 둘 필요가 없습니다. 컨테이너 ip와 port를 수동으로 ngninx / haproxy conf 파일에 쓸 필요가 없습니다. 또한 여러 서버 (docker swarm 포함), 여러 서비스 (docker 작성 포함), 중단 시간없이 응용 프로그램 업데이트, 중단 시간없이 확장 (또는 축소) 등의 작업을 수행 할 수 있습니다.\n이번 글이 실용적이었으면 합니다. 그리고 혹시 당신의 회사에서는 어떻게 사용하는지를 알려주시면 매우 기쁘게 듣겠습니다!\n\n역자주: 도커파일로 작성하여 이미지화 하는 것↩︎\n역자주: 복사본이라는 뜻으로 여기서는 같은 이미지에서 생성된 같은 기능을 하는 컨테이너를 뜻함.↩︎\n역자가 가장 도움을 많이 받은 부분↩︎\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106568995-5cf4e900-6577-11eb-9440-f1dd52dafeb8.png",
    "last_modified": "2021-05-05T05:36:14+00:00",
    "input_file": {}
  },
  {
    "path": "post/r로나만의-웹페이지-만들기/",
    "title": "[R로나만의] 웹페이지 만들기 1탄 Rpubs",
    "description": "Rmd + RPubs로 웹페이지를 만들 수 있다. github pages 소개하려다 돌린건 안 비밀.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2018-03-09",
    "categories": [
      "R",
      "rpubs",
      "web",
      "html",
      "Rmd",
      "R로나만의"
    ],
    "contents": "\n\n세줄요약\nRmd + RPubs로 웹페이지를 만들 수 있다.\nRstudio에서 하면 쉽다.\ngithub pages 소개하려다 돌린건 안 비밀.\nWeb에 자신의 결과물을 정리하고 공개하는 것은 시간이 가면 갈 수록 그 중요성을 더해 가고 있습니다.\n\n오늘날 웹사이트를 가지지 않은 사람은 존재하지 않는 것이다.\n\n저는 코드 공유 SNS인 Github을 이용해 코드를 공유하고 대화하는 것을 공부하다 github pages에 대해 알게 되었습니다. 거기에 .Rmd 파일은 웹기술에 대한 사전지식 없이 .html 파일로 변환할 수 있었습니다. R 마크다운 + github pages 조합으로 R에서 만들 수 있는 여려 결과물들을 웹으로 공개하여 인터넷 주소로 공유하는 방법이 있는 것입니다. 이건 다음 번에 설명하기로 하고, Rstudio를 이용해서 .Rmd 문서를 .html 파일로 변경하여 웹페이지로 만들어주는 Rpubs라는 서비스를 소개하겠습니다.\nRpubs\n\nRpubs는 Easy web publishing from R라는 말처럼 Rstudio로 .html 파일을 쉽게 무료로 호스팅해주는 서비스입니다. 우리는 .Rmd 파일로 쉽게 .html 파일을 만들 수 있기 때문에, 이걸 이용해볼 겁니다.\n본래 일반적으로 사용하는 포멧은 .md 파일입니다. 판독(pandoc)이라는 오픈소스 프로젝트를 이용해서 여러 다른 문서 포멧으로 변환할 수 있습니다. 아래 그림은 input -> output인데 한번 확인해 보시죠.\n\n이렇게 많은 변환 기능을 제공해주는 판독을 사용해서 마크다운(.md)을 웹문서(.html)로 변환할 겁니다.\n우리는 knitr 패키지를 이용해서 .Rmd 문서를 .md 파일로 바꾸고, 판독을 이용해서 원하는 다양한 포멧(이번 경우는 .html)으로 바꿉니다.\n\n내부 동작은 이 정도로 가볍게 넘기고, Rstudio를 이용해서 .Rmd 파일을 만들고 저장하고, .html 파일로 바꿔보겠습니다.\n그럼 이제 Rstudio를 실행해 볼까요?\n<img src=“https://user-images.githubusercontent.com/6179259/37238875-1b273872-2473-11e8-8278-40edfd2aff12.PNG”, width=100%>\n새로 파일을 만드는 방법이 몇 가지 있지만, 우리는 아래 방법을 시도해 볼겁니다.\n\nRstudio에서 File 버튼 밑에 새로 만들기 버튼을 누릅니다. 우리가 만들건 R Markdown 입니다.\n\n필요한 패키지가 설치안 안되어 있는데, 설치할꺼냐고 물어보네요! 당연히 Yes를 눌러 패키지들을 설치해줍니다.\n\n패키지가 설치되고 있습니다. 글자가 깨진 부분은 기능에는 이상이 없으니 우선은 넘어가겠습니다. 다음에 기회되면 한번 파보겠습니다.\n\n드디어 Rmd 파일을 만드는 창이 열렸습니다. 많은 옵션이 있지만 저희는 기본으로 진행하려고 하니, 바로 OK를 눌러주세요.\n\n간단한 기능 설명이 포함되있는 문서가 만들어졌습니다. 그럼 간단하게만 구조를 확인해 볼까요?\n\n우선 화면 내에 드래그 한 부분이 YAML header 입니다. YAML은 JSON, XML 같은 양식의 일종입니다. 마크다운에는 header와 body 두 공간이 있습니다. 물론 대부분의 마크업이 같은 구성을 가지고 있습니다. header는 변환하기 위한 설정들을 작성하는 공간입니다. 지금 화면에서는 html문서를 변환결과로 하겠다고 작성한 것입니다. 여기에서 html로 변환할 때의 다양한 옵션을 확인하세요. html 문서 이외에 다른 포멧들의 옵션도 설명이 잘되어 있습니다.\n\nbody 부분은 전부 markdown 문법을 그대로 지원합니다. 문법 설명은 정말 많이 있으니 한 번 확인해보세요. .Rmd는 코드 덩어리에서 R 코드를 실행하고 결과를 함께 .md로 변환해줍니다. 그래서 코드 덩어리 부분 문법만 확인하면 됩니다. 그 문법도 지금 범위는 아니니 레퍼런스를 확인해주세요!\n\n편집 공간의 왼쪽 위에 보면 Knit 버튼이 있습니다. Knit를 바로 누르면 header에 작성한 output 양식에 따라 바로 변환을 진행하구요. Knit 버튼의 화살표를 클릭하면 위의 이미지와 같이 선택할 수 있는 옵션들이 나옵니다. 우리는 .html이 되어야 하므로, 가장 위에 Knit to HTML을 클릭해 보겠습니다.\n\nKnit 과정은 저장이 완료된 파일을 기준으로 변환을 진행하기 때문에 파일이 온전히 저장된 상태여야 합니다. .Rmd 파일을 저장하면 바로 변환 작업을 시작하며, 완료되면 팝업창으로 결과를 보여줍니다.\n\n팝업창을 같이 확인해볼까요? 제일 위에 파일 이름을 보니 test.html로 .html 확장자인 것을 확인할 수 있습니다. 팝업창은 기능이 제한적인 브라우저이므로 Open in Browser 버튼으로 크롬이나 익스플로러에서 파일을 확인할 수 있습니다.\n\n드디어 Publish 버튼입니다. 처음 클릭하면 역시 추가 패키지 설치를 묻는 창이 나오네요. 이전 것도 마찬가지지만 한번 설치하면 다시 물어보지 않습니다. Yes로 설치를 진행해 주세요.\n\nPublish는 두 곳이 가능합니다. 드디어 제가 소개해드린 RPubs를 선택할 수 있게 되었네요. 제 눈에는 free service가 크게 들여옵니다. ㅎㅎ RStudio Connect는 더 다양한 기능을 제공하는 방법(shiny 등)이면서 기업 라이선스에서 많이 사용하는 방법입니다. RPubs를 선택하겠습니다.\n\n경고를 한번 해주는군요. Rpubs는 무료 서비스이기 때문에 모든 사용자에게 공개되는 서비스입니다. 문서를 무료로 웹서비스에 올릴 수 있지만, 제한적인 공개가 어렵다는 단점이 있군요. 신기하게도 검색에도 잘 걸리는 편입니다. 파워포인트 형태의 결과물을 공유하는 slideshare와 비슷하게 보고서 형식의 문서를 공유하는 서비스라고 생각하면 좋을 것 같습니다.\n\nPublish 버튼으로 드디어 문서를 업로드합니다. 두구두구두구두구둥!\n\n브라우저 창이 열리면서 로그인과 회원가입을 선택하는 페이지가 열립니다. 회원가입으로 같이 따라가 볼까요? 로그인을 하면 바로 두 번째 스탭으로 넘어갑니다.\n\n회원가입은 간단합니다. 아이디 역할을 할 email 주소, 문서상 공개될 Username, 이름과 비밀번호 , 비밀번호 확인입니다. 회원가입을 해주세요.\n\n드디어 스텝 2 입니다. 문서의 제목과 설명을 설정할 수 있습니다. Slug라는 생소한 단어가 눈에 띕니다. 간단하게는 문서의 인터넷 주소라고 생각하면 좋습니다. 아무것도 설정하지 않으면 무작위 숫자로 자동 생성해줍니다. 저는 비운 채로 넘어가겠습니다.\n\n짜잔! 축하합니다. 저와 같은 과정을 따라오셨다면 거의 비슷한 문서가 웹주소를 가진 상태로 세상에 공개되었을 겁니다. 예시는 그대로 공개해 두었으니 확인해보세요. http://rpubs.com/test_user0375/368575 링크를 클릭하셔도 좋습니다.\n오른쪽 아래에 댓글 기능인 Comments, 공유하는 Share, 문서보기 모드인 Hide Toolbars를 선택할 수 있습니다. 문서보기 모드가 많이 쓰일 것 같군요.\n데이터 분석에 있어 결과의 공유는 매우 중요합니다. 특히 과학적 방법에 대한 설명과 재현성 확보를 통한 신뢰도 구축은 코드를 통한 문서화만이 달성할 수 있는 목표입니다. 물론 데이터 공유 방법이나 다른 것들이 받침되어야 하겠습니다.\nR markdown 문서를 웹으로 공유해서 좋은 분석가가 되어 보는 것은 어떤가요?\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106486781-59208280-64f5-11eb-81cb-183510282c73.png",
    "last_modified": "2021-05-05T05:35:44+00:00",
    "input_file": {}
  },
  {
    "path": "post/blogdown으로-블로그-이사하기/",
    "title": "blogdown으로 블로그 이사하기",
    "description": "탈도 많았던 blog의 engine 이전을 완료했습니다. 사용하는 테마가 바뀌긴했지만, 그래도 지금 테마가 어느 정도 만족스러워 결정하게 되었습니다. 원래 `jekyll`로 작성한 블로그에서 `blogdown(Hugo)`으로 변경하였는데요. ...",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2018-03-06",
    "categories": [
      "blog",
      "blogdown",
      "hugo",
      "minimal",
      "rstudio"
    ],
    "contents": "\n\n탈도 많았던 blog의 engine 이전을 완료했습니다. 사용하는 테마가 바뀌긴했지만, 그래도 지금 테마가 어느 정도 만족스러워 결정하게 되었습니다. 원래 jekyll로 작성한 블로그에서 blogdown(Hugo)으로 변경하였는데요. blogdown은 rstudio의 수석 엔지니어인 Yihui Xie가 golang으로 작성된 static site generator 입니다. jekyll 또한 같은 범주의 도구이죠.\n그동안 jekyll을 사용한 이유\njekyll은 간단함, 자유로운 테마 선택, 간단함 때문에 사용했습니다.\njekyll의 간단함\njekyll 블로그는 Github 계정만 있으면 아이디.github.io라는 주소로 쉽게 만들 수 있습니다! jekyll-now를 포크하고, pages 설정만 하면 끝납니다.\njekyll은 지향점이 text를 블로그로 바꿔라! 입니다. 덕분에 매우 쉬운 도구가 되었죠. .md 파일을 블로그 포스트에 해당하는 형태로 운영할 수 있게 해줍니다.\nGithub는 ruby라는 언어로 개발되었다고 합니다. 공교롭게도(!) jekyll도 ruby로 작성되어 있죠. 그래서 Github에서 제공하는 pages라는 서비스에서 jekyll를 빌드없이 바로 사용할 수 있습니다. 물론 .Rmd를 .md로 렌더링하는 과정이 필요하기 때문에 R로 블로깅할 때는 아쉬운 대목입니다.\n자유로운 테마 선택\njekyll은 static site generator로써 가장 유명한 도구 입니다. staticgen을 확인해보면 압도적인 스타수를 확인할 수 있습니다. 다음 인기 있는 도구가 Hugo군요. 최근에는 Gatsby도 인기있다고 들었습니다.\n아무튼… jekyll이 가장 인기있고 역사도 있는 만큼 선택할 수 있는 테마의 범위가 가장 넓습니다. jekyllthemes라는 곳에서 잘 모아져 있는 테마들을 구경할 수 도 있고, 따로 만들어진 테마들을 검색해서 찾을 수도 있습니다. 저는 Lagrange라는 테마를 선택했었습니다. 설명이 매우 잘 되어 있고(물론 영어입니다…), 사진 첨부가 기능으로 들어가 있어서 이름만 정해주면 되었고, 결정적으로 디자인이 너무 마음에 들었습니다.\n\njekyll의 간단함\n특별히 동작과정을 이해하려는 노력을 할 것이 아니라면 공부해야 할 부분은 _config.yml 파일입니다.\n# Site Settings\ntitle:               Mrchypark\ntagline:             log for you & me\ndescription:\nbaseurl:            #\"/Lagrange\"\nurl:                #\"https://lenpaul.github.io\"\ngithub:\n  url:               #\"https://lenpaul.github.io/Lagrange\"\nauthor:\n  name:              \"박찬엽\"\n  email:             \"mrchypark@gmail.com\"\n  twitter:           \"mrchypark_\"\n  instagram:         \"mrchypark\"\n  github:            \"mrchypark\"\n  facebook:          \"mrchypark\"\n  linkedin:          \"chanyub.park\"\nnavigation:\n- title: Materials\n  url: /materials\n- title: Index\n  url: /index\n- title: About\n  url: /about\n\n\npaginate:            5\ndisqus:              \"mrchy****\"\nga:                  \"UA-478*****-**\"\n\n# Build settings\nmarkdown:            kramdown\nhighlighter:         rouge\npermalink:           none\ngems:                [jekyll-paginate]\nencoding:            \"UTF-8\"\n이건 기존의 jekyll로 블로그를 만들 때 사용한 _config.yml 파일입니다. 테마가 친절한 편이여서 여러 SNS에 대한 링크를 아이디만 넣어주면 바로 예쁘게 사용할 수 있게 설정해 줍니다. 댓글을 위한 disqus나 GA 또한 ID만으로 연결을 해줍니다.\njekyll에서 blogdown으로\n당연히도 jekyll은 R파베틱(Rphabetic)하지 않기 때문입니다. 물론 Hugo라고 R파베틱한 것은 아니지만, 패키지화되어 있다는 점이 Rstudio와의 호환성을 많이 올려줍니다.\nblogdown은 staticgen에서 두번째를 차지하고 있는 Hugo를 R 패키지화한 도구입니다. Rstudio의 Addin으로 사이트 구축, 새포스트 쓰기 등의 기능도 지원하고 build_site() 명령어 한방으로 docs 폴더에 블로그 구축을 완전히 끝내줍니다. Hugo가 빠른 블로그라는 점도 한 몫했네요.\nblogdown은 설명서가 친절하다 - blogdown을 만든 사람은 bookdown을 만든 사람이기도 합니다. 덕분에 자세한 메뉴얼이 온라인 책으로 준비되어 있기도 합니다.\nrstudio와 호환이 좋다 - 아무래도 일하는 곳에 도구를 지원하는 방식으로 패키지를 작성한 것 같습니다. Addin 기능 뿐만 아니라 Rstudio를 블로그 글쓰기 에디터로 사용하는데 부족함 없게 지원합니다. 물론 버전이 오르면서 한글 문제(정확하게는 중국어 문제)가 해결된 이유도 있습니다.\n빠르다 - 신기하게 Hugo로 넘어간 많은 분들이 jekyll가 느려지는 문제를 지적하였습니다. 제 블로그가 글이 많지는 않지만 미래를 대비하고자 하는 마음도 있었습니다.\n다시 도구 이전 신고\n네, 블로그를 blogdown으로 이전하였습니다. 추후 시간이 되면 blogdown으로 블로그를 만드는 법에 대해서 포스팅하도록 하겠습니다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106467983-b52cdc00-64e0-11eb-9f46-1f97f8abf56b.png",
    "last_modified": "2021-05-05T05:33:46+00:00",
    "input_file": {}
  },
  {
    "path": "post/rphabetic-알파베틱-제안/",
    "title": "Rphabetic(알파베틱) 제안",
    "description": "사용자 친화적 혹은 사용자가 이용하기 쉬운 을 개인적으로는 `Rphabetic`하다고 표현하려 합니다.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2018-03-06",
    "categories": [
      "suggest",
      "R",
      "term"
    ],
    "contents": "\n\nPython 공부를 하면서 재밌으면서도 직관적인 단어를 알게 되었는데, Pythonic way입니다. 말하지 않아도 파이썬스러운 방법이라는 뜻이라는게 한눈에 들어오더라구요. Pythonic 하다, 하지 않다로도 많이 사용하는 것을 봤습니다.\n그래서 R에서는 비슷한 단어가 없는건가 싶더라구요. 찾아보니 R's way가 있었습니다만, 힙하지 않아 보였습니다.(힙이라니…)\n아무튼 한국 R 유저 그룹에 글을 올려 의견을 물었습니다. 제가 R-legant하다를 먼저 제시하면서 다른 분들도 많은 의견을 주셨습니다. 그러다가 역시 조금은 억지스러운가 라는 생각이 들었는데요. Rcoholic 같이 발음으로도 좀 더 자연스러워야하지 않은가 싶더라구요.\n고민 끝에 개인적으로는 Rphabetic하다고 표현하려 합니다.\n굳이 정의하자면, 사용자 친화적 혹은 사용자가 이용하기 쉬운 이라고 하면 어떨까요. 전에 리디북스의 분석가이신 하헌철님께서 언급해주신 R의 철학에 가까운 의미이지 않나 생각이 듭니다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106484489-0219ae00-64f3-11eb-8312-f4f6f8907adb.png",
    "last_modified": "2021-05-05T05:34:43+00:00",
    "input_file": {}
  },
  {
    "path": "post/구글-광고-추가/",
    "title": "구글 광고 추가",
    "description": "블로그 하단에 구글 광고를 추가하였습니다. 처음 붙여보는 것이라 하단 이외에 다른 곳에서도 광고가 나올 수 있습니다.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2018-03-06",
    "categories": [
      "anounce",
      "ad"
    ],
    "contents": "\n\n블로그 하단에 구글 광고를 추가하였습니다. 처음 붙여보는 것이라 하단 이외에 다른 곳에서도 광고가 나올 수 있습니다. 읽어보시는 글이 도움이 되셨다면 클릭 한 번 부탁드리겠습니다. 저는 여러 정보성 글로 먹고 사는 일을 하고 싶습니다. 후원, 유료 컨텐츠등 다양한 방향으로도 시도할 계획이니 많은 관심 부탁드립니다.\n감사합니다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106467282-c32e2d00-64df-11eb-9435-7ed1cc5bf3e0.png",
    "last_modified": "2021-05-05T05:36:07+00:00",
    "input_file": {}
  },
  {
    "path": "post/materials-페이지-업데이트/",
    "title": "Materials 페이지 업데이트",
    "description": "제 블로그 왼쪽 위에 Materials라는 메뉴를 추가하였습니다.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2017-11-22",
    "categories": [
      "news",
      "blog",
      "materials"
    ],
    "contents": "\n\n제 블로그 왼쪽 위에 Materials라는 메뉴가 있습니다. 작성하는 자료들을 모아 놓는 공간으로 따로 분류해 두었었는데, 그동안 만든 자료들이 좀 있어서 내용을 업데이트했습니다.\n짧게 소개하면 제가 패스트 캠퍼스에서 진행했던 강의 자료와 R로 api 서버 만들기, 크롤링 하기, github 함께 사용하기 같은 발표자료를 링크해 두었습니다.\n혹시 살펴보시다가 이야기해주실 부분에 대해서는 언제든지 어떤 체널로든 피드백 부탁드립니다.\n감사합니다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106466661-f9b77800-64de-11eb-807d-fcedbfbc1df0.png",
    "last_modified": "2021-05-05T05:34:30+00:00",
    "input_file": {}
  },
  {
    "path": "post/한글-띄어쓰기-api-이용하기/",
    "title": "한글 띄어쓰기 API 이용하기",
    "description": "현재 아래 소개하는 api는 동작하지 않으며 KoSpacing패키지가 새롭게 배포되었습니다.\n패키지 사용 환경 설정은 본 블로그의 다른 포스트를 참고하세요.\nKoNLP 패키지를 만드신 고감자님께서 KoNLP에 한글 자동 띄어쓰기 기능을 추가하시기 위해서 관련 연구를 수행하시고 우선 결과물로 웹 요청으로 결과를 제공하는 API를 우선 공개하셨습니다....",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2017-10-09",
    "categories": [
      "R",
      "httr",
      "api",
      "server",
      "POST",
      "GET"
    ],
    "contents": "\n\nContents\n업데이트\n띄어쓰기 api 요청하기\nhttp 란\nR로 http 요청하기\n\n\n\n업데이트\n현재 아래 소개하는 api는 동작하지 않으며 KoSpacing 패키지가 새롭게 배포되었습니다.\n패키지 사용 환경 설정은 본 블로그의 다른 포스트를 참고하세요.\nKoNLP 패키지를 만드신 고감자님께서 KoNLP에 한글 자동 띄어쓰기 기능을 추가하시기 위해서 관련 연구를 수행하시고 우선 결과물로 웹 요청으로 결과를 제공하는 API를 우선 공개하셨습니다.(관련글) 사용법도 함께 공개하셨는데, R에서는 사용이 어색할 수 있는 reticulate 패키지로 예시를 작성해주셔서 R에서 많이 사용하는 패키지들로 예시코드를 공유하면서 웹 요청에 대한 내용도 함께 공유해볼까 합니다.\n띄어쓰기 api 요청하기\n먼저 공유해주신 코드를 살펴보겠습니다.\nlibrary(reticulate)\n\nrequests <- import('requests')\n\nspaced_sent <- requests$put('http://35.201.156.140:8080/spacing', \n      data=list(sent=\"아래와같은방식으로API를사용할수있으며,호출건수에대해서별도의제한은없으나,1회 호출에200글자로글자수를제한하고있다.\"))$json() \n\nprint(spaced_sent$sent)\nreticulate는 파이썬 코드를 R에서 사용할 있게 interface 해주는 패키지로 위 코드를 실행하기 위해서는 reticulate 패키지, 파이썬, 파이썬의 requests 패키지가 필요합니다. 그럼 R에서 웹 요청을 보내기 좋은 httr 패키지로 코드를 바꿔보겠습니다.\nif (!requireNamespace(\"httr\")) install.packages(\"httr\")\nlibrary(httr)\n\nbody<-list(sent=\"아래와같은방식으로API를사용할수있으며,호출건수에대해서별도의제한은없으나,1회 호출에200글자로글자수를제한하고있다.\")\nres<-PUT(url='http://35.201.156.140:8080/spacing', body=body)\n\ncontent(res)$sent\n## [1] \"아래와 같은 방식으로 API를 사용할 수 있으며, 호출 건수에 대해서 별도의 제한은 없으나, 1회 호출에 200글자로 글자수를 제한하고 있다. \"\n관련 기능을 만드실 때 고감자님에게 도움을 드린 것이 있는데 직접 언급해주셨습니다. 다시 한번 감사드립니다. 아래로는 http란, R에서 간단한 크롤링이나 api를 사용하기 위한 패키지 소개 및 간단한 사용 예시가 작성되어 있습니다.\nhttp 란\nhttp란 보통 1999년에 발표된 http/1.1 버전을 뜻합니다. 해당 링크에서 보면 프로토콜이란 하나의 약속입니다. 브라우저와 서버가 서로 데이터를 주고 받기 위해서 만든 규칙이라고 이해하시면 좋습니다. 그렇다면 웹의 정보를 R에서 가져오기 위해서는 서버에게 브라우저가 요청하는 약속을 그대로 따라하면 좋을 것 같습니다.\nR로 http 요청하기\nhttp로 요청하는 다양한 방법이 있지만, 간단하게는 GET과 POST만 이해하시면 됩니다. 서버에게 요청하는 것은 request, 응답을 받는 것은 response라고 하겠습니다.__(그놈의 영어)__ 우선 GET부터 보겠습니다.\nGET 요청\nGET은 서버의 주소만으로 서버에 데이터를 요청하는 방법입니다. 대부분의 브라우저에 주소를 입력하고 엔터를 누르는 것과 같습니다. GET이라는 것을 메소드라고 부릅니다. R에서는 http 요청을 하기 위한 다양항 패키지가 있지만 메소드 이름을 바로 함수로 제공하는 httr 패키지를 사용하겠습니다.\n\n\nif (!requireNamespace(\"httr\")) install.packages(\"httr\")\nlibrary(httr)\nres<-GET(\"https://mrchypark.github.io/\")\ncontent(res)\n\n\n{html_document}\n<html xmlns=\"http://www.w3.org/1999/xhtml\" lang=\"\" xml:lang=\"\">\n[1] <head>\\n<meta http-equiv=\"Content-Type\" content=\"text/html; cha ...\n[2] <body class=\"layout-listing\">\\n\\n<!--radix_placeholder_front_ma ...\n\n위의 결과에서 <html>이라고 나온 것을 볼 수 있습니다. html는 css, javascrit와 함께 브라우저가 사람들이 볼 수 있는 그림을 그리도록 만들어진 규칙입니다. GET 요청은 대부분 서버에서 이런 html 문서를 데이터로 받기 위해서 브라우저에서 동작하는 방식입니다. 알고 계신 다른 사이트들을 시도해보시면 더 이해가 좋을 것 같습니다. 이 html 문서에서 필요한 곳의 내용만 추출하는 패키지로 rvest 패키지가 있습니다. rvest 패키지 사용법은 많은 분들이 소개해주셔서 검색해 보시길 추천드립니다.\nPOST 요청\nPOST는 서버에 데이터를 요청할 때 뭔가 값을 함께 요청하는 방식입니다. 대표적으로 로그인이 있습니다. 위 고감자님의 요청은 PUT을 사용했는데, POST와 거의 같습니다. POST를 값을 실어보내는 것을 body라고 합니다. body는 R에서는 list 자료형으로 처리합니다.\n\n\nbody<-list(sent=\"아래와같은방식으로API를사용할수있으며,호출건수에대해서별도의제한은없으나,1회 호출에200글자로글자수를제한하고있다.\")\nbody\n\n\n$sent\n[1] \"아래와같은방식으로API를사용할수있으며,호출건수에대해서별도의제한은없으나,1회 호출에200글자로글자수를제한하고있다.\"\n\n위 띄어쓰기 API 요청을 보면 body를 선언하는 부분이 list로 되어 있고, 데이터는 띄어쓰기가 필요한 문장, 그 이름을 sent로 하였습니다. 이건 서버에 sent라는 이름으로 띄어쓰기가 필요한 문장을 함께 전달하기 위해서 선언한 겁니다.\nPUT은 POST와 거의 같다고 했습니다. 여기서는 예시를 PUT으로 하겠습니다.\nres<-PUT(url='http://35.201.156.140:8080/spacing', body=body, verbose())\n위는 PUT요청을 했을 때 일어나는 일들 전체를 보여줍니다. httr 패키지가 다 알아서 해주니 우리는 이제 아래처럼 요청하면 됩니다.\nres<-PUT(url='http://35.201.156.140:8080/spacing', body=body)\nres는 PUT 요청으로 서버에게 요청을 했을 때 서버가 우리에게 돌려준 결과를 저장하였습니다. 위에서 말한 response입니다.\nres\n## Response [http://35.201.156.140:8080/spacing]\n##   Date: 2018-03-05 07:15\n##   Status: 200\n##   Content-Type: application/json\n##   Size: 348 B\n## {\"sent\": \"\\uc544\\ub798\\uc640 \\uac19\\uc740 \\ubc29\\uc2dd\\uc73c\\ub85c API\\u...\n실제로 값에 response라고 하면서 여러 정보를 보여주고 있습니다. 어느 서버 주소에서 받은 것인지, 언제 받았는지, 상태는 얼마인지 받은 데이터가 어떤 것인지, 받은 데이터의 크기가 얼마나 되는지 같은 것들이네요. 하나하나 따져 보시려면 str(res)를 수행해보시면 좋을 것 같습니다. http가 response를 어떻게 정의해 놨는지 알 수 있습니다.\n이 중에서 우리가 궁금한 것은 content입니다. httr 패키지는 response 객체에서 content만 보는 기능을 content() 함수로 제공하고 있습니다. content()함수는 몇몇 유명한 형식에 대해서 자동으로 가져오는 기능을 제공합니다.\ncontent(res)\n## $sent\n## [1] \"아래와 같은 방식으로 API를 사용할 수 있으며, 호출 건수에 대해서 별도의 제한은 없으나, 1회 호출에 200글자로 글자수를 제한하고 있다. \"\ncontent에 json 방식으로 준 모양입니다. R은 json 방식의 데이터를 list 자료형으로 해석합니다. json의 설명을 확인해 보세요. list 이름이 sent인걸 보니 마지막 단계만이 남았습니다.\ncontent(res)$sent\n## [1] \"아래와 같은 방식으로 API를 사용할 수 있으며, 호출 건수에 대해서 별도의 제한은 없으나, 1회 호출에 200글자로 글자수를 제한하고 있다. \"\nresData<-content(res)\nresData$sent\n## [1] \"아래와 같은 방식으로 API를 사용할 수 있으며, 호출 건수에 대해서 별도의 제한은 없으나, 1회 호출에 200글자로 글자수를 제한하고 있다. \"\nOpen API 라고 되어 있는 서비스들이 위와 같은 방식을 사용하고 있습니다. 보통은 sent라고 되어 있는 부분(요청시 body로 선언할 내용과 방법)을 서비스 제공자 쪽에서 설명해줘야 합니다. 다른 API 서비스를 사용하실 때 오늘의 내용이 도움이 되었으면 합니다.\n끝까지 읽어주셔서 감사합니다. 질문, 지적 대환영이며 댓글로 부탁드립니다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106461744-8c084d80-64d8-11eb-93a4-ebedf3fb21c7.png",
    "last_modified": "2021-05-05T05:37:05+00:00",
    "input_file": {}
  },
  {
    "path": "post/논리-연산자-정리/",
    "title": "논리 연산자 정리",
    "description": "드디어 블로그를 단순하게 유지하기 위해 distill로 옮깁니다.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2017-07-31",
    "categories": [
      "operator",
      "logical",
      "Boolean",
      "R",
      "rlang"
    ],
    "contents": "\n\nContents\n논리 연산자란\n논리 연산자\n논리 연산자 왼쪽의 데이터가 1개 일때\n논리 연산자 왼쪽의 데이터가 여러개 일때\n논리 연산자 데이터가 모두 여러개 일때\n\n\n드디어 블로그에서 Rmd를 사용할 수 있게 되어서 매우 기쁜 마음에 포스팅을 하나 기획하였습니다. 그것은 바로 논리 연산자! 기본적은 것은 다 쉬운데 데이터가 여러 개인 벡터(vector)일 때 동작에 대해서 많이 고민하지 않는 것 같아 이렇게 첫 번째 주제로 잡았습니다.\n논리 연산자란\n논리 연산자(Logical Operators)란 논리 자료형(logical로 표시하며 T/F를 의미)를 사칙 연산처럼 TRUE / FALSE 를 계산하여 하나의 결과를 만드는 것이라고 할 수 있습니다. 대표적으로 if 구문에 해당하는 조건문에서 사용하는데요, 코드를 짤 때 조건문을 피할 수 없기 때문에 동작에 대해 잘 이해하고 있는 것이 좋습니다.\nR에서 사용하는 논리 연산은 아래와 같습니다.\n논리 연산자\na, b: 숫자 데이터 1개\nx, y: 논리 데이터 1개\n\n\n연산자\n\n\n설명\n\n\na < b\n\n\na가 b보다 작다\n\n\na <= b\n\n\na가 b보다 작거나 같다\n\n\na > b\n\n\na가 b보다 크다\n\n\na >= b\n\n\na가 b보다 크거나 같다\n\n\na == b\n\n\na와 b가 같다\n\n\na !=\n\n\na와 b가 같지 않다\n\n\n!x\n\n\nx가 아니다\n\n\nx | y\n\n\nx이거나 y이다\n\n\nx & y\n\n\nx이고 y이다\n\n\nisTRUE(x)\n\n\nx가 TRUE이다\n\n\n더하기, 빼기 같은 산술 연산자도 있으니 R에서 사용하는 연산자 소개는 이곳을 참고하면 좋을 것 같습니다. 위에서 강조한 바와 같이 위에 논리 연산자는 모두 데이터가 1개 일때를 의미합니다. 정확하게는 연산자의 왼쪽인 a는 여러 데이터인 벡터(vector)여도 되는데, 연산자의 오른쪽인 b는 한 개 여야만 합니다. 아니, 여러 개일 때 어떻게 동작하는지 알고 있어야 합니다.\n우선 a가 1개일 때와 여러 개일 때를 확인해 보겠습니다.\n논리 연산자 왼쪽의 데이터가 1개 일때\n데이터가 1개인 경우는 매우 간단하고, 모두 상상하는 처음 예시이기도 합니다.\n\n\na <- 10\nb <- 30\n\na < b\n\n\n[1] TRUE\n\na <= b\n\n\n[1] TRUE\n\na > b\n\n\n[1] FALSE\n\na >= b\n\n\n[1] FALSE\n\na == b\n\n\n[1] FALSE\n\na != b\n\n\n[1] TRUE\n\n위에는 모두 상상하시는 대로 결과가 나왔으리라 생각합니다. 맨 아래만 짚어보면 =는 <-와 같은 뜻이어서, 수학적인 등호의 역할을 하길 기대해야 하는 기호는 ==입니다. ==는 왼쪽과 오른쪽이 같다라는 뜻입니다. 그리고 맨 위에 !x에 x가 아니다라는 설명을 해두었습니다. x는 논리 데이터 1개라는 설명도 했죠. 그러다 보니 !=는 !(a == b)와 의미가 같습니다. 작성하기 편하게 하기위해서 약어처럼 정의를 해둔 것이지요. 보통은 논리 자료형 앞에 붙어서 원래 결과의 부정을 뜻합니다. |나 &는 잘 아시리라 생각하고, isTRUE()를 좀 확인해 보겠습니다.\nisTRUE()\nR에서 몇 가지 요령이 있는데, ?함수이름, help(함수이름)이라고 하면 설명이 나오고, ()를 붙이지 않고 함수이름만 콘솔에 입력하면 그 함수를 구성하는 코드가 출력됩니다.\n\n\nisTRUE\n\n\nfunction (x) \nis.logical(x) && length(x) == 1L && !is.na(x) && x\n<bytecode: 0x558ded2612f0>\n<environment: namespace:base>\n\nisTRUE()가 어떻게 동작하는 함수인지 궁금해서 코드를 확인해 봤습니다. 여러개가 있지만 눈에 들어오는 것은 identical(TRUE, x)네요. 입력인자인 x가 TRUE와 같은 것인지를 확인하는 것입니다. identical()은 정확하게 같은지를 결과로 줍니다. 예를 들면 같은 숫자인데 자료형이 다르던가, R은 NA를 계산할 수 없음으로 취급해서 ==으로 확인하면 NA로 결과를 줍니다. 그래서 rstudio를 사용하시면 == NA를 인식해서 is.ns()를 사용하라고 경고를 주기도 합니다. 아래 코드를 봐주세요.\n\n\n2L == 2\n\n\n[1] TRUE\n\nidentical(2L,2)\n\n\n[1] FALSE\n\n10 == NA\n\n\n[1] NA\n\n10 != NA\n\n\n[1] NA\n\n10 > NA\n\n\n[1] NA\n\nidentical(10,NA)\n\n\n[1] FALSE\n\n그래서 isTRUE(x)는 x가 TRUE와 완전히 같은지를 확인해서 같으면 TRUE, 다르면 FALSE를 결과로 주는 함수입니다. 조건문 안에 identical()은 익숙해지면 자주 사용하는 함수이니 확인해주세요.\n논리 연산자 왼쪽의 데이터가 여러개 일때\n데이터가 여러개라는 것은 벡터(vector)로 구성한다는 뜻입니다. 우선 결과를 확인해 보겠습니다. 일반적으로 벡터를 만들 때는 c()를 사용합니다. ?c로 설명서를 확인해 보세요.\n\n\na <- c(10,20,30,40,50)\nb <- 30\n\na <  b\n\n\n[1]  TRUE  TRUE FALSE FALSE FALSE\n\na <= b\n\n\n[1]  TRUE  TRUE  TRUE FALSE FALSE\n\na > b\n\n\n[1] FALSE FALSE FALSE  TRUE  TRUE\n\na >= b\n\n\n[1] FALSE FALSE  TRUE  TRUE  TRUE\n\na == b\n\n\n[1] FALSE FALSE  TRUE FALSE FALSE\n\na != b\n\n\n[1]  TRUE  TRUE FALSE  TRUE  TRUE\n\n결과를 확인해 보면 모두 a 데이터의 개수인 5개 만큼 결과 또한 출력된 것을 확인할 수 있습니다. 이것은 산술 연산자에서도 확인할 수 있는 동작인데요.\n\n\na <- c(10,20,30,40,50)\nb <- 30\n\na + b\n\n\n[1] 40 50 60 70 80\n\na - b\n\n\n[1] -20 -10   0  10  20\n\na * b\n\n\n[1]  300  600  900 1200 1500\n\na / b\n\n\n[1] 0.3333333 0.6666667 1.0000000 1.3333333 1.6666667\n\na ** b\n\n\n[1] 1.000000e+30 1.073742e+39 2.058911e+44 1.152922e+48 9.313226e+50\n\na %% b\n\n\n[1] 10 20  0 10 20\n\na %/% b\n\n\n[1] 0 0 1 1 1\n\n이렇게 연산자의 왼쪽이 여러개의 데이터인 벡터이고, 오른쪽이 데이터 1개 일때(데이터가 1개 일때도 벡터라고 합니다.) 연산자는 왼쪽 데이터를 기준으로 각각 연산을 수행해서 왼쪽 데이터의 개수만큼 결과를 보여줍니다. 그렇다면, 논리 연산자 오른쪽의 데이터가 여러개면 어떻게 될까요? 예상되실 겁니다.\n\n\na <- 30\nb <- c(10,20,30,40,50)\n\na <  b\n\n\n[1] FALSE FALSE FALSE  TRUE  TRUE\n\na <= b\n\n\n[1] FALSE FALSE  TRUE  TRUE  TRUE\n\na > b\n\n\n[1]  TRUE  TRUE FALSE FALSE FALSE\n\na >= b\n\n\n[1]  TRUE  TRUE  TRUE FALSE FALSE\n\na == b\n\n\n[1] FALSE FALSE  TRUE FALSE FALSE\n\na != b\n\n\n[1]  TRUE  TRUE FALSE  TRUE  TRUE\n\n논리 연산자 데이터가 모두 여러개 일때\n그럼 이제 마지막 경우를 남겨두고 있습니다. 양쪽 다 여러개의 데이터인 경우인데요, 이 경우에서도 데이터의 개수가 같은 경우와 다른 경우로 달라집니다.\n데이터의 개수가 같은 경우\n먼저 결과부터 보시죠\n\n\na <- c(10,20,30,40,50)\nb <- c(1,2,3,4,5)\n\na <  b\n\n\n[1] FALSE FALSE FALSE FALSE FALSE\n\na <= b\n\n\n[1] FALSE FALSE FALSE FALSE FALSE\n\na > b\n\n\n[1] TRUE TRUE TRUE TRUE TRUE\n\na >= b\n\n\n[1] TRUE TRUE TRUE TRUE TRUE\n\na == b\n\n\n[1] FALSE FALSE FALSE FALSE FALSE\n\na != b\n\n\n[1] TRUE TRUE TRUE TRUE TRUE\n\n개수가 같으니 결과도 같은 개수만큼 나왔고, 그 의미는 각각의 위치에 것들이 각각 연산되었다는 뜻입니다. |나 &도 같이 동작하는지 보시죠\n\n\nx <- c(T,T,T)\ny <- c(T,F,F)\n\nx & y\n\n\n[1]  TRUE FALSE FALSE\n\nx | y\n\n\n[1] TRUE TRUE TRUE\n\n|나 &도 똑같이 결과가 데이터의 갯수와 같이 3개로 나오는 것을 볼 수 있습니다. 그런데, 논리 자료형의 연산 결과가 여러 개인 경우는 사실 조건문을 사용하는데 좋은 결과가 아닙니다. 그래서 논리 자료형의 연산 결과를 1개로 정리하는 방법들이 있습니다.\n\n\nx <- c(T,T,T)\ny <- c(T,F,F)\n\nany(y)\n\n\n[1] TRUE\n\nall(y)\n\n\n[1] FALSE\n\nx && y\n\n\n[1] TRUE\n\nx || y\n\n\n[1] TRUE\n\n첫번째 방법은 any(), all()함수를 사용하는 방법입니다. 두 함수 모두 인자로 논리 자료형의 벡터를 사용하는데요, any()는 뭐라도 하나 TRUE라면 TRUE를 결과로 줍니다. any라는 이름에 걸맞죠. all()은 전부 TRUE여야 TRUE를 줍니다. 역시 all이라는 이름에 걸맞습니다. 여러개의 논리 데이터를 하나의 결과로 정리한다는 점에서 조건문에 사용하기 좋습니다.\n그 아래 ||와 &&도 결과를 한개만 준다는 점에서는 같습니다만 연산 방식이 다릅니다. 이 두 연산자는 양쪽에 데이터가 여러개가 온다고 하더라도 첫번째 데이터만 사용합니다. 조건문의 ()에 논리 데이터가 여러개이면 경고를 주고 첫번째 데이터만 사용한다고 합니다. ||와 &&은 의도적으로 모두 첫번째 데이터만 연산에 사용한다는 것을 명시적으로 표현하는 것입니다. 한번 확인해 보겠습니다.\n\n\nx <- c(T,T,T)\ny <- c(T,F,F)\nx && y\n\n\n[1] TRUE\n\nx || y\n\n\n[1] TRUE\n\nx <- c(F,T,T)\ny <- c(T,F,F)\nx && y\n\n\n[1] FALSE\n\nx || y\n\n\n[1] TRUE\n\nx <- c(T,T,T)\ny <- c(F,F,F)\nx && y\n\n\n[1] FALSE\n\nx || y\n\n\n[1] TRUE\n\nx <- c(F,T,T)\ny <- c(F,F,F)\nx && y\n\n\n[1] FALSE\n\nx || y\n\n\n[1] FALSE\n\n지금은 앞에만 달리하며 출력했는데, 뒤에 데이터를 변경해서 결과가 달라지지 않는 것을 직접 확인해 보시면 좋을 것 같습니다. 더 자세한 정보는 ?\"|\"로 확인하실 수 있습니다. 한 문장만 가져와서 보여드리면\n\nThe longer form evaluates left to right examining only the first element of each vector.\n\n여기서 longer form이 ||나 &&를 뜻합니다.\n데이터의 개수가 다른 경우\n데이터의 개수가 다른 경우는 또 두 가지 경우로 나뉩니다. 두 데이터의 개수가 배수 관계에 있는 경우와 아닌 경우입니다. 배수인 경우 먼저 보시죠\n데이터의 개수가 배수 관계인 경우\n\n\na <- c(10,20,30,40,50,60)\nb <- c(10,20,30)\n\na <  b\n\n\n[1] FALSE FALSE FALSE FALSE FALSE FALSE\n\na <= b\n\n\n[1]  TRUE  TRUE  TRUE FALSE FALSE FALSE\n\na > b\n\n\n[1] FALSE FALSE FALSE  TRUE  TRUE  TRUE\n\na >= b\n\n\n[1] TRUE TRUE TRUE TRUE TRUE TRUE\n\na == b\n\n\n[1]  TRUE  TRUE  TRUE FALSE FALSE FALSE\n\na != b\n\n\n[1] FALSE FALSE FALSE  TRUE  TRUE  TRUE\n\n우선 결과가 경고 없이 잘 나왔고, 총 6개입니다. 이때는 개수가 부족한 쪽이 개수가 많은 쪽 만큼 한번 더 돌아서(Recycle) 연산에 사용된 것을 알 수 있습니다. 이것을 Recycling Rule이라고 합니다. 배수관계에 있다보니 특별히 잘못했다고 경고를 주지도 않습니다. 그럼 배수 관계가 아닐 떈 어떻게 될까요?\n데이터의 개수가 배수 관계가 아닌 경우\n\n\na <- c(10,20,30,40,50)\nb <- c(10,20,30)\n\na <  b\n\n\n[1] FALSE FALSE FALSE FALSE FALSE\n\na <= b\n\n\n[1]  TRUE  TRUE  TRUE FALSE FALSE\n\na > b\n\n\n[1] FALSE FALSE FALSE  TRUE  TRUE\n\na >= b\n\n\n[1] TRUE TRUE TRUE TRUE TRUE\n\na == b\n\n\n[1]  TRUE  TRUE  TRUE FALSE FALSE\n\na != b\n\n\n[1] FALSE FALSE FALSE  TRUE  TRUE\n\n똑같이 Recycling Rule이 적용되어 적은 쪽이 많은 쪽 개수 만큼 한번 더 돌아서 사용하여 연산하지만, 쓰다 말기 때문에 경고를 줍니다. 배수관계가 아닌데 너가 지금 잘 사용한 게 맞는거냐라고 물어보는 거죠. 맞다면 무시하시면 됩니다. 결과도 긴 데이터쪽 개수만큼인 5개로 나왔네요. 의도하신거라면 이대로 진행하시면 됩니다.\n이렇게 논리 연산자도 데이터가 여러개일 때 산술 연산자와 같은 동작을 취합니다. 이 부분이 아마 기초를 배운 후에 조합해서 확인해 봐야 하는 부분인 것 같습니다. 그리고 많이 실수하시는 부분이 있습니다. 논리 자료형이라면 특별히 문제되지 않는데, ==의 동작을 오해하세요. 사실 이걸 이야기하고 싶어서 위에 저 많은 얘기를 했는데요. 이미 주제 하나 정도 되는 것 같아 포스트를 나누겠습니다.\n다음 포스트는 왜 %in% 연산자를 사용하는가? feat.== 입니다.\n끝까지 읽어주셔서 감사합니다. 질문, 지적 대환영이며 댓글로 부탁드립니다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106395892-0e94fc80-6448-11eb-9836-f3f8449a472b.png",
    "last_modified": "2021-05-05T05:36:10+00:00",
    "input_file": {}
  },
  {
    "path": "post/블로그-reboot/",
    "title": "블로그 reboot",
    "description": "blogdown으로 옮겨서 시작합니다.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2017-04-05",
    "categories": [
      "anounce",
      "blog",
      "reboot"
    ],
    "contents": "\n\n블로그를 찾아주신 모든 분들 반갑습니다! 안녕하세요 박찬엽입니다. 여러 블로그 도구들과 씨름하다 정착하고 싶어 어느 정도 정리했습니다. 가능하면 한 번에 처리할 방법들을 고민하고 사용해보고 하는 기간이 길었던 것 같습니다. reboot라고 제목을 지은 이유는 이런 저런 실험을 하고 OS에 환경을 세팅하고 난 후에는 reboot을 하기 때문입니다. 이제 다시 reboot할 일 없는 열일하는 서버처럼 잘 운영해 보겠습니다.\n감사합니다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106381525-aff66100-63fc-11eb-878f-724b1f26b387.png",
    "last_modified": "2021-05-05T05:36:20+00:00",
    "input_file": {}
  }
]
