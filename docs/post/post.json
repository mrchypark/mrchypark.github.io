[
  {
    "path": "post/distill로-옮깁니다/",
    "title": "distil로 옮깁니다",
    "description": "드디어 블로그를 단순하게 유지하기 위해 distill로 옮깁니다.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2021-01-28",
    "categories": [],
    "contents": "\n\nContents\nblogdown의 대안을 찾아서\ndistill 소개\n\nblogdown의 대안을 찾아서\nblogdown은 꽤 오랫동안 사용한 블로그 패키지다. 여전히 좋은 패키지라고 생각한다. blogdown 또한 rstudio에서 관리하며, 최근 버전 1.0.0 을 출시했다.\n대안이 필요한 이유는 blogdown 자체의 문제만은 아니지만, 여전히 문제다.\n한글 윈도우 rstudio 에서 빌드시 경로 문제가 발생할 때가 있다.\n캐쉬 동작을 이해하지 못해서 빌드 결과가 다르다.\nrstudio가 글 작성 도구로써 매우 좋다고 할 수 없다.\nrstudio가 글 작성 도구로써 매우 좋다고 할 수 없는 이유는, 우선 매우 무겁기 때문이다. 오죽하면 Rmd 전용 글 작성 도구만 따로 만들까 고민하던 적이 있기도 하다.(지금도 유효하다.)\ndistill 소개\ndistill 은 rstudio 의 패키지로\n\n\nShow code\n\nlibrary(\"dplyr\")\n\nmtcars %>% \n  tibble() %>% \n  filter(mpg >20)\n\n\n# A tibble: 14 x 11\n     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb\n   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n 1  21       6 160     110  3.9   2.62  16.5     0     1     4     4\n 2  21       6 160     110  3.9   2.88  17.0     0     1     4     4\n 3  22.8     4 108      93  3.85  2.32  18.6     1     1     4     1\n 4  21.4     6 258     110  3.08  3.22  19.4     1     0     3     1\n 5  24.4     4 147.     62  3.69  3.19  20       1     0     4     2\n 6  22.8     4 141.     95  3.92  3.15  22.9     1     0     4     2\n 7  32.4     4  78.7    66  4.08  2.2   19.5     1     1     4     1\n 8  30.4     4  75.7    52  4.93  1.62  18.5     1     1     4     2\n 9  33.9     4  71.1    65  4.22  1.84  19.9     1     1     4     1\n10  21.5     4 120.     97  3.7   2.46  20.0     1     0     3     1\n11  27.3     4  79      66  4.08  1.94  18.9     1     1     4     1\n12  26       4 120.     91  4.43  2.14  16.7     0     1     5     2\n13  30.4     4  95.1   113  3.77  1.51  16.9     1     1     5     2\n14  21.4     4 121     109  4.11  2.78  18.6     1     1     4     2\n\nShow code\n\nprint(\"heloe\")\n\n\n[1] \"heloe\"\n\n\n\n\n",
    "preview": {},
    "last_modified": "2021-02-01T14:00:53+00:00",
    "input_file": {}
  },
  {
    "path": "post/blogdown으로-블로그-이사하기/",
    "title": "blogdown으로 블로그 이사하기",
    "description": "탈도 많았던 blog의 engine 이전을 완료했습니다. 사용하는 테마가 바뀌긴했지만, 그래도 지금 테마가 어느 정도 만족스러워 결정하게 되었습니다. 원래 `jekyll`로 작성한 블로그에서 `blogdown(Hugo)`으로 변경하였는데요. ...",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2018-03-06",
    "categories": [
      "blog",
      "blogdown",
      "hugo",
      "minimal",
      "rstudio"
    ],
    "contents": "\n\n탈도 많았던 blog의 engine 이전을 완료했습니다. 사용하는 테마가 바뀌긴했지만, 그래도 지금 테마가 어느 정도 만족스러워 결정하게 되었습니다. 원래 jekyll로 작성한 블로그에서 blogdown(Hugo)으로 변경하였는데요. blogdown은 rstudio의 수석 엔지니어인 Yihui Xie가 golang으로 작성된 static site generator 입니다. jekyll 또한 같은 범주의 도구이죠.\n그동안 jekyll을 사용한 이유\njekyll은 간단함, 자유로운 테마 선택, 간단함 때문에 사용했습니다.\njekyll의 간단함\njekyll 블로그는 Github 계정만 있으면 아이디.github.io라는 주소로 쉽게 만들 수 있습니다! jekyll-now를 포크하고, pages 설정만 하면 끝납니다.\njekyll은 지향점이 text를 블로그로 바꿔라! 입니다. 덕분에 매우 쉬운 도구가 되었죠. .md 파일을 블로그 포스트에 해당하는 형태로 운영할 수 있게 해줍니다.\nGithub는 ruby라는 언어로 개발되었다고 합니다. 공교롭게도(!) jekyll도 ruby로 작성되어 있죠. 그래서 Github에서 제공하는 pages라는 서비스에서 jekyll를 빌드없이 바로 사용할 수 있습니다. 물론 .Rmd를 .md로 렌더링하는 과정이 필요하기 때문에 R로 블로깅할 때는 아쉬운 대목입니다.\n자유로운 테마 선택\njekyll은 static site generator로써 가장 유명한 도구 입니다. staticgen을 확인해보면 압도적인 스타수를 확인할 수 있습니다. 다음 인기 있는 도구가 Hugo군요. 최근에는 Gatsby도 인기있다고 들었습니다.\n아무튼… jekyll이 가장 인기있고 역사도 있는 만큼 선택할 수 있는 테마의 범위가 가장 넓습니다. jekyllthemes라는 곳에서 잘 모아져 있는 테마들을 구경할 수 도 있고, 따로 만들어진 테마들을 검색해서 찾을 수도 있습니다. 저는 Lagrange라는 테마를 선택했었습니다. 설명이 매우 잘 되어 있고(물론 영어입니다…), 사진 첨부가 기능으로 들어가 있어서 이름만 정해주면 되었고, 결정적으로 디자인이 너무 마음에 들었습니다.\n\njekyll의 간단함\n특별히 동작과정을 이해하려는 노력을 할 것이 아니라면 공부해야 할 부분은 _config.yml 파일입니다.\n# Site Settings\ntitle:               Mrchypark\ntagline:             log for you & me\ndescription:\nbaseurl:            #\"/Lagrange\"\nurl:                #\"https://lenpaul.github.io\"\ngithub:\n  url:               #\"https://lenpaul.github.io/Lagrange\"\nauthor:\n  name:              \"박찬엽\"\n  email:             \"mrchypark@gmail.com\"\n  twitter:           \"mrchypark_\"\n  instagram:         \"mrchypark\"\n  github:            \"mrchypark\"\n  facebook:          \"mrchypark\"\n  linkedin:          \"chanyub.park\"\nnavigation:\n- title: Materials\n  url: /materials\n- title: Index\n  url: /index\n- title: About\n  url: /about\n\n\npaginate:            5\ndisqus:              \"mrchy****\"\nga:                  \"UA-478*****-**\"\n\n# Build settings\nmarkdown:            kramdown\nhighlighter:         rouge\npermalink:           none\ngems:                [jekyll-paginate]\nencoding:            \"UTF-8\"\n이건 기존의 jekyll로 블로그를 만들 때 사용한 _config.yml 파일입니다. 테마가 친절한 편이여서 여러 SNS에 대한 링크를 아이디만 넣어주면 바로 예쁘게 사용할 수 있게 설정해 줍니다. 댓글을 위한 disqus나 GA 또한 ID만으로 연결을 해줍니다.\njekyll에서 blogdown으로\n당연히도 jekyll은 R파베틱(Rphabetic)하지 않기 때문입니다. 물론 Hugo라고 R파베틱한 것은 아니지만, 패키지화되어 있다는 점이 Rstudio와의 호환성을 많이 올려줍니다.\nblogdown은 staticgen에서 두번째를 차지하고 있는 Hugo를 R 패키지화한 도구입니다. Rstudio의 Addin으로 사이트 구축, 새포스트 쓰기 등의 기능도 지원하고 build_site() 명령어 한방으로 docs 폴더에 블로그 구축을 완전히 끝내줍니다. Hugo가 빠른 블로그라는 점도 한 몫했네요.\nblogdown은 설명서가 친절하다 - blogdown을 만든 사람은 bookdown을 만든 사람이기도 합니다. 덕분에 자세한 메뉴얼이 온라인 책으로 준비되어 있기도 합니다.\nrstudio와 호환이 좋다 - 아무래도 일하는 곳에 도구를 지원하는 방식으로 패키지를 작성한 것 같습니다. Addin 기능 뿐만 아니라 Rstudio를 블로그 글쓰기 에디터로 사용하는데 부족함 없게 지원합니다. 물론 버전이 오르면서 한글 문제(정확하게는 중국어 문제)가 해결된 이유도 있습니다.\n빠르다 - 신기하게 Hugo로 넘어간 많은 분들이 jekyll가 느려지는 문제를 지적하였습니다. 제 블로그가 글이 많지는 않지만 미래를 대비하고자 하는 마음도 있었습니다.\n다시 도구 이전 신고\n네, 블로그를 blogdown으로 이전하였습니다. 추후 시간이 되면 blogdown으로 블로그를 만드는 법에 대해서 포스팅하도록 하겠습니다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106467983-b52cdc00-64e0-11eb-9f46-1f97f8abf56b.png",
    "last_modified": "2021-02-01T14:00:53+00:00",
    "input_file": {}
  },
  {
    "path": "post/구글-광고-추가/",
    "title": "구글 광고 추가",
    "description": "블로그 하단에 구글 광고를 추가하였습니다. 처음 붙여보는 것이라 하단 이외에 다른 곳에서도 광고가 나올 수 있습니다.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2018-03-06",
    "categories": [
      "anounce",
      "ad"
    ],
    "contents": "\n\n블로그 하단에 구글 광고를 추가하였습니다. 처음 붙여보는 것이라 하단 이외에 다른 곳에서도 광고가 나올 수 있습니다. 읽어보시는 글이 도움이 되셨다면 클릭 한 번 부탁드리겠습니다. 저는 여러 정보성 글로 먹고 사는 일을 하고 싶습니다. 후원, 유료 컨텐츠등 다양한 방향으로도 시도할 계획이니 많은 관심 부탁드립니다.\n감사합니다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106467282-c32e2d00-64df-11eb-9435-7ed1cc5bf3e0.png",
    "last_modified": "2021-02-01T14:00:53+00:00",
    "input_file": {}
  },
  {
    "path": "post/materials-페이지-업데이트/",
    "title": "Materials 페이지 업데이트",
    "description": "제 블로그 왼쪽 위에 Materials라는 메뉴를 추가하였습니다.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2017-11-22",
    "categories": [
      "news",
      "blog",
      "materials"
    ],
    "contents": "\n\n제 블로그 왼쪽 위에 Materials라는 메뉴가 있습니다. 작성하는 자료들을 모아 놓는 공간으로 따로 분류해 두었었는데, 그동안 만든 자료들이 좀 있어서 내용을 업데이트했습니다.\n짧게 소개하면 제가 패스트 캠퍼스에서 진행했던 강의 자료와 R로 api 서버 만들기, 크롤링 하기, github 함께 사용하기 같은 발표자료를 링크해 두었습니다.\n혹시 살펴보시다가 이야기해주실 부분에 대해서는 언제든지 어떤 체널로든 피드백 부탁드립니다.\n감사합니다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106466661-f9b77800-64de-11eb-807d-fcedbfbc1df0.png",
    "last_modified": "2021-02-01T14:00:53+00:00",
    "input_file": {}
  },
  {
    "path": "post/한글-띄어쓰기-api-이용하기/",
    "title": "한글 띄어쓰기 API 이용하기",
    "description": "현재 아래 소개하는 api는 동작하지 않으며 KoSpacing패키지가 새롭게 배포되었습니다.\n패키지 사용 환경 설정은 본 블로그의 다른 포스트를 참고하세요.\nKoNLP 패키지를 만드신 고감자님께서 KoNLP에 한글 자동 띄어쓰기 기능을 추가하시기 위해서 관련 연구를 수행하시고 우선 결과물로 웹 요청으로 결과를 제공하는 API를 우선 공개하셨습니다....",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2017-10-09",
    "categories": [
      "R",
      "httr",
      "api",
      "server",
      "POST",
      "GET"
    ],
    "contents": "\n\nContents\n업데이트\n띄어쓰기 api 요청하기\nhttp 란\nR로 http 요청하기\n\n\n\n업데이트\n현재 아래 소개하는 api는 동작하지 않으며 KoSpacing 패키지가 새롭게 배포되었습니다.\n패키지 사용 환경 설정은 본 블로그의 다른 포스트를 참고하세요.\nKoNLP 패키지를 만드신 고감자님께서 KoNLP에 한글 자동 띄어쓰기 기능을 추가하시기 위해서 관련 연구를 수행하시고 우선 결과물로 웹 요청으로 결과를 제공하는 API를 우선 공개하셨습니다.(관련글) 사용법도 함께 공개하셨는데, R에서는 사용이 어색할 수 있는 reticulate 패키지로 예시를 작성해주셔서 R에서 많이 사용하는 패키지들로 예시코드를 공유하면서 웹 요청에 대한 내용도 함께 공유해볼까 합니다.\n띄어쓰기 api 요청하기\n먼저 공유해주신 코드를 살펴보겠습니다.\nlibrary(reticulate)\n\nrequests <- import('requests')\n\nspaced_sent <- requests$put('http://35.201.156.140:8080/spacing', \n      data=list(sent=\"아래와같은방식으로API를사용할수있으며,호출건수에대해서별도의제한은없으나,1회 호출에200글자로글자수를제한하고있다.\"))$json() \n\nprint(spaced_sent$sent)\nreticulate는 파이썬 코드를 R에서 사용할 있게 interface 해주는 패키지로 위 코드를 실행하기 위해서는 reticulate 패키지, 파이썬, 파이썬의 requests 패키지가 필요합니다. 그럼 R에서 웹 요청을 보내기 좋은 httr 패키지로 코드를 바꿔보겠습니다.\nif (!requireNamespace(\"httr\")) install.packages(\"httr\")\nlibrary(httr)\n\nbody<-list(sent=\"아래와같은방식으로API를사용할수있으며,호출건수에대해서별도의제한은없으나,1회 호출에200글자로글자수를제한하고있다.\")\nres<-PUT(url='http://35.201.156.140:8080/spacing', body=body)\n\ncontent(res)$sent\n## [1] \"아래와 같은 방식으로 API를 사용할 수 있으며, 호출 건수에 대해서 별도의 제한은 없으나, 1회 호출에 200글자로 글자수를 제한하고 있다. \"\n관련 기능을 만드실 때 고감자님에게 도움을 드린 것이 있는데 직접 언급해주셨습니다. 다시 한번 감사드립니다. 아래로는 http란, R에서 간단한 크롤링이나 api를 사용하기 위한 패키지 소개 및 간단한 사용 예시가 작성되어 있습니다.\nhttp 란\nhttp란 보통 1999년에 발표된 http/1.1 버전을 뜻합니다. 해당 링크에서 보면 프로토콜이란 하나의 약속입니다. 브라우저와 서버가 서로 데이터를 주고 받기 위해서 만든 규칙이라고 이해하시면 좋습니다. 그렇다면 웹의 정보를 R에서 가져오기 위해서는 서버에게 브라우저가 요청하는 약속을 그대로 따라하면 좋을 것 같습니다.\nR로 http 요청하기\nhttp로 요청하는 다양한 방법이 있지만, 간단하게는 GET과 POST만 이해하시면 됩니다. 서버에게 요청하는 것은 request, 응답을 받는 것은 response라고 하겠습니다.__(그놈의 영어)__ 우선 GET부터 보겠습니다.\nGET 요청\nGET은 서버의 주소만으로 서버에 데이터를 요청하는 방법입니다. 대부분의 브라우저에 주소를 입력하고 엔터를 누르는 것과 같습니다. GET이라는 것을 메소드라고 부릅니다. R에서는 http 요청을 하기 위한 다양항 패키지가 있지만 메소드 이름을 바로 함수로 제공하는 httr 패키지를 사용하겠습니다.\n\n\nShow code\n\nif (!requireNamespace(\"httr\")) install.packages(\"httr\")\nlibrary(httr)\nres<-GET(\"https://mrchypark.github.io/\")\ncontent(res)\n\n\n{html_document}\n<html xmlns=\"http://www.w3.org/1999/xhtml\" lang=\"\" xml:lang=\"\">\n[1] <head>\\n<meta http-equiv=\"Content-Type\" content=\"text/html; cha ...\n[2] <body class=\"layout-listing\">\\n\\n<!--radix_placeholder_front_ma ...\n\n위의 결과에서 <html>이라고 나온 것을 볼 수 있습니다. html는 css, javascrit와 함께 브라우저가 사람들이 볼 수 있는 그림을 그리도록 만들어진 규칙입니다. GET 요청은 대부분 서버에서 이런 html 문서를 데이터로 받기 위해서 브라우저에서 동작하는 방식입니다. 알고 계신 다른 사이트들을 시도해보시면 더 이해가 좋을 것 같습니다. 이 html 문서에서 필요한 곳의 내용만 추출하는 패키지로 rvest 패키지가 있습니다. rvest 패키지 사용법은 많은 분들이 소개해주셔서 검색해 보시길 추천드립니다.\nPOST 요청\nPOST는 서버에 데이터를 요청할 때 뭔가 값을 함께 요청하는 방식입니다. 대표적으로 로그인이 있습니다. 위 고감자님의 요청은 PUT을 사용했는데, POST와 거의 같습니다. POST를 값을 실어보내는 것을 body라고 합니다. body는 R에서는 list 자료형으로 처리합니다.\n\n\nShow code\n\nbody<-list(sent=\"아래와같은방식으로API를사용할수있으며,호출건수에대해서별도의제한은없으나,1회 호출에200글자로글자수를제한하고있다.\")\nbody\n\n\n$sent\n[1] \"아래와같은방식으로API를사용할수있으며,호출건수에대해서별도의제한은없으나,1회 호출에200글자로글자수를제한하고있다.\"\n\n위 띄어쓰기 API 요청을 보면 body를 선언하는 부분이 list로 되어 있고, 데이터는 띄어쓰기가 필요한 문장, 그 이름을 sent로 하였습니다. 이건 서버에 sent라는 이름으로 띄어쓰기가 필요한 문장을 함께 전달하기 위해서 선언한 겁니다.\nPUT은 POST와 거의 같다고 했습니다. 여기서는 예시를 PUT으로 하겠습니다.\nres<-PUT(url='http://35.201.156.140:8080/spacing', body=body, verbose())\n위는 PUT요청을 했을 때 일어나는 일들 전체를 보여줍니다. httr 패키지가 다 알아서 해주니 우리는 이제 아래처럼 요청하면 됩니다.\nres<-PUT(url='http://35.201.156.140:8080/spacing', body=body)\nres는 PUT 요청으로 서버에게 요청을 했을 때 서버가 우리에게 돌려준 결과를 저장하였습니다. 위에서 말한 response입니다.\nres\n## Response [http://35.201.156.140:8080/spacing]\n##   Date: 2018-03-05 07:15\n##   Status: 200\n##   Content-Type: application/json\n##   Size: 348 B\n## {\"sent\": \"\\uc544\\ub798\\uc640 \\uac19\\uc740 \\ubc29\\uc2dd\\uc73c\\ub85c API\\u...\n실제로 값에 response라고 하면서 여러 정보를 보여주고 있습니다. 어느 서버 주소에서 받은 것인지, 언제 받았는지, 상태는 얼마인지 받은 데이터가 어떤 것인지, 받은 데이터의 크기가 얼마나 되는지 같은 것들이네요. 하나하나 따져 보시려면 str(res)를 수행해보시면 좋을 것 같습니다. http가 response를 어떻게 정의해 놨는지 알 수 있습니다.\n이 중에서 우리가 궁금한 것은 content입니다. httr 패키지는 response 객체에서 content만 보는 기능을 content() 함수로 제공하고 있습니다. content()함수는 몇몇 유명한 형식에 대해서 자동으로 가져오는 기능을 제공합니다.\ncontent(res)\n## $sent\n## [1] \"아래와 같은 방식으로 API를 사용할 수 있으며, 호출 건수에 대해서 별도의 제한은 없으나, 1회 호출에 200글자로 글자수를 제한하고 있다. \"\ncontent에 json 방식으로 준 모양입니다. R은 json 방식의 데이터를 list 자료형으로 해석합니다. json의 설명을 확인해 보세요. list 이름이 sent인걸 보니 마지막 단계만이 남았습니다.\ncontent(res)$sent\n## [1] \"아래와 같은 방식으로 API를 사용할 수 있으며, 호출 건수에 대해서 별도의 제한은 없으나, 1회 호출에 200글자로 글자수를 제한하고 있다. \"\nresData<-content(res)\nresData$sent\n## [1] \"아래와 같은 방식으로 API를 사용할 수 있으며, 호출 건수에 대해서 별도의 제한은 없으나, 1회 호출에 200글자로 글자수를 제한하고 있다. \"\nOpen API 라고 되어 있는 서비스들이 위와 같은 방식을 사용하고 있습니다. 보통은 sent라고 되어 있는 부분(요청시 body로 선언할 내용과 방법)을 서비스 제공자 쪽에서 설명해줘야 합니다. 다른 API 서비스를 사용하실 때 오늘의 내용이 도움이 되었으면 합니다.\n끝까지 읽어주셔서 감사합니다. 질문, 지적 대환영이며 댓글로 부탁드립니다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106461744-8c084d80-64d8-11eb-93a4-ebedf3fb21c7.png",
    "last_modified": "2021-02-01T14:00:53+00:00",
    "input_file": {}
  },
  {
    "path": "post/논리-연산자-정리/",
    "title": "논리 연산자 정리",
    "description": "드디어 블로그를 단순하게 유지하기 위해 distill로 옮깁니다.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2017-07-31",
    "categories": [
      "operator",
      "logical",
      "Boolean",
      "R",
      "rlang"
    ],
    "contents": "\n\nContents\n논리 연산자란\n논리 연산자\n논리 연산자 왼쪽의 데이터가 1개 일때\n논리 연산자 왼쪽의 데이터가 여러개 일때\n논리 연산자 데이터가 모두 여러개 일때\n\n\n드디어 블로그에서 Rmd를 사용할 수 있게 되어서 매우 기쁜 마음에 포스팅을 하나 기획하였습니다. 그것은 바로 논리 연산자! 기본적은 것은 다 쉬운데 데이터가 여러 개인 벡터(vector)일 때 동작에 대해서 많이 고민하지 않는 것 같아 이렇게 첫 번째 주제로 잡았습니다.\n논리 연산자란\n논리 연산자(Logical Operators)란 논리 자료형(logical로 표시하며 T/F를 의미)를 사칙 연산처럼 TRUE / FALSE 를 계산하여 하나의 결과를 만드는 것이라고 할 수 있습니다. 대표적으로 if 구문에 해당하는 조건문에서 사용하는데요, 코드를 짤 때 조건문을 피할 수 없기 때문에 동작에 대해 잘 이해하고 있는 것이 좋습니다.\nR에서 사용하는 논리 연산은 아래와 같습니다.\n논리 연산자\na, b: 숫자 데이터 1개\nx, y: 논리 데이터 1개\n\n\n연산자\n\n\n설명\n\n\na < b\n\n\na가 b보다 작다\n\n\na <= b\n\n\na가 b보다 작거나 같다\n\n\na > b\n\n\na가 b보다 크다\n\n\na >= b\n\n\na가 b보다 크거나 같다\n\n\na == b\n\n\na와 b가 같다\n\n\na !=\n\n\na와 b가 같지 않다\n\n\n!x\n\n\nx가 아니다\n\n\nx | y\n\n\nx이거나 y이다\n\n\nx & y\n\n\nx이고 y이다\n\n\nisTRUE(x)\n\n\nx가 TRUE이다\n\n\n더하기, 빼기 같은 산술 연산자도 있으니 R에서 사용하는 연산자 소개는 이곳을 참고하면 좋을 것 같습니다. 위에서 강조한 바와 같이 위에 논리 연산자는 모두 데이터가 1개 일때를 의미합니다. 정확하게는 연산자의 왼쪽인 a는 여러 데이터인 벡터(vector)여도 되는데, 연산자의 오른쪽인 b는 한 개 여야만 합니다. 아니, 여러 개일 때 어떻게 동작하는지 알고 있어야 합니다.\n우선 a가 1개일 때와 여러 개일 때를 확인해 보겠습니다.\n논리 연산자 왼쪽의 데이터가 1개 일때\n데이터가 1개인 경우는 매우 간단하고, 모두 상상하는 처음 예시이기도 합니다.\n\n\na <- 10\nb <- 30\n\na < b\n\n\n[1] TRUE\n\na <= b\n\n\n[1] TRUE\n\na > b\n\n\n[1] FALSE\n\na >= b\n\n\n[1] FALSE\n\na == b\n\n\n[1] FALSE\n\na != b\n\n\n[1] TRUE\n\n위에는 모두 상상하시는 대로 결과가 나왔으리라 생각합니다. 맨 아래만 짚어보면 =는 <-와 같은 뜻이어서, 수학적인 등호의 역할을 하길 기대해야 하는 기호는 ==입니다. ==는 왼쪽과 오른쪽이 같다라는 뜻입니다. 그리고 맨 위에 !x에 x가 아니다라는 설명을 해두었습니다. x는 논리 데이터 1개라는 설명도 했죠. 그러다 보니 !=는 !(a == b)와 의미가 같습니다. 작성하기 편하게 하기위해서 약어처럼 정의를 해둔 것이지요. 보통은 논리 자료형 앞에 붙어서 원래 결과의 부정을 뜻합니다. |나 &는 잘 아시리라 생각하고, isTRUE()를 좀 확인해 보겠습니다.\nisTRUE()\nR에서 몇 가지 요령이 있는데, ?함수이름, help(함수이름)이라고 하면 설명이 나오고, ()를 붙이지 않고 함수이름만 콘솔에 입력하면 그 함수를 구성하는 코드가 출력됩니다.\n\n\nisTRUE\n\n\nfunction (x) \nis.logical(x) && length(x) == 1L && !is.na(x) && x\n<bytecode: 0x558ded2612f0>\n<environment: namespace:base>\n\nisTRUE()가 어떻게 동작하는 함수인지 궁금해서 코드를 확인해 봤습니다. 여러개가 있지만 눈에 들어오는 것은 identical(TRUE, x)네요. 입력인자인 x가 TRUE와 같은 것인지를 확인하는 것입니다. identical()은 정확하게 같은지를 결과로 줍니다. 예를 들면 같은 숫자인데 자료형이 다르던가, R은 NA를 계산할 수 없음으로 취급해서 ==으로 확인하면 NA로 결과를 줍니다. 그래서 rstudio를 사용하시면 == NA를 인식해서 is.ns()를 사용하라고 경고를 주기도 합니다. 아래 코드를 봐주세요.\n\n\n2L == 2\n\n\n[1] TRUE\n\nidentical(2L,2)\n\n\n[1] FALSE\n\n10 == NA\n\n\n[1] NA\n\n10 != NA\n\n\n[1] NA\n\n10 > NA\n\n\n[1] NA\n\nidentical(10,NA)\n\n\n[1] FALSE\n\n그래서 isTRUE(x)는 x가 TRUE와 완전히 같은지를 확인해서 같으면 TRUE, 다르면 FALSE를 결과로 주는 함수입니다. 조건문 안에 identical()은 익숙해지면 자주 사용하는 함수이니 확인해주세요.\n논리 연산자 왼쪽의 데이터가 여러개 일때\n데이터가 여러개라는 것은 벡터(vector)로 구성한다는 뜻입니다. 우선 결과를 확인해 보겠습니다. 일반적으로 벡터를 만들 때는 c()를 사용합니다. ?c로 설명서를 확인해 보세요.\n\n\na <- c(10,20,30,40,50)\nb <- 30\n\na <  b\n\n\n[1]  TRUE  TRUE FALSE FALSE FALSE\n\na <= b\n\n\n[1]  TRUE  TRUE  TRUE FALSE FALSE\n\na > b\n\n\n[1] FALSE FALSE FALSE  TRUE  TRUE\n\na >= b\n\n\n[1] FALSE FALSE  TRUE  TRUE  TRUE\n\na == b\n\n\n[1] FALSE FALSE  TRUE FALSE FALSE\n\na != b\n\n\n[1]  TRUE  TRUE FALSE  TRUE  TRUE\n\n결과를 확인해 보면 모두 a 데이터의 개수인 5개 만큼 결과 또한 출력된 것을 확인할 수 있습니다. 이것은 산술 연산자에서도 확인할 수 있는 동작인데요.\n\n\na <- c(10,20,30,40,50)\nb <- 30\n\na + b\n\n\n[1] 40 50 60 70 80\n\na - b\n\n\n[1] -20 -10   0  10  20\n\na * b\n\n\n[1]  300  600  900 1200 1500\n\na / b\n\n\n[1] 0.3333333 0.6666667 1.0000000 1.3333333 1.6666667\n\na ** b\n\n\n[1] 1.000000e+30 1.073742e+39 2.058911e+44 1.152922e+48 9.313226e+50\n\na %% b\n\n\n[1] 10 20  0 10 20\n\na %/% b\n\n\n[1] 0 0 1 1 1\n\n이렇게 연산자의 왼쪽이 여러개의 데이터인 벡터이고, 오른쪽이 데이터 1개 일때(데이터가 1개 일때도 벡터라고 합니다.) 연산자는 왼쪽 데이터를 기준으로 각각 연산을 수행해서 왼쪽 데이터의 개수만큼 결과를 보여줍니다. 그렇다면, 논리 연산자 오른쪽의 데이터가 여러개면 어떻게 될까요? 예상되실 겁니다.\n\n\na <- 30\nb <- c(10,20,30,40,50)\n\na <  b\n\n\n[1] FALSE FALSE FALSE  TRUE  TRUE\n\na <= b\n\n\n[1] FALSE FALSE  TRUE  TRUE  TRUE\n\na > b\n\n\n[1]  TRUE  TRUE FALSE FALSE FALSE\n\na >= b\n\n\n[1]  TRUE  TRUE  TRUE FALSE FALSE\n\na == b\n\n\n[1] FALSE FALSE  TRUE FALSE FALSE\n\na != b\n\n\n[1]  TRUE  TRUE FALSE  TRUE  TRUE\n\n논리 연산자 데이터가 모두 여러개 일때\n그럼 이제 마지막 경우를 남겨두고 있습니다. 양쪽 다 여러개의 데이터인 경우인데요, 이 경우에서도 데이터의 개수가 같은 경우와 다른 경우로 달라집니다.\n데이터의 개수가 같은 경우\n먼저 결과부터 보시죠\n\n\na <- c(10,20,30,40,50)\nb <- c(1,2,3,4,5)\n\na <  b\n\n\n[1] FALSE FALSE FALSE FALSE FALSE\n\na <= b\n\n\n[1] FALSE FALSE FALSE FALSE FALSE\n\na > b\n\n\n[1] TRUE TRUE TRUE TRUE TRUE\n\na >= b\n\n\n[1] TRUE TRUE TRUE TRUE TRUE\n\na == b\n\n\n[1] FALSE FALSE FALSE FALSE FALSE\n\na != b\n\n\n[1] TRUE TRUE TRUE TRUE TRUE\n\n개수가 같으니 결과도 같은 개수만큼 나왔고, 그 의미는 각각의 위치에 것들이 각각 연산되었다는 뜻입니다. |나 &도 같이 동작하는지 보시죠\n\n\nx <- c(T,T,T)\ny <- c(T,F,F)\n\nx & y\n\n\n[1]  TRUE FALSE FALSE\n\nx | y\n\n\n[1] TRUE TRUE TRUE\n\n|나 &도 똑같이 결과가 데이터의 갯수와 같이 3개로 나오는 것을 볼 수 있습니다. 그런데, 논리 자료형의 연산 결과가 여러 개인 경우는 사실 조건문을 사용하는데 좋은 결과가 아닙니다. 그래서 논리 자료형의 연산 결과를 1개로 정리하는 방법들이 있습니다.\n\n\nx <- c(T,T,T)\ny <- c(T,F,F)\n\nany(y)\n\n\n[1] TRUE\n\nall(y)\n\n\n[1] FALSE\n\nx && y\n\n\n[1] TRUE\n\nx || y\n\n\n[1] TRUE\n\n첫번째 방법은 any(), all()함수를 사용하는 방법입니다. 두 함수 모두 인자로 논리 자료형의 벡터를 사용하는데요, any()는 뭐라도 하나 TRUE라면 TRUE를 결과로 줍니다. any라는 이름에 걸맞죠. all()은 전부 TRUE여야 TRUE를 줍니다. 역시 all이라는 이름에 걸맞습니다. 여러개의 논리 데이터를 하나의 결과로 정리한다는 점에서 조건문에 사용하기 좋습니다.\n그 아래 ||와 &&도 결과를 한개만 준다는 점에서는 같습니다만 연산 방식이 다릅니다. 이 두 연산자는 양쪽에 데이터가 여러개가 온다고 하더라도 첫번째 데이터만 사용합니다. 조건문의 ()에 논리 데이터가 여러개이면 경고를 주고 첫번째 데이터만 사용한다고 합니다. ||와 &&은 의도적으로 모두 첫번째 데이터만 연산에 사용한다는 것을 명시적으로 표현하는 것입니다. 한번 확인해 보겠습니다.\n\n\nx <- c(T,T,T)\ny <- c(T,F,F)\nx && y\n\n\n[1] TRUE\n\nx || y\n\n\n[1] TRUE\n\nx <- c(F,T,T)\ny <- c(T,F,F)\nx && y\n\n\n[1] FALSE\n\nx || y\n\n\n[1] TRUE\n\nx <- c(T,T,T)\ny <- c(F,F,F)\nx && y\n\n\n[1] FALSE\n\nx || y\n\n\n[1] TRUE\n\nx <- c(F,T,T)\ny <- c(F,F,F)\nx && y\n\n\n[1] FALSE\n\nx || y\n\n\n[1] FALSE\n\n지금은 앞에만 달리하며 출력했는데, 뒤에 데이터를 변경해서 결과가 달라지지 않는 것을 직접 확인해 보시면 좋을 것 같습니다. 더 자세한 정보는 ?\"|\"로 확인하실 수 있습니다. 한 문장만 가져와서 보여드리면\n\nThe longer form evaluates left to right examining only the first element of each vector.\n\n여기서 longer form이 ||나 &&를 뜻합니다.\n데이터의 개수가 다른 경우\n데이터의 개수가 다른 경우는 또 두 가지 경우로 나뉩니다. 두 데이터의 개수가 배수 관계에 있는 경우와 아닌 경우입니다. 배수인 경우 먼저 보시죠\n데이터의 개수가 배수 관계인 경우\n\n\na <- c(10,20,30,40,50,60)\nb <- c(10,20,30)\n\na <  b\n\n\n[1] FALSE FALSE FALSE FALSE FALSE FALSE\n\na <= b\n\n\n[1]  TRUE  TRUE  TRUE FALSE FALSE FALSE\n\na > b\n\n\n[1] FALSE FALSE FALSE  TRUE  TRUE  TRUE\n\na >= b\n\n\n[1] TRUE TRUE TRUE TRUE TRUE TRUE\n\na == b\n\n\n[1]  TRUE  TRUE  TRUE FALSE FALSE FALSE\n\na != b\n\n\n[1] FALSE FALSE FALSE  TRUE  TRUE  TRUE\n\n우선 결과가 경고 없이 잘 나왔고, 총 6개입니다. 이때는 개수가 부족한 쪽이 개수가 많은 쪽 만큼 한번 더 돌아서(Recycle) 연산에 사용된 것을 알 수 있습니다. 이것을 Recycling Rule이라고 합니다. 배수관계에 있다보니 특별히 잘못했다고 경고를 주지도 않습니다. 그럼 배수 관계가 아닐 떈 어떻게 될까요?\n데이터의 개수가 배수 관계가 아닌 경우\n\n\na <- c(10,20,30,40,50)\nb <- c(10,20,30)\n\na <  b\n\n\n[1] FALSE FALSE FALSE FALSE FALSE\n\na <= b\n\n\n[1]  TRUE  TRUE  TRUE FALSE FALSE\n\na > b\n\n\n[1] FALSE FALSE FALSE  TRUE  TRUE\n\na >= b\n\n\n[1] TRUE TRUE TRUE TRUE TRUE\n\na == b\n\n\n[1]  TRUE  TRUE  TRUE FALSE FALSE\n\na != b\n\n\n[1] FALSE FALSE FALSE  TRUE  TRUE\n\n똑같이 Recycling Rule이 적용되어 적은 쪽이 많은 쪽 개수 만큼 한번 더 돌아서 사용하여 연산하지만, 쓰다 말기 때문에 경고를 줍니다. 배수관계가 아닌데 너가 지금 잘 사용한 게 맞는거냐라고 물어보는 거죠. 맞다면 무시하시면 됩니다. 결과도 긴 데이터쪽 개수만큼인 5개로 나왔네요. 의도하신거라면 이대로 진행하시면 됩니다.\n이렇게 논리 연산자도 데이터가 여러개일 때 산술 연산자와 같은 동작을 취합니다. 이 부분이 아마 기초를 배운 후에 조합해서 확인해 봐야 하는 부분인 것 같습니다. 그리고 많이 실수하시는 부분이 있습니다. 논리 자료형이라면 특별히 문제되지 않는데, ==의 동작을 오해하세요. 사실 이걸 이야기하고 싶어서 위에 저 많은 얘기를 했는데요. 이미 주제 하나 정도 되는 것 같아 포스트를 나누겠습니다.\n다음 포스트는 왜 %in% 연산자를 사용하는가? feat.== 입니다.\n끝까지 읽어주셔서 감사합니다. 질문, 지적 대환영이며 댓글로 부탁드립니다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106395892-0e94fc80-6448-11eb-9836-f3f8449a472b.png",
    "last_modified": "2021-02-01T14:00:53+00:00",
    "input_file": {}
  },
  {
    "path": "post/블로그-reboot/",
    "title": "블로그 reboot",
    "description": "blogdown으로 옮겨서 시작합니다.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2017-04-05",
    "categories": [
      "anounce",
      "blog",
      "reboot"
    ],
    "contents": "\n\n블로그를 찾아주신 모든 분들 반갑습니다! 안녕하세요 박찬엽입니다. 여러 블로그 도구들과 씨름하다 정착하고 싶어 어느 정도 정리했습니다. 가능하면 한 번에 처리할 방법들을 고민하고 사용해보고 하는 기간이 길었던 것 같습니다. reboot라고 제목을 지은 이유는 이런 저런 실험을 하고 OS에 환경을 세팅하고 난 후에는 reboot을 하기 때문입니다. 이제 다시 reboot할 일 없는 열일하는 서버처럼 잘 운영해 보겠습니다.\n감사합니다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106381525-aff66100-63fc-11eb-878f-724b1f26b387.png",
    "last_modified": "2021-02-01T14:00:53+00:00",
    "input_file": {}
  }
]
