[
  {
    "path": "post/distill로-옮깁니다/",
    "title": "distil로 옮깁니다",
    "description": "드디어 블로그를 단순하게 유지하기 위해 distill로 옮깁니다.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2021-01-28",
    "categories": [],
    "contents": "\n\nContents\nblogdown의 대안을 찾아서\ndistill 소개\n\nblogdown의 대안을 찾아서\nblogdown은 꽤 오랫동안 사용한 블로그 패키지다. 여전히 좋은 패키지라고 생각한다. blogdown 또한 rstudio에서 관리하며, 최근 버전 1.0.0 을 출시했다.\n대안이 필요한 이유는 blogdown 자체의 문제만은 아니지만, 여전히 문제다.\n한글 윈도우 rstudio 에서 빌드시 경로 문제가 발생할 때가 있다.\n캐쉬 동작을 이해하지 못해서 빌드 결과가 다르다.\nrstudio가 글 작성 도구로써 매우 좋다고 할 수 없다.\nrstudio가 글 작성 도구로써 매우 좋다고 할 수 없는 이유는, 우선 매우 무겁기 때문이다. 오죽하면 Rmd 전용 글 작성 도구만 따로 만들까 고민하던 적이 있기도 하다.(지금도 유효하다.)\ndistill 소개\ndistill 은 rstudio 의 패키지로\n\n\nShow code\n\nlibrary(\"dplyr\")\n\nmtcars %>% \n  tibble() %>% \n  filter(mpg >20)\n\n\n# A tibble: 14 x 11\n     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb\n   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n 1  21       6 160     110  3.9   2.62  16.5     0     1     4     4\n 2  21       6 160     110  3.9   2.88  17.0     0     1     4     4\n 3  22.8     4 108      93  3.85  2.32  18.6     1     1     4     1\n 4  21.4     6 258     110  3.08  3.22  19.4     1     0     3     1\n 5  24.4     4 147.     62  3.69  3.19  20       1     0     4     2\n 6  22.8     4 141.     95  3.92  3.15  22.9     1     0     4     2\n 7  32.4     4  78.7    66  4.08  2.2   19.5     1     1     4     1\n 8  30.4     4  75.7    52  4.93  1.62  18.5     1     1     4     2\n 9  33.9     4  71.1    65  4.22  1.84  19.9     1     1     4     1\n10  21.5     4 120.     97  3.7   2.46  20.0     1     0     3     1\n11  27.3     4  79      66  4.08  1.94  18.9     1     1     4     1\n12  26       4 120.     91  4.43  2.14  16.7     0     1     5     2\n13  30.4     4  95.1   113  3.77  1.51  16.9     1     1     5     2\n14  21.4     4 121     109  4.11  2.78  18.6     1     1     4     2\n\nShow code\n\nprint(\"heloe\")\n\n\n[1] \"heloe\"\n\n\n\n\n",
    "preview": {},
    "last_modified": "2021-02-01T13:47:52+00:00",
    "input_file": {}
  },
  {
    "path": "post/materials-페이지-업데이트/",
    "title": "Materials 페이지 업데이트",
    "description": "제 블로그 왼쪽 위에 Materials라는 메뉴를 추가하였습니다.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2017-11-22",
    "categories": [
      "news",
      "blog",
      "materials"
    ],
    "contents": "\n\n제 블로그 왼쪽 위에 Materials라는 메뉴가 있습니다. 작성하는 자료들을 모아 놓는 공간으로 따로 분류해 두었었는데, 그동안 만든 자료들이 좀 있어서 내용을 업데이트했습니다.\n짧게 소개하면 제가 패스트 캠퍼스에서 진행했던 강의 자료와 R로 api 서버 만들기, 크롤링 하기, github 함께 사용하기 같은 발표자료를 링크해 두었습니다.\n혹시 살펴보시다가 이야기해주실 부분에 대해서는 언제든지 어떤 체널로든 피드백 부탁드립니다.\n감사합니다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106466661-f9b77800-64de-11eb-807d-fcedbfbc1df0.png",
    "last_modified": "2021-02-01T13:47:52+00:00",
    "input_file": {}
  },
  {
    "path": "post/한글-띄어쓰기-api-이용하기/",
    "title": "한글 띄어쓰기 API 이용하기",
    "description": "현재 아래 소개하는 api는 동작하지 않으며 KoSpacing패키지가 새롭게 배포되었습니다.\n패키지 사용 환경 설정은 본 블로그의 다른 포스트를 참고하세요.\nKoNLP 패키지를 만드신 고감자님께서 KoNLP에 한글 자동 띄어쓰기 기능을 추가하시기 위해서 관련 연구를 수행하시고 우선 결과물로 웹 요청으로 결과를 제공하는 API를 우선 공개하셨습니다....",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2017-10-09",
    "categories": [
      "R",
      "httr",
      "api",
      "server",
      "POST",
      "GET"
    ],
    "contents": "\n\nContents\n업데이트\n띄어쓰기 api 요청하기\nhttp 란\nR로 http 요청하기\n\n\n\n업데이트\n현재 아래 소개하는 api는 동작하지 않으며 KoSpacing 패키지가 새롭게 배포되었습니다.\n패키지 사용 환경 설정은 본 블로그의 다른 포스트를 참고하세요.\nKoNLP 패키지를 만드신 고감자님께서 KoNLP에 한글 자동 띄어쓰기 기능을 추가하시기 위해서 관련 연구를 수행하시고 우선 결과물로 웹 요청으로 결과를 제공하는 API를 우선 공개하셨습니다.(관련글) 사용법도 함께 공개하셨는데, R에서는 사용이 어색할 수 있는 reticulate 패키지로 예시를 작성해주셔서 R에서 많이 사용하는 패키지들로 예시코드를 공유하면서 웹 요청에 대한 내용도 함께 공유해볼까 합니다.\n띄어쓰기 api 요청하기\n먼저 공유해주신 코드를 살펴보겠습니다.\nlibrary(reticulate)\n\nrequests <- import('requests')\n\nspaced_sent <- requests$put('http://35.201.156.140:8080/spacing', \n      data=list(sent=\"아래와같은방식으로API를사용할수있으며,호출건수에대해서별도의제한은없으나,1회 호출에200글자로글자수를제한하고있다.\"))$json() \n\nprint(spaced_sent$sent)\nreticulate는 파이썬 코드를 R에서 사용할 있게 interface 해주는 패키지로 위 코드를 실행하기 위해서는 reticulate 패키지, 파이썬, 파이썬의 requests 패키지가 필요합니다. 그럼 R에서 웹 요청을 보내기 좋은 httr 패키지로 코드를 바꿔보겠습니다.\nif (!requireNamespace(\"httr\")) install.packages(\"httr\")\nlibrary(httr)\n\nbody<-list(sent=\"아래와같은방식으로API를사용할수있으며,호출건수에대해서별도의제한은없으나,1회 호출에200글자로글자수를제한하고있다.\")\nres<-PUT(url='http://35.201.156.140:8080/spacing', body=body)\n\ncontent(res)$sent\n## [1] \"아래와 같은 방식으로 API를 사용할 수 있으며, 호출 건수에 대해서 별도의 제한은 없으나, 1회 호출에 200글자로 글자수를 제한하고 있다. \"\n관련 기능을 만드실 때 고감자님에게 도움을 드린 것이 있는데 직접 언급해주셨습니다. 다시 한번 감사드립니다. 아래로는 http란, R에서 간단한 크롤링이나 api를 사용하기 위한 패키지 소개 및 간단한 사용 예시가 작성되어 있습니다.\nhttp 란\nhttp란 보통 1999년에 발표된 http/1.1 버전을 뜻합니다. 해당 링크에서 보면 프로토콜이란 하나의 약속입니다. 브라우저와 서버가 서로 데이터를 주고 받기 위해서 만든 규칙이라고 이해하시면 좋습니다. 그렇다면 웹의 정보를 R에서 가져오기 위해서는 서버에게 브라우저가 요청하는 약속을 그대로 따라하면 좋을 것 같습니다.\nR로 http 요청하기\nhttp로 요청하는 다양한 방법이 있지만, 간단하게는 GET과 POST만 이해하시면 됩니다. 서버에게 요청하는 것은 request, 응답을 받는 것은 response라고 하겠습니다.__(그놈의 영어)__ 우선 GET부터 보겠습니다.\nGET 요청\nGET은 서버의 주소만으로 서버에 데이터를 요청하는 방법입니다. 대부분의 브라우저에 주소를 입력하고 엔터를 누르는 것과 같습니다. GET이라는 것을 메소드라고 부릅니다. R에서는 http 요청을 하기 위한 다양항 패키지가 있지만 메소드 이름을 바로 함수로 제공하는 httr 패키지를 사용하겠습니다.\n\n\nShow code\n\nif (!requireNamespace(\"httr\")) install.packages(\"httr\")\nlibrary(httr)\nres<-GET(\"https://mrchypark.github.io/\")\ncontent(res)\n\n\n{html_document}\n<html xmlns=\"http://www.w3.org/1999/xhtml\" lang=\"\" xml:lang=\"\">\n[1] <head>\\n<meta http-equiv=\"Content-Type\" content=\"text/html; cha ...\n[2] <body class=\"layout-listing\">\\n\\n<!--radix_placeholder_front_ma ...\n\n위의 결과에서 <html>이라고 나온 것을 볼 수 있습니다. html는 css, javascrit와 함께 브라우저가 사람들이 볼 수 있는 그림을 그리도록 만들어진 규칙입니다. GET 요청은 대부분 서버에서 이런 html 문서를 데이터로 받기 위해서 브라우저에서 동작하는 방식입니다. 알고 계신 다른 사이트들을 시도해보시면 더 이해가 좋을 것 같습니다. 이 html 문서에서 필요한 곳의 내용만 추출하는 패키지로 rvest 패키지가 있습니다. rvest 패키지 사용법은 많은 분들이 소개해주셔서 검색해 보시길 추천드립니다.\nPOST 요청\nPOST는 서버에 데이터를 요청할 때 뭔가 값을 함께 요청하는 방식입니다. 대표적으로 로그인이 있습니다. 위 고감자님의 요청은 PUT을 사용했는데, POST와 거의 같습니다. POST를 값을 실어보내는 것을 body라고 합니다. body는 R에서는 list 자료형으로 처리합니다.\n\n\nShow code\n\nbody<-list(sent=\"아래와같은방식으로API를사용할수있으며,호출건수에대해서별도의제한은없으나,1회 호출에200글자로글자수를제한하고있다.\")\nbody\n\n\n$sent\n[1] \"아래와같은방식으로API를사용할수있으며,호출건수에대해서별도의제한은없으나,1회 호출에200글자로글자수를제한하고있다.\"\n\n위 띄어쓰기 API 요청을 보면 body를 선언하는 부분이 list로 되어 있고, 데이터는 띄어쓰기가 필요한 문장, 그 이름을 sent로 하였습니다. 이건 서버에 sent라는 이름으로 띄어쓰기가 필요한 문장을 함께 전달하기 위해서 선언한 겁니다.\nPUT은 POST와 거의 같다고 했습니다. 여기서는 예시를 PUT으로 하겠습니다.\nres<-PUT(url='http://35.201.156.140:8080/spacing', body=body, verbose())\n위는 PUT요청을 했을 때 일어나는 일들 전체를 보여줍니다. httr 패키지가 다 알아서 해주니 우리는 이제 아래처럼 요청하면 됩니다.\nres<-PUT(url='http://35.201.156.140:8080/spacing', body=body)\nres는 PUT 요청으로 서버에게 요청을 했을 때 서버가 우리에게 돌려준 결과를 저장하였습니다. 위에서 말한 response입니다.\nres\n## Response [http://35.201.156.140:8080/spacing]\n##   Date: 2018-03-05 07:15\n##   Status: 200\n##   Content-Type: application/json\n##   Size: 348 B\n## {\"sent\": \"\\uc544\\ub798\\uc640 \\uac19\\uc740 \\ubc29\\uc2dd\\uc73c\\ub85c API\\u...\n실제로 값에 response라고 하면서 여러 정보를 보여주고 있습니다. 어느 서버 주소에서 받은 것인지, 언제 받았는지, 상태는 얼마인지 받은 데이터가 어떤 것인지, 받은 데이터의 크기가 얼마나 되는지 같은 것들이네요. 하나하나 따져 보시려면 str(res)를 수행해보시면 좋을 것 같습니다. http가 response를 어떻게 정의해 놨는지 알 수 있습니다.\n이 중에서 우리가 궁금한 것은 content입니다. httr 패키지는 response 객체에서 content만 보는 기능을 content() 함수로 제공하고 있습니다. content()함수는 몇몇 유명한 형식에 대해서 자동으로 가져오는 기능을 제공합니다.\ncontent(res)\n## $sent\n## [1] \"아래와 같은 방식으로 API를 사용할 수 있으며, 호출 건수에 대해서 별도의 제한은 없으나, 1회 호출에 200글자로 글자수를 제한하고 있다. \"\ncontent에 json 방식으로 준 모양입니다. R은 json 방식의 데이터를 list 자료형으로 해석합니다. json의 설명을 확인해 보세요. list 이름이 sent인걸 보니 마지막 단계만이 남았습니다.\ncontent(res)$sent\n## [1] \"아래와 같은 방식으로 API를 사용할 수 있으며, 호출 건수에 대해서 별도의 제한은 없으나, 1회 호출에 200글자로 글자수를 제한하고 있다. \"\nresData<-content(res)\nresData$sent\n## [1] \"아래와 같은 방식으로 API를 사용할 수 있으며, 호출 건수에 대해서 별도의 제한은 없으나, 1회 호출에 200글자로 글자수를 제한하고 있다. \"\nOpen API 라고 되어 있는 서비스들이 위와 같은 방식을 사용하고 있습니다. 보통은 sent라고 되어 있는 부분(요청시 body로 선언할 내용과 방법)을 서비스 제공자 쪽에서 설명해줘야 합니다. 다른 API 서비스를 사용하실 때 오늘의 내용이 도움이 되었으면 합니다.\n끝까지 읽어주셔서 감사합니다. 질문, 지적 대환영이며 댓글로 부탁드립니다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106461744-8c084d80-64d8-11eb-93a4-ebedf3fb21c7.png",
    "last_modified": "2021-02-01T13:47:52+00:00",
    "input_file": {}
  },
  {
    "path": "post/논리-연산자-정리/",
    "title": "논리 연산자 정리",
    "description": "드디어 블로그를 단순하게 유지하기 위해 distill로 옮깁니다.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2017-07-31",
    "categories": [
      "operator",
      "logical",
      "Boolean",
      "R",
      "rlang"
    ],
    "contents": "\n\nContents\n논리 연산자란\n논리 연산자\n논리 연산자 왼쪽의 데이터가 1개 일때\n논리 연산자 왼쪽의 데이터가 여러개 일때\n논리 연산자 데이터가 모두 여러개 일때\n\n\n드디어 블로그에서 Rmd를 사용할 수 있게 되어서 매우 기쁜 마음에 포스팅을 하나 기획하였습니다. 그것은 바로 논리 연산자! 기본적은 것은 다 쉬운데 데이터가 여러 개인 벡터(vector)일 때 동작에 대해서 많이 고민하지 않는 것 같아 이렇게 첫 번째 주제로 잡았습니다.\n논리 연산자란\n논리 연산자(Logical Operators)란 논리 자료형(logical로 표시하며 T/F를 의미)를 사칙 연산처럼 TRUE / FALSE 를 계산하여 하나의 결과를 만드는 것이라고 할 수 있습니다. 대표적으로 if 구문에 해당하는 조건문에서 사용하는데요, 코드를 짤 때 조건문을 피할 수 없기 때문에 동작에 대해 잘 이해하고 있는 것이 좋습니다.\nR에서 사용하는 논리 연산은 아래와 같습니다.\n논리 연산자\na, b: 숫자 데이터 1개\nx, y: 논리 데이터 1개\n\n\n연산자\n\n\n설명\n\n\na < b\n\n\na가 b보다 작다\n\n\na <= b\n\n\na가 b보다 작거나 같다\n\n\na > b\n\n\na가 b보다 크다\n\n\na >= b\n\n\na가 b보다 크거나 같다\n\n\na == b\n\n\na와 b가 같다\n\n\na !=\n\n\na와 b가 같지 않다\n\n\n!x\n\n\nx가 아니다\n\n\nx | y\n\n\nx이거나 y이다\n\n\nx & y\n\n\nx이고 y이다\n\n\nisTRUE(x)\n\n\nx가 TRUE이다\n\n\n더하기, 빼기 같은 산술 연산자도 있으니 R에서 사용하는 연산자 소개는 이곳을 참고하면 좋을 것 같습니다. 위에서 강조한 바와 같이 위에 논리 연산자는 모두 데이터가 1개 일때를 의미합니다. 정확하게는 연산자의 왼쪽인 a는 여러 데이터인 벡터(vector)여도 되는데, 연산자의 오른쪽인 b는 한 개 여야만 합니다. 아니, 여러 개일 때 어떻게 동작하는지 알고 있어야 합니다.\n우선 a가 1개일 때와 여러 개일 때를 확인해 보겠습니다.\n논리 연산자 왼쪽의 데이터가 1개 일때\n데이터가 1개인 경우는 매우 간단하고, 모두 상상하는 처음 예시이기도 합니다.\n\n\na <- 10\nb <- 30\n\na < b\n\n\n[1] TRUE\n\na <= b\n\n\n[1] TRUE\n\na > b\n\n\n[1] FALSE\n\na >= b\n\n\n[1] FALSE\n\na == b\n\n\n[1] FALSE\n\na != b\n\n\n[1] TRUE\n\n위에는 모두 상상하시는 대로 결과가 나왔으리라 생각합니다. 맨 아래만 짚어보면 =는 <-와 같은 뜻이어서, 수학적인 등호의 역할을 하길 기대해야 하는 기호는 ==입니다. ==는 왼쪽과 오른쪽이 같다라는 뜻입니다. 그리고 맨 위에 !x에 x가 아니다라는 설명을 해두었습니다. x는 논리 데이터 1개라는 설명도 했죠. 그러다 보니 !=는 !(a == b)와 의미가 같습니다. 작성하기 편하게 하기위해서 약어처럼 정의를 해둔 것이지요. 보통은 논리 자료형 앞에 붙어서 원래 결과의 부정을 뜻합니다. |나 &는 잘 아시리라 생각하고, isTRUE()를 좀 확인해 보겠습니다.\nisTRUE()\nR에서 몇 가지 요령이 있는데, ?함수이름, help(함수이름)이라고 하면 설명이 나오고, ()를 붙이지 않고 함수이름만 콘솔에 입력하면 그 함수를 구성하는 코드가 출력됩니다.\n\n\nisTRUE\n\n\nfunction (x) \nis.logical(x) && length(x) == 1L && !is.na(x) && x\n<bytecode: 0x558ded2612f0>\n<environment: namespace:base>\n\nisTRUE()가 어떻게 동작하는 함수인지 궁금해서 코드를 확인해 봤습니다. 여러개가 있지만 눈에 들어오는 것은 identical(TRUE, x)네요. 입력인자인 x가 TRUE와 같은 것인지를 확인하는 것입니다. identical()은 정확하게 같은지를 결과로 줍니다. 예를 들면 같은 숫자인데 자료형이 다르던가, R은 NA를 계산할 수 없음으로 취급해서 ==으로 확인하면 NA로 결과를 줍니다. 그래서 rstudio를 사용하시면 == NA를 인식해서 is.ns()를 사용하라고 경고를 주기도 합니다. 아래 코드를 봐주세요.\n\n\n2L == 2\n\n\n[1] TRUE\n\nidentical(2L,2)\n\n\n[1] FALSE\n\n10 == NA\n\n\n[1] NA\n\n10 != NA\n\n\n[1] NA\n\n10 > NA\n\n\n[1] NA\n\nidentical(10,NA)\n\n\n[1] FALSE\n\n그래서 isTRUE(x)는 x가 TRUE와 완전히 같은지를 확인해서 같으면 TRUE, 다르면 FALSE를 결과로 주는 함수입니다. 조건문 안에 identical()은 익숙해지면 자주 사용하는 함수이니 확인해주세요.\n논리 연산자 왼쪽의 데이터가 여러개 일때\n데이터가 여러개라는 것은 벡터(vector)로 구성한다는 뜻입니다. 우선 결과를 확인해 보겠습니다. 일반적으로 벡터를 만들 때는 c()를 사용합니다. ?c로 설명서를 확인해 보세요.\n\n\na <- c(10,20,30,40,50)\nb <- 30\n\na <  b\n\n\n[1]  TRUE  TRUE FALSE FALSE FALSE\n\na <= b\n\n\n[1]  TRUE  TRUE  TRUE FALSE FALSE\n\na > b\n\n\n[1] FALSE FALSE FALSE  TRUE  TRUE\n\na >= b\n\n\n[1] FALSE FALSE  TRUE  TRUE  TRUE\n\na == b\n\n\n[1] FALSE FALSE  TRUE FALSE FALSE\n\na != b\n\n\n[1]  TRUE  TRUE FALSE  TRUE  TRUE\n\n결과를 확인해 보면 모두 a 데이터의 개수인 5개 만큼 결과 또한 출력된 것을 확인할 수 있습니다. 이것은 산술 연산자에서도 확인할 수 있는 동작인데요.\n\n\na <- c(10,20,30,40,50)\nb <- 30\n\na + b\n\n\n[1] 40 50 60 70 80\n\na - b\n\n\n[1] -20 -10   0  10  20\n\na * b\n\n\n[1]  300  600  900 1200 1500\n\na / b\n\n\n[1] 0.3333333 0.6666667 1.0000000 1.3333333 1.6666667\n\na ** b\n\n\n[1] 1.000000e+30 1.073742e+39 2.058911e+44 1.152922e+48 9.313226e+50\n\na %% b\n\n\n[1] 10 20  0 10 20\n\na %/% b\n\n\n[1] 0 0 1 1 1\n\n이렇게 연산자의 왼쪽이 여러개의 데이터인 벡터이고, 오른쪽이 데이터 1개 일때(데이터가 1개 일때도 벡터라고 합니다.) 연산자는 왼쪽 데이터를 기준으로 각각 연산을 수행해서 왼쪽 데이터의 개수만큼 결과를 보여줍니다. 그렇다면, 논리 연산자 오른쪽의 데이터가 여러개면 어떻게 될까요? 예상되실 겁니다.\n\n\na <- 30\nb <- c(10,20,30,40,50)\n\na <  b\n\n\n[1] FALSE FALSE FALSE  TRUE  TRUE\n\na <= b\n\n\n[1] FALSE FALSE  TRUE  TRUE  TRUE\n\na > b\n\n\n[1]  TRUE  TRUE FALSE FALSE FALSE\n\na >= b\n\n\n[1]  TRUE  TRUE  TRUE FALSE FALSE\n\na == b\n\n\n[1] FALSE FALSE  TRUE FALSE FALSE\n\na != b\n\n\n[1]  TRUE  TRUE FALSE  TRUE  TRUE\n\n논리 연산자 데이터가 모두 여러개 일때\n그럼 이제 마지막 경우를 남겨두고 있습니다. 양쪽 다 여러개의 데이터인 경우인데요, 이 경우에서도 데이터의 개수가 같은 경우와 다른 경우로 달라집니다.\n데이터의 개수가 같은 경우\n먼저 결과부터 보시죠\n\n\na <- c(10,20,30,40,50)\nb <- c(1,2,3,4,5)\n\na <  b\n\n\n[1] FALSE FALSE FALSE FALSE FALSE\n\na <= b\n\n\n[1] FALSE FALSE FALSE FALSE FALSE\n\na > b\n\n\n[1] TRUE TRUE TRUE TRUE TRUE\n\na >= b\n\n\n[1] TRUE TRUE TRUE TRUE TRUE\n\na == b\n\n\n[1] FALSE FALSE FALSE FALSE FALSE\n\na != b\n\n\n[1] TRUE TRUE TRUE TRUE TRUE\n\n개수가 같으니 결과도 같은 개수만큼 나왔고, 그 의미는 각각의 위치에 것들이 각각 연산되었다는 뜻입니다. |나 &도 같이 동작하는지 보시죠\n\n\nx <- c(T,T,T)\ny <- c(T,F,F)\n\nx & y\n\n\n[1]  TRUE FALSE FALSE\n\nx | y\n\n\n[1] TRUE TRUE TRUE\n\n|나 &도 똑같이 결과가 데이터의 갯수와 같이 3개로 나오는 것을 볼 수 있습니다. 그런데, 논리 자료형의 연산 결과가 여러 개인 경우는 사실 조건문을 사용하는데 좋은 결과가 아닙니다. 그래서 논리 자료형의 연산 결과를 1개로 정리하는 방법들이 있습니다.\n\n\nx <- c(T,T,T)\ny <- c(T,F,F)\n\nany(y)\n\n\n[1] TRUE\n\nall(y)\n\n\n[1] FALSE\n\nx && y\n\n\n[1] TRUE\n\nx || y\n\n\n[1] TRUE\n\n첫번째 방법은 any(), all()함수를 사용하는 방법입니다. 두 함수 모두 인자로 논리 자료형의 벡터를 사용하는데요, any()는 뭐라도 하나 TRUE라면 TRUE를 결과로 줍니다. any라는 이름에 걸맞죠. all()은 전부 TRUE여야 TRUE를 줍니다. 역시 all이라는 이름에 걸맞습니다. 여러개의 논리 데이터를 하나의 결과로 정리한다는 점에서 조건문에 사용하기 좋습니다.\n그 아래 ||와 &&도 결과를 한개만 준다는 점에서는 같습니다만 연산 방식이 다릅니다. 이 두 연산자는 양쪽에 데이터가 여러개가 온다고 하더라도 첫번째 데이터만 사용합니다. 조건문의 ()에 논리 데이터가 여러개이면 경고를 주고 첫번째 데이터만 사용한다고 합니다. ||와 &&은 의도적으로 모두 첫번째 데이터만 연산에 사용한다는 것을 명시적으로 표현하는 것입니다. 한번 확인해 보겠습니다.\n\n\nx <- c(T,T,T)\ny <- c(T,F,F)\nx && y\n\n\n[1] TRUE\n\nx || y\n\n\n[1] TRUE\n\nx <- c(F,T,T)\ny <- c(T,F,F)\nx && y\n\n\n[1] FALSE\n\nx || y\n\n\n[1] TRUE\n\nx <- c(T,T,T)\ny <- c(F,F,F)\nx && y\n\n\n[1] FALSE\n\nx || y\n\n\n[1] TRUE\n\nx <- c(F,T,T)\ny <- c(F,F,F)\nx && y\n\n\n[1] FALSE\n\nx || y\n\n\n[1] FALSE\n\n지금은 앞에만 달리하며 출력했는데, 뒤에 데이터를 변경해서 결과가 달라지지 않는 것을 직접 확인해 보시면 좋을 것 같습니다. 더 자세한 정보는 ?\"|\"로 확인하실 수 있습니다. 한 문장만 가져와서 보여드리면\n\nThe longer form evaluates left to right examining only the first element of each vector.\n\n여기서 longer form이 ||나 &&를 뜻합니다.\n데이터의 개수가 다른 경우\n데이터의 개수가 다른 경우는 또 두 가지 경우로 나뉩니다. 두 데이터의 개수가 배수 관계에 있는 경우와 아닌 경우입니다. 배수인 경우 먼저 보시죠\n데이터의 개수가 배수 관계인 경우\n\n\na <- c(10,20,30,40,50,60)\nb <- c(10,20,30)\n\na <  b\n\n\n[1] FALSE FALSE FALSE FALSE FALSE FALSE\n\na <= b\n\n\n[1]  TRUE  TRUE  TRUE FALSE FALSE FALSE\n\na > b\n\n\n[1] FALSE FALSE FALSE  TRUE  TRUE  TRUE\n\na >= b\n\n\n[1] TRUE TRUE TRUE TRUE TRUE TRUE\n\na == b\n\n\n[1]  TRUE  TRUE  TRUE FALSE FALSE FALSE\n\na != b\n\n\n[1] FALSE FALSE FALSE  TRUE  TRUE  TRUE\n\n우선 결과가 경고 없이 잘 나왔고, 총 6개입니다. 이때는 개수가 부족한 쪽이 개수가 많은 쪽 만큼 한번 더 돌아서(Recycle) 연산에 사용된 것을 알 수 있습니다. 이것을 Recycling Rule이라고 합니다. 배수관계에 있다보니 특별히 잘못했다고 경고를 주지도 않습니다. 그럼 배수 관계가 아닐 떈 어떻게 될까요?\n데이터의 개수가 배수 관계가 아닌 경우\n\n\na <- c(10,20,30,40,50)\nb <- c(10,20,30)\n\na <  b\n\n\n[1] FALSE FALSE FALSE FALSE FALSE\n\na <= b\n\n\n[1]  TRUE  TRUE  TRUE FALSE FALSE\n\na > b\n\n\n[1] FALSE FALSE FALSE  TRUE  TRUE\n\na >= b\n\n\n[1] TRUE TRUE TRUE TRUE TRUE\n\na == b\n\n\n[1]  TRUE  TRUE  TRUE FALSE FALSE\n\na != b\n\n\n[1] FALSE FALSE FALSE  TRUE  TRUE\n\n똑같이 Recycling Rule이 적용되어 적은 쪽이 많은 쪽 개수 만큼 한번 더 돌아서 사용하여 연산하지만, 쓰다 말기 때문에 경고를 줍니다. 배수관계가 아닌데 너가 지금 잘 사용한 게 맞는거냐라고 물어보는 거죠. 맞다면 무시하시면 됩니다. 결과도 긴 데이터쪽 개수만큼인 5개로 나왔네요. 의도하신거라면 이대로 진행하시면 됩니다.\n이렇게 논리 연산자도 데이터가 여러개일 때 산술 연산자와 같은 동작을 취합니다. 이 부분이 아마 기초를 배운 후에 조합해서 확인해 봐야 하는 부분인 것 같습니다. 그리고 많이 실수하시는 부분이 있습니다. 논리 자료형이라면 특별히 문제되지 않는데, ==의 동작을 오해하세요. 사실 이걸 이야기하고 싶어서 위에 저 많은 얘기를 했는데요. 이미 주제 하나 정도 되는 것 같아 포스트를 나누겠습니다.\n다음 포스트는 왜 %in% 연산자를 사용하는가? feat.== 입니다.\n끝까지 읽어주셔서 감사합니다. 질문, 지적 대환영이며 댓글로 부탁드립니다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106395892-0e94fc80-6448-11eb-9836-f3f8449a472b.png",
    "last_modified": "2021-02-01T13:47:52+00:00",
    "input_file": {}
  },
  {
    "path": "post/블로그-reboot/",
    "title": "블로그 reboot",
    "description": "blogdown으로 옮겨서 시작합니다.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2017-04-05",
    "categories": [
      "anounce",
      "blog",
      "reboot"
    ],
    "contents": "\n\n블로그를 찾아주신 모든 분들 반갑습니다! 안녕하세요 박찬엽입니다. 여러 블로그 도구들과 씨름하다 정착하고 싶어 어느 정도 정리했습니다. 가능하면 한 번에 처리할 방법들을 고민하고 사용해보고 하는 기간이 길었던 것 같습니다. reboot라고 제목을 지은 이유는 이런 저런 실험을 하고 OS에 환경을 세팅하고 난 후에는 reboot을 하기 때문입니다. 이제 다시 reboot할 일 없는 열일하는 서버처럼 잘 운영해 보겠습니다.\n감사합니다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106381525-aff66100-63fc-11eb-878f-724b1f26b387.png",
    "last_modified": "2021-02-01T13:47:52+00:00",
    "input_file": {}
  }
]
