[
  {
    "path": "post/여러개의-github-계정을-사용해보자/",
    "title": "여러개의 github 계정을 사용해보자",
    "description": "여러 ssh키를 사용하려면 .gitconfig에 설정해주면 된다. 폴더별 프로필과 ssh key를 설정할 수 있다.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2022-10-12",
    "categories": [
      "github",
      "account",
      "tips",
      "gitconfig",
      "ssh"
    ],
    "contents": "\n\nContents\n답은\ngitconfig다\n\n\nPhoto by\nErol\nAhmed on\nUnsplash\n여러 블로그를 찾아본 결과, .ssh/config 파일을 작성하는 방법이나\nGIT_SSH_COMMAND를 사용하는 방법을 설명하고 있습니다. 모두\n너무 불편해서 다른 방법을 열심히 찾았고, 폴더 경로 기준으로 동작하는\n방법을 찾아서 공유합니다.\n한줄 요약\n\n.gitconfig를 잘 사용하면 된다.\n\ngithub은 명실상부 코드를 사용하는 사람이라면 사용해야\n하는 최우선 서비스로 도약했습니다. 그러다 보니 개인적으로 계정을\n사용하는 경우가 많아졌는데요. 역시 회사 계정을 추가로 사용할 일도\n생기고는 합니다. 물론 회사 조직에 개인 계정을 추가할 수 도 있습니다만,\n몇 가지 안타까운 지점이 발생합니다.\nSAML로 접근제어를 하는 경우 개인 계정을 관리 범위를 벗어납니다.\n개인이 어떤 회사에 코드기여한 것을 공유하고 싶지 않을 수\n있습니다.\n1번의 사례는 아마도 구글 workspace를 사용하는 경우일텐데요. github도\n엔터프라이즈 플랜에서는 SAML(Security Assertion Markup Language)을\n지원한답니다? SAML을 지원하면 계정관리를 한 곳에 통합할 수 있습니다.\n구글 workspace에서 제거하면 github 조직 계정에서 함께 제거(정확하진\n않지만)되는 것이지요.\n2번의 경우는 2가지 일텐데요. 하나는 혹시 퇴사를 하게 되면 이후 회사의\n구성원에게 내가 기여한 부분을 알리고 싶지 않다. + 혹시 그 코드를\n오픈하게 되면 다른 사람들에게 알리고 싶지 않다가 되겠습니다.\n물론 계정명으로 공유되는 만큼, 노출 정도가 다를 수는 있겠습니다만.\n회사 활동과 개인 활동을 명확히 구분하려면, 그리고 회사에서도 개발자가\n생산한 코드의 회사 소유를 확인하는데에도 필요한 활동이다 싶습니다.\n아무튼, 여러 가지 이유로 여러 github 계정을 가지게 되었고, 이걸 개별\nssh 키를 사용해야 하며(github에서 여러 계정에 공통 ssh키를 허용하지\n않음.) 같은 컴퓨터에서 사용하고 싶은 분들에게 설정하는 방법을 공유하고자\n합니다.\n답은 gitconfig다\n여러 자료가 다양한 이야기를 하고 있지만 제가 실행해본 가장 최신의\n방법은, .gitconfig 파일을 잘 작성하는 것으로 해결되었습니다. 우선 저는\n회사 repo는 특별한 하나의 폴더 내에서 사용한다는 상태를 가정하고\n시작하였습니다.\nssh키 생성\nssh 키 생성은 ssh-keygen 명령으로 수행합니다. 우선 ssh\n키를 사용하는 이유는 보안때문인데요. 많은 키생성 알고리즘이 있습니다만,\n제가 찾는 한 권장되는 방법은 2가지 입니다. RSA를 높은 비트로 수행하는것,\nEdDSA(Ed25519)를 사용하는 것. 참고1, 참고2\n둘 중에 하나를 선택해 생성하면 됩니다. 저는 EdDSA를 선택했습니다.\nssh-keygen -t ed25519 -C \"보통 이메일 주소\"\nrsa 방식은 아래와 같습니다.\nssh-keygen -t rsa -b 4096 -C \"보통 이메일 주소\"\n\n-C 는 주석으로 보통 사용하는 이메일을 작성하는 것 같아\n추가했습니다.\n\n개인적으로 이미 사용하고 있는게 있다면 아마도 id_rsa 정도로 저장되어\n있을 겁니다. (없다면 하나 생성하세요.) id_work 정도로 새로 사용할 키를\n추가하시면 되겠습니다.\ngithub에 ssh 키 등록\n이 부분은 github 의 공식 문서로 대체합니다. https://docs.github.com/en/authentication/connecting-to-github-with-ssh/adding-a-new-ssh-key-to-your-github-account\n혹시 이해가 안되시면 댓글달아주세요.\n기본 프로필 설정\n우선 ~/ 위치에 .gitconfig 파일을\n생성합니다. 저는 개인 계정을 기본값으로, 회사 계정을 특수한 폴더내에\n설정하려고 합니다. 그래서 ~/ 위치의 .gitconfig 파일에는\n개인 설정을 추가합니다. 설정 파일은 아래와 같습니다.\n# ~/.gitconfig 파일의 내용\n\n[user]\n    email = mrchypark@gmail.com\n    name = Chanyub.Park\n\n[github]\n    user = mrchypark\n \n[core]\n    sshCommand = \"ssh -i ~/.ssh/id_ed25519_persnal\"\n\n[includeIf \"gitdir:~/Documents/work/\"] \n    path = ~/.gitconfig-work\n갑자기 설명할게 많아졌네요. [user]는\ngit config --global user.하고 설정하는 설정값입니다.\nemail과 name이 없으면 commit이 안되니 모두\n알고 있을거라 생각합니다. [github]은 github 계정명인데,\n이게 없으면 어떻게 되는지는 잘 모릅니다. 우선은 필요한 것 같아\n작성했는데요. 혹시 테스트를 해보신 분이 있으면 댓글 달아 주세요. :)\n(아마 github에서 사용하는 계정 연동용 키이겠죠?)\n[core] 부분이 중요한데요. 기본 프로필에서 사용할 ssh\n키의 위치입니다. 저는 개인이 사용할 키 이름을\nid_ed25519_persnal로 작성했으니 이곳에 명시적으로\n작성해두었습니다.\n[includeIf 로 시작하는 부분이 이제 조건문인데요. 만약\ngit이 이 폴더 내부에 있다면 아래 설정파일을 사용해라! 라는 설정입니다.\nincludeIf 덕분에 여러 계정 설정이 가능해서 감사할\n따름입니다. 저는 문서 폴더에 work라는 폴더의 git들은\n~/.gitconfig-work 설정을 사용하라고 지정했습니다.\n# ~/.gitconfig-work 파일의 내용\n\n[user]\n    email = <회사 이메일 계정 정보>\n    name = Chanyub.Park\n\n[github]\n    user = <회사의 깃헙 계정>\n \n[core]\n    sshCommand = \"ssh -i ~/.ssh/id_ed25519_work\"\n이 파일에는 기본 설정파일인 ~/.gitconfig에서 덮을\n설정들을 추가합니다. [user], [github],\n[core]에서의 ssh key 위치 모두 추가하였습니다. 이때 사용한\nssh 키는 물론 github 회사 계정에서 ssh 키로 등록해야 합니다.\n이제 실제로 사용하기 위해서 ssh-add에 추가해 줍니다.\nssh-add ~/.ssh/id_ed25519_persnal\nssh-add ~/.ssh/id_ed25519_work\n저는 zsh를 사용하고 있어서 .zshrc에 위 명령을 모두 추가해두었습니다.\n이게 있어야 devcontainer 사용할 때 다른 설정 없이 ssh키를\ngit으로 사용할 수 있더라구요.\n그리고 아직 공부가 부족하여 기존에 로컬 레포를 연결하는 방법을\n모르겠습니다. 한번 remote 명령으로 기존 레포의 리모트\n설정을 변경해보았는데, 작동하지 않더라구요. 슬프게도,\ngit clone한 레포에서는 잘 작동하는 것을 확인하였습니다.\n이 포스트를 작성하면서, 정보를 전달하면서도, 제가 부족한 부분이 3가지\n있었습니다.\n정말 추천하는 알고리즘\n[github] 설정의 기능과 동작\n기존에 사용하고 있던 레포의 설정 적용\n혹시 답을 알고 계신 분이 계시다면 답글 달아주시고, 포스트가 도움이\n되셨다면 공유라도 한번 부탁드립니다. 감사합니다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/195148825-b47fd39a-d194-4ce5-b1b3-2b0b5327ec0e.jpg",
    "last_modified": "2022-11-27T05:11:08+00:00",
    "input_file": {}
  },
  {
    "path": "post/rtips-m1-mac에서-패키지-인스톨-문제-해결하기/",
    "title": "[Rtips] m1 mac에서 패키지 인스톨 문제 해결하기",
    "description": "공식 문서 링크: https://mac.r-project.org/tools/",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2022-09-14",
    "categories": [
      "R",
      "m1",
      "package install",
      "xcode",
      "fortran",
      "compiler",
      "Rtips",
      "iamdt"
    ],
    "contents": "\n\nPhoto by\nMaxim\nHopman on\nUnsplash\n한줄요약\n\n공식 문서를\n확인하자.\n\n최근 mac에서 R의 패키지를 설치할 때 컴파일 단계에서 문제가 생기는\n경우가 있습니다. gfortran 이 없다는 식의 에러인데요. 보통\nxcode가 설치가 안되어 있거나 brew install gcc\n정도로 해결되었던 문제라 넘어갔었습니다. 근데, 최근에 mac을 다시 설정할\n일이 생겨서 살펴보니 같은 문제가 발생했습니다.\n해결방법\n총 2개를 설치하라고 안내하고 있습니다.\nxcode\nmac용 개발도구인 xcode를 설지합니다. 어떤 방식으로\n설치해도 문제는 없는 것 같습니다만, 터미널에서 아래 명령으로 설치할 수\n있습니다.\nsudo xcode-select --install\nGNU fortran\n아쉽게도 포트란 컴파일러가 xcode에 포함되어 있지 않답니다. 인텔\n맥인지, m1 맥인지에 따라 방법이 다릅니다.\n2.1 인텔 맥\ndmg 설치 파일을 제공합니다. /usr/local/gfortran/bin\n위치에 설치를 하나봅니다.\nexport PATH=$PATH:/usr/local/gfortran/bin 로 PATH를\n추가해야 합니다.\n2.2 m1 맥\nm1 맥용 컴파일러를 다운로드 받아서 압축을 풀어야 합니다. 다운로드\n받은 파일이 있는 위치에 가서 아래 명령을 터미널에서 수행합니다.\nsudo tar fxz gfortran-12.0.1-20220312-is-darwin20-arm64.tar.xz -C /\n그리고 마찬가지로\nexport PATH=$PATH:/opt/R/arm64/gfortran/bin 로 경로를\n추가합니다.\n모든 것이 끝나면 이제 문제없이 패키지를 컴파일하여 설치할 겁니다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/190064110-47aa2571-5986-424d-b454-fb498a100b84.jpeg",
    "last_modified": "2022-11-27T05:10:02+00:00",
    "input_file": {}
  },
  {
    "path": "post/패키지-소개-빠르고-편리한-형태소-분석기-elbird/",
    "title": "[패키지 소개] 빠르고 편리한 형태소 분석기 elbird",
    "description": "cpp 기반의 한글 형태소 분석기인 kiwi를 사용하여 빠르고 편리한 R 패키지인 elbird를 제작하였습니다.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2022-04-05",
    "categories": [
      "R",
      "package",
      "cran",
      "kiwi",
      "elbird",
      "morphological",
      "analyzer"
    ],
    "contents": "\n\nContents\nelbird\n패키지\n개발\n뒷이야기\n\n\n 혹시 괜찮으시면 위 이미지 클릭해서 좋아요 한번 부탁드립니다. :)\n한줄요약\n이제 한번에 설치해서 사용하는 elbird로 편안한\n텍스트마이닝하세요~~\nelbird 패키지\nelbird를\n소개합니다. elbird는 cpp로\n개발된 kiwi를 사용하는\n형태소 분석기로, python 버전 kiwi인 kiwipiepy를 사용하는\n형태로 2020년 6월에 시작하였습니다.\n하지만 conda를 설치해야 한다는 의존성 부분이 존재했기 때문에, cpp를\n사용하는 방법을 계속 공부하였습니다. 그 부산물로 go 패키지인 kiwigo도 제작해보면서\n개발에 필요한 내용을 파악할 수 있었습니다. 역시 kiwigo 개발을\n하드케리해주신 kkweon님께\n진심으로 감사드립니다.\n드디어, 다른 설치 없이 바로 사용할 수 있는 빠르고 편리한 형태소\n분석기 R 패키지 elbird의 기본\n골격을 갖추었습니다.\n현재 크랜 버전은 0.1.3 입니다.\ninstall.packages(\"elbird\")\n바로 사용해보겠습니다.\n\n\nlibrary(elbird)\ntokenize(\"새로운 형태소 분석기인 elbird를 소개합니다.\")\n\n\n# A tibble: 6 × 5\n  sent  form   tag   start   len\n  <chr> <chr>  <chr> <int> <int>\n1 1     새롭   VA        1     3\n2 1     형태소 NNG       5     3\n3 1     분석기 NNG       9     3\n4 1     elbird SL       14     6\n5 1     소개   NNG      22     2\n6 1     ᆸ니다  EF       24     3\n\ntokenize() 함수는 아마 형태소 분석기가 필요하신 분들이\n가장 많이 사용하는 함수일 것입니다.\nkiwi는 내장\n불용어사전을 제공하고 있습니다. 이에 elbird도\n불용어사전을 관리하고 사용하는 방법을 함께 제공합니다. 우선\ntokenize() 함수는 stopwords 파라미터를\n제공하며, 기본값은 TRUE입니다. 내장 불용어 사전을\n사용한다는 뜻입니다. 사용하지 않으려면 FALSE를 주시면\n됩니다.\n\n\ntokenize(\"안녕하세요.\")\n\n\n# A tibble: 3 × 5\n  sent  form  tag   start   len\n  <chr> <chr> <chr> <int> <int>\n1 1     안녕  NNG       1     2\n2 1     시    EP        4     1\n3 1     어요  EF        4     2\n\ntokenize(\"안녕하세요.\", stopwords = FALSE)\n\n\n# A tibble: 5 × 5\n  sent  form  tag   start   len\n  <chr> <chr> <chr> <int> <int>\n1 1     안녕  NNG       1     2\n2 1     하    XSA       3     1\n3 1     시    EP        4     1\n4 1     어요  EF        4     2\n5 1     .     SF        6     1\n\n비교해서 보면 문장부호가 분석 결과로 포함된 것을 알 수 있습니다. 내장\n불용어사전에는 문장부호가 등록되어 있어 stopwords = TRUE 일\n때 결과에서 제외되는 것입니다.\nelbird는\n처음부터 tidytext와 함께\n사용하는 것을 고려하여 제작하였습니다. tidytext의\nunnest_tokens() 함수와는 이렇게 사용할 수 있습니다.\n\n\nlibrary(magrittr)\nlibrary(tidytext)\nlibrary(tibble)\ntar <- tibble(content = \"유구한 역사와 전통에 빛나는 우리 대한국민은 3ㆍ1운동으로 건립된...\")\n\ntar %>% \n  unnest_tokens(\n    input = content,\n    output = word,\n    token = tokenize_tidy\n    )\n\n\n# A tibble: 9 × 1\n  word    \n  <chr>   \n1 유구/xr \n2 역사/nng\n3 전통/nng\n4 빛나/vv \n5 국민/nng\n6 3/sn    \n7 1/sn    \n8 운동/nng\n9 건립/nng\n\nkiwi 기능에서 아직\n구현되지 않은 기능들이 있습니다. 모두 구현하고, 또 소개하겠습니다.\n감사합니다.\n개발 뒷이야기\n형태소 분석기는 텍스트 분석에 꼭 필요한 도구입니다. R에서는 KoNLP가 가장 유명하고\n많이 쓰이고 있습니다. java로 카이스트에서 제작한 HanNanum\n형태소 분석기를 R 패키지로 만든 것입니다. 그래서 jdk를 컴퓨터에\n설치해야만 사용할 수 있습니다. 아쉽게도 2020년\n2월 1일 cran에서 내려간 후 유지/보수가 되지 않고 있는 상황입니다.\n소스가 자바로 되어 있다보니, 제가 수정하고 접근하기에도 쉽지 않더군요.\n특히 형태소 분석기를 설치하는 일이 jdk 때문에\n초보자에게 아주 어려운 일이 되곤 합니다. 다른 의존성이 없었으면 좋겠다는\n생각이 들었습니다.\nKoNLP와는 다르게 은전한닢\n프로젝트를 사용한 RcppMeCab도 있습니다.\n일본어 분석기인 mecab를\n한국어 맞게 사용하려고 튜닝한 은전한닢도\nmecab-ko 라는 이름으로 널리 사용되는 편입니다. cpp로 작성한 빠른 성능,\n중국어/일본어도 사용가능, 띄어쓰기 오류에 강한 분석 능력, 설치의\n용이함이 장점이라고 할 수 있습니다. 대신 사용자 사전을 관리하기 어렵고,\n문제가 생겼을 때 해결하기 어려운 에러등이 발생하기도 합니다. 역시\nmecab과 사전 설치라는 의존성이 발목을 잡기도 합니다.\n사용하기 쉽고, 다른 추가 설치를 하지 않아도 되고, 사용자 사전 관리\n기능도 잘 되어 있는 패키지가 있으면 좋겠지 않나요?\n그렇게 elbird 개발을\n시작하였습니다.\n우선 잘 되어 있는 다른 형태소 분석기를 찾기 시작했습니다. 저는 형태소\n분석기를 직접 만들 능력이 없었기 때문입니다. cpp로 제작하고\n오픈소스이며, 사용자 기능이 잘 되어 있는 패키지를 찾다가 조건에 맞는\n것을 찾았습니다. 바로 kiwi입니다. 이 자리를 빌어\n좋은 형태소 분석기를 개발해 주시고, 계속 개선하고 계시는 bab2min님께 깊은 감사의 인사를\n드립니다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/161697867-de4156cf-3f56-49f7-aa26-413ce300fd4b.png",
    "last_modified": "2022-11-27T05:11:27+00:00",
    "input_file": {}
  },
  {
    "path": "post/패키지-버전은-어떻게-작성해야할까/",
    "title": "패키지 버전은 어떻게 작성해야할까",
    "description": "시멘틱 버전의 의미와 현대적인 방식의 버전 관리 방식을 소개합니다.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2021-09-02",
    "categories": [
      "semver",
      "headver",
      "package",
      "version",
      "develop",
      "semantic-release"
    ],
    "contents": "\n\nPhoto by\nJimmy\nDean on\nUnsplash\n한줄요약\n\n버전 정책은 semver를 사용하되, 개발자가 필수로 사용하는 커밋메세지에\n규칙을 정하여 자동화합니다.\n\n관련 논의를 함께 진행해주신 코딩맛집의\n박찬성님 감사합니다.\n버전을 어떻게 하지?\n코드를 작성할 때 가장 고민하는 것은 이름을 짓는 것입니다. 하지만,\n버전 변경을 정하는 것 또한 매우 큰 고민이기도 합니다. 제가 devops를\n맡아서 배포 및 운영 책임을 가지면서 개발자들과 배포용 버전 관리에 대해서\n많은 고민을 하고 있습니다. 많이들 semver를 사용하기는 합니다만,\n실제 의미로 사용하기 보다는 기간적인 의미를 둘 때가 많습니다. 특히\n릴리즈 주기를 지정하는 순간, 버전의 의미와 기간의 의미는 많이 섞이게\n됩니다.\n저는 k8s를 사용하는 운영자로서 개발자와 빌드된 도커 이미지로\n소통하기로 정했는데요. 그러다보니 도커 이미지의 태그가 매우 중요한\n정보가 되었습니다. 그래서 개발 버전은 git의 short hash를, 이외에 사용을\n위한 버전은 vsemver를 태그하여\n태그 정보에 변경 부분을 작성하는 규칙을 정했습니다. 예를 들어 v1.1.3\n버전을 배포해야 하는 것이면, 테스트를 거친 어플리케이션의 v1.1.3 버전\n이미지를 배포하는 식이지요.\n그런데 이런 버전 정보를 본래의 의미에 맞게 올리는 것이 쉬운 일이\n아니었습니다.\nsemver란?\n\nsemver의 의미를 설명하는 단락입니다. 충분히 이해하신다면 건너뛰어도\n좋습니다.\n\nsemver는 오늘날 대부분의\n조직에서 사용합니다. 전체 명칭은 Semantic Versioning 이고,\n명세서(Specification)를 지칭하는 표현입니다.\n명세 전체는 공식 문서를 확인하는 것을 추천합니다.\n간단히 축약하면 X.Y.Z 의 형식을 따르는 버전 체계라고 할 수 있습니다.\nX는 주 버전(Major)으로 0으로 시작할 경우 개발 중임을, 그\n이상의 숫자로 표현할 경우 각 버전 내에서 api 명세를 많이 변경하지 않을\n것임을 뜻합니다. 0.~ 으로 시작하는 버전은 현재 개발중임으로 중간에\n사용법이 자유롭게 바뀔 수 있다는 경고입니다. 대신 개발자에게 유지\n책임에서 자유롭게함으로써 초기 개발상황을 반영한 정책이라고 볼 수\n있습니다.\nZ는 수 버전(Patch)으로 api 명세의 변경 없이 버그 수정\n등의 수정이 발생한 경우에만 올립니다. 앞선 버전이 변경될 시 0으로 초기화\n합니다.\nY는 직전 버전의 api 명세는 그대로 사용할 수 있으나 Z 버전 업과는 다른\n수준의 큰 변경이 있을 때 올립니다. 대표적으로 api 추가나 기존 api를\n제거할 예정이라고 알리는 때를 들 수 있습니다. 내부적으로 대대적인 변경이\n있을 때에도 api의 변경이 없더라도 올릴 수 있습니다. 예를 들면 의존하는\n패키지의 변경이나 파라미터, 결과값에 컬럼이 추가되는 것 등을 들 수\n있습니다.\nX는 기존 버전을 사용하는 코드를 변경해야만 하는 변화가 있는 경우\n올립니다. 단순하게는 함수나 파라미터의 이름이 바뀌었거나 제거된 경우가\n있습니다. 혹은 아예 사용 체계 자체가 바뀌는 경우도 주 버전을 올리는\n이유입니다.\nsemver의 문제점\nsemver의 문제점은 여러 faq나 각 버전을 올리는 규칙을 공유함에도\n불구하고, 각 개발자가 판단하는 버전업의 경계가 다르다는 것입니다. 특히\n버전을 올리는 것을 각 개발자가 수동으로 수행하기 때문에 생기는 어려움도\n발생하였습니다. 저의 경우, 주 버전을 기간에 맞추고 나머지 버전은\n무시한채 식별자 변경으로 개발하는 것을 경험하기도 했습니다. 그만큼\n변경점에 대한 판단과 버전 변경의 고민을 개발자에게 주면 생기는 문제가\n발생하는 것이지요.\n주변 분들에게 질문해보니, 듣기 좋은 규칙을 하나 얻었습니다. 버그\n수정은 수버전, 기능 추가는 부버전, 제거는 주버전을 올립니다. 큰 변경으로\n주버전을 올리는 것은 논란이 되지 않으니 신경쓰지 않아도 되구요. * 관련\n아이디어를 공유해주신 코딩맛집의\nyongmin님 감사합니다.\n그럼에도 불구하고, 버전을 보는 사람으로 하여금 정보를 전달할 수 있는\n방법을 찾는 것이 중요할 것입니다.\nheadver\n이런 문제를 해결하기 위해 line에서는 자체적으로 사용하는 headver를 구성하여 발표하기도\n했습니다. headver는 수동\n버전 관리의 문제와 여러 버전 체계의 혼란을 최소화하기 위해 주 버전\n이외의 버전을 다른 자동화된 정보로 처리하였습니다.\n{주버전}.{년주}.{빌드번호}로 구성된 semver와 문법 호환하는 정책을\n제안한 것인데요. 주 버전의 의미는 그대로 같고, yyww의 2자리 년도와 해당\n주를 2자리수로 표현한 날짜, 같은 기간내 실행된 증가하는 빌드 번호로\n구성합니다. 이렇게 하면 주 버전만 수동으로 관리하고, 나머지는 기간과\n순서의 의미를 전달함으로써 버전이 일정 기간과 비슷하게 연결되는 점을\n활용합니다. yyyyMMdd 가 아닌 이유는 자동증가하는 빌드 번호 덕분에 중간\n기간 표현은 yyww로 충분하다고 합니다. 특히 스프린트를 진행하는 경우,\n주단위 혹은 2주단위를 많이 사용하므로 개별 스프린트 단위를 표현할 수\n있기도 합니다.\n주버전 조차도 공개 단위로 제안하고 있기도 합니다. 사용자에게 전달하는\n타이밍에 주버전을 올림으로써 적극적으로 주 버전을 올리는 것은\n제안합니다. 버전 변경의 고민을 최소화하려는 결정을 느낄 수\n있었습니다.\n이렇게 하면 버전을 올리는 것에 대해 논의하는 시간을 줄일 수 있으며\n충분히 소통하는 사람들 간에 정보를 전달할 수 있습니다.\n제가 가진 고민과 비슷한 문제를 해결하려는 노력을 확인할 수 있어서\n매우 좋았습니다. 버전 관리의 자동화라는 아이디어를 얻을 수 있었던 점도\n저에게 매력적이었구요.\ncalver\n최근 Rstudio 에서는 자사 사용\n제품의 버전 체계를 calver(calendar-version)으로 전환한다고\n공유하였습니다.\ncalver는\n{4자리년(yyyy)}.{2자리월(MM)}.{patch}로 구성합니다. 이\n전환으로 블로그에서는\n바로 버전의 나이(?)를 확인할 수 있다.\n고객이 지원 서비스를 받는 기간을 이해하기 쉽다.\n새로운 기능을 추가할 것인지를 정하기 쉽다.\n는 장점을 내세웠습니다.\n이 버전 체계 변경의 목적을 고객 지원 기간을 정리하기 위해서라고\n합니다.\n지원 기간은 리눅스나 nodejs에서의 정책때문에 익숙한 단어일텐데요.\nlts라는 장기 지원 버전과 단기 지원 버전을 번갈아 출시하는\n정책을 가지고 있습니다.\nrust는 특이하게 년도별 edition을 제공하기도 합니다. 메인 버전은 장기\n지원 체계를 유지하고, 매년 실험적인 기능을 년도별 edition에 담아 그\n기간만 지원하는 정책입니다.\n두 지원 정책 모두 정기적인 릴리즈 계획과 더불어 정해진 기간동안\n유지보수 및 지원하는 정책을 취함으로써 새로운 기능 테스트와 더불어\n유지보수 리소스를 합리적으로 가져가기 위해 설계되었습니다.\nRstudio에서는 이번 버전 체계의 변화를 통해 아래와 같은 지원 정책을\n취합니다. latest 버전은 기간과 상관없이 지원하고, 과거\n버전의 경우 calver 기준 18개월 까지만 지원합니다. 지원 정책\n문서에 이러한 내용이 업데이트되었고, 관련한 공유를 블로그로 한 것\n같습니다.\n이렇게 지원 정책과 버전을 이해하기 쉽게 일치시킴으로써 버전에\n노출되는 사람에게 전달하는 정보가 강조되는 효과가 있습니다. 다른 버전\n체계와 비교하자면, 년.월 정보의 주버전과\npatch의 자동화 가능한 수버전이 특징이라 볼 수 있습니다. headver와 같이 주버전을\n하나만 관리하되 그것 조차 년월로 취급하여 배포 타이밍을 이름으로\n사용하였습니다.\n특히 많은 프로젝트가 릴리즈 주기를 가지고 있다는 점에서, 그리고 주기\n단위로 주, 부 버전을 올리는 계획을 세운다는 점에서 calver는\n더욱 사용자 지향적 버전 체계라는 생각이 들었습니다.\nbnver\n저 나름대로 새로운 버전 체계를 생각해보게 되었습니다. 물론 headver처럼 semver 호환까지는 고려하지\n못했지만, 버전에 개발자와 운영자에게 유용한 정보를 담으면 좋겠다고\n생각했습니다. bnver는 Branch Name Version 이란\n뜻입니다. 구성은 {Branch Name}.{yyyyMMdd}.{git short hash}\n입니다. 이렇게 하면 브랜치 이름으로 개발 버전인지, 새로운 관리 버전인지,\nmain 버전인지를 전달할 수 있습니다. yyyyMMdd는 보시는\n바와같이 날짜입니다. yyww는 개인적인 감상으로는 가독성이 떨어진다\n느꼈습니다. 지금이 몇째주 이지? 라는 걸 주단위 스프린트 같이\n사용해야지만 쉬운 방식이라 생각했거든요. 더 범용으로 사용하기에는\n년월일 방식이 효과적이라 생각했습니다. git short hash는\n아직 고민이 많습니다. 빌드 시스템들이 파이프라인이 트리거링된 git hash\n정보를 전달하는 경우가 많기 때문에 쓸모가 없다 싶다가도, 운영자 입장에선\n현재 배포된 서비스가 기대하는 버전이 맞는지 확인하는데 중요한 정보라고\n생각합니다.\nbnver의 장점이라면 모든 버전이 자동으로 동작하며, 개발자가 신경써야\n할 부분은 빌드 파이프라인이 어떤 브랜치를 받아서 동작하는지 입니다. 이미\n브랜치를 분리하여 작업하는 워크플로우가 광범위하게 사용되고 있기 때문에\n변경없이 사용할 수 있습니다.\n단점이라면 api 호환성에 대한 정보가 전혀 없다는 점 입니다. 호환성\n정보를 전달하기 위한 방법이 없는 것은 아닙니다. main 브랜치를 mainv1이나\nv1 등으로 변경해서 사용하면 됩니다. 이 정도 변경이라면 사용하기 어려울\n수 있겠다 싶긴 합니다.\n개발자에게 여러 자유도를 허락하면서 운영자에게 정보를 전달하는\n방법으로 생각해 보았습니다.\n다시 semver\nsemver의 본래 문제로 돌아가 봅시다. 3단계의 버전을 가지고 있으며 각\n버전을 개발자가 수동으로 관리한다는 것이 큰 문제입니다. headver는 수동\n관리용 버전을 1개로 줄이고, 그 조차도 간단한 정책을 취함으로써 소모적인\n논쟁을 해결합니다. bnver는 개발자와 운영자 사이의 정보 전달과 모든 버전\n자동화를 목표로 설계하였습니다. 물론 브랜치를 관리하는 것 자체가\n수동이긴 하지만, 개발자의 작업 흐름에 사용되는 동작을 활용한다는 점이\n자동의 의미를 유지합니다. 그럼 semver의 가장 큰 문제는 실제 코딩에서의\n변경에 대한 의미를 판단하여 개발자가 수동으로 관리한다는\n점이라 할 수 있겠습니다.\nsemver를 자동으로 작성할 수 있다면, 그럼 문제가 해결되는\n걸까요?\nsemantic-release\nsemantic-release-action을\n소개해주신 코딩맛집의\nMo Kweon님 감사합니다.\nsemver를 자동화하려면 어떻게 하면 좋을까요? bnver가 가진 아이디어를\n활용할 수 있을 것 같습니다. 개발자의 워크플로우내에서 semver를 조정할 수\n있는 정보를 받아서 자동으로 동작해주면 됩니다. 가장 간단하게는 코드\n변경분을 보고 semver의 어느 버전을 변경할지를 정하면 되는 것이지요.\n규칙을 정하면 가능할 것도 같으면서도 어렵다는 느낌이 듭니다.\n우선 개발자의 워크플로우에 항상 사용되는 것이 무엇인지 부터 살펴보면\n좋을 것 같습니다. 필수 단계라고 하면 2가지를 생각할 수 있습니다. 위에\n언급한 코드 그 자체가 1번이고, 두번째는 커밋 메세지 입니다.\n본 단락의 제목인 semantic-release는 정형화된 커밋 메세지를 활용하여\nsemver를 자동으로 작성해 줍니다.\n예를 들면 커밋 메세지에 BREAKING CHANGE 라는 글자가 있다면 주버전을\n올리는 식입니다.\n이 접근은 semver의 많은 부분을 해결하면서, 개발자에게 버전의 논란을\n많이 줄일 수 있는 방식입니다. 개발자는 버그 수정, hotfix, api 개선 등\n실제로 작업한 내용을 바탕으로 커밋 메세지를 작성하면 됩니다. 미리 정의한\n커밋 활동의 카테고리를 팀 내에서 합의를 하고, 그리고 그 합의된 활동\n이름이 각 semver 버전에 연동하는 것으로 작동합니다.\n이렇게 하면 개발자가 집중해야 할 것과 그것을 노출하는 방식을 분리하여\n논의점을 대표화할 수 있습니다. 예를 들어 어떤 커밋이 발생할 때 자신이\n작업한 내용이 어떤 카테고리에 속하는지는 이슈 생성때 부터 논의하거나\n정할 수 있습니다. 버전 그 자체는 개발자가 신경쓸 필요가 없는 것이지요.\n예를 들어 semantic-release-action은\nbreaking이나 revert라는 글자가 있다면 각각\n주버전과 수버전을 올리는 규칙이 기본으로 들어가 있습니다. 유명한 몇 가지\n프로젝트에서 사용하는 관례도 선택할 수 있게 되어 있습니다. 이 부분을\n그대로 사용해도 좋고, 팀 내에서 사용할 관례를 정하는 것도 좋은 것\n같습니다. 논의점을 대표화한다는 말의 뜻이기도 합니다. 어떤 단어가 커밋\n메세지에 있으면 어떤 버전을 올린다는 논의를 대표적으로 한번만 하게\n함으로써 개별 커밋때 논의할 내용을 대표적으로 논의할 수 있게\n되었습니다.\n웹 페이지에 html 이 내용과 디자인으로 분리한 것처럼 커밋메세지와\n버전표현을 분리함으로써 자동화를 달성한 것이지요.\n깃헙 액션인 semantic-release-action의\n접근이 공개 버전을 사용하는 프로젝트에서 사용할 수 있는 최선의 선택이지\n않나 싶습니다. 이 깃헙 액션은 버저닝의 고민을 커밋메세지로 전환하고,\n커밋 메세지를 잘 작성하는 것을 독려하는 효과가 있습니다. 그리고 개발자는\n태그가 무엇인지, 릴리즈가 무엇인지 신경쓰지 않을 수 있게 됩니다.\n깃의 많은 부분이 자동화보다는 명시적인 동작으로 구성된 것을 생각하면,\nsemantic-release-action는\n큰 자동화 규칙이라고 할 수 있습니다. 당장 태그가 무엇인지 몰라도 된다는\n점이 참 마음에 듭니다. 브랜치 전략과도 완전히 분리된 정책을 취하는 것도\n중요한 설계 관점이라고 생각합니다.\n배포 담당자로써 무엇이\n좋은가?\n사실 배포 담당자는 명시적인 버전이기만 하다면 나머지는 작은 문제일 수\n있다고 생각합니다. 다만 광범위하게 퍼져있는 semver를 자동화를 통해 자체가\n가진 문제를 해결할 수 있다면 가장 효과적이겠다 생각하고 있습니다. headver는 결국 버전을 3개에서\n1개로 단순화함으로써 문제를 해결한 것이라고 생각이 들구요.\nbnver 또한 비슷한 전략입니다만, 그 조차 개발자의 깃\n워크플로우에 의존하게 함으로써 자동화에 초점을 맞춘 것이라 생각합니다.\n가장 큰 단점으로 main 브랜치라는 그간의 관례를 버려야 할 수도 있는\n결정이라는 점이라 어떻게 하는게 좋을지 고민하게 되었습니다. 이때 semver의 자동화가 가장 합리적인\n선택이라는 생각이 듭니다. 물론 팀내에 어떤 커밋 활동이 있는지 카테고리를\n정하고, 각 카테고리를 어떤 semver 버전을 올리는데 사용할지를\n정해야 하긴 합니다만, 이 부분의 의사 결정을 중앙화함으로써 발산해버릴\n논의를 빠르게 끝내고 활용할 수 있다는 장점이 있습니다.\nR 패키지 개발에서\n어떻게 사용하면 좋을까?\n그대로 사용해도 좋다고 생각합니다. 다만 usethis 패키지와 pkgdown 패키지의 활성화로\nNEWS.md 작성이 보편화된 상황인데요. 이 부분까지 커밋 메세지로 자동화하는\n것이 어떤가 하는 생각이 들었습니다.\n명시적으로 작성하길 선호한다면, 최소한 NEWS.md와 github release가\n동기화되는 정도는 필요하다 생각이 드네요. 한번 r-lib의 action 패키지에\nexample로 제안해 봐야겠습니다.\n긴 글 읽어주셔서 감사합니다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/131734519-de76f53d-30c4-4bd5-9e9b-9fc46f6614e8.jpg",
    "last_modified": "2022-11-27T05:11:12+00:00",
    "input_file": {}
  },
  {
    "path": "post/코딩냄비와-사이드프로젝트/",
    "title": "코딩냄비와 사이드프로젝트",
    "description": "셀럽 오브 셀럽이신 박찬성님이 운영하시는 코딩냄비에 참여해보았습니다.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2021-06-12",
    "categories": [
      "sideproject",
      "codingpot",
      "community"
    ],
    "contents": "\n\nPhoto by\nHelena\nLopes on\nUnsplash\n코딩맛집\n코딩맛집은 박찬성님께서 만드신\n디스코드 커뮤니티입니다.\n다양한 사이드 프로젝트와 스터디, 집필 프로젝트가 진행중입니다.\n\n저도 pr12er\n프로젝트에 백엔드로 참여하고 있습니다. (처음만 조금 하고 계속 시간을\n못내고 있는건 함정 ㅠ) grpc를 겪어볼 수 있었기 때문에 사이드 프로젝트로\n매우 성공적인 경험이었습니다.\n다른 스터디 프로젝트에서도 제가 아는 부분을 공유함으로써 스스로\n정리하는 효과도 있었습니다. learning-go와 ci-cd에 아는 내용을 피드백하고\n있습니다. 덕분에 upx가 런타임 메모리를 희생해서 바이너리 크기를 줄인다는\n사실도 알게 되었습니다.\n효과적인 R 프로그래밍 번역 때도 하드캐리 해주신 권경모 님께서 여기서도\n하드캐리 해주시고 계십니다. 덕분에 정말 많은 공부를 하고 있습니다.\n찬성님과 경모님이 활동하시는 걸 보면 반성도 많이 하게 됩니다.(ㅎㅎ)\n코딩맛집은 다른 대단한\n분들도 많습니다. 이수정님은\n의료계에 계시면서도 배움을 멈추지 않으십니다. 특히 딥러닝과 데이터에\n관심이 많으셔서 계속 좋은 질문과 의견 주시고 계십니다. pr12er 프로젝트에서의\n다양한 의견은 넓은 식견을 짐작케 합니다.\n벌써 코딩냄비 조직이\n생기더니 프로젝트 저장소가 마구마구 만들어지고 있습니다. 어느새\n블로그까지 생겼네요. 첫블로그\n글인 go의 도커파일에 대한 분석내용과 okteto 서비스 소개가\n인상적입니다.\n코딩맛집의 장점은 빠른 피드백과 작은 개선입니다. 이 부분은 제가 일을\n하면서도 꼭 배워야 하는 자세라고 생각이 드네요.\n이런 멋진 커뮤니티에 참여하고 싶으시면 코딩맛집 링크를 클릭해주세요.\nhttps://discord.gg/HGPnfzDdkG\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/121763544-dd57d600-cb77-11eb-9faa-f3f197f28bbd.jpg",
    "last_modified": "2022-11-27T05:11:09+00:00",
    "input_file": {}
  },
  {
    "path": "post/클하-데이터-팔아서-먹고-살-수-있나요/",
    "title": "[클하] 데이터 팔아서 먹고 살 수 있나요",
    "description": "클럽하우스 요약: 데이터로 먹고 사는 방법들을 이야기해봤습니다.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2021-06-09",
    "categories": [
      "클럽하우스",
      "박박사",
      "데이터",
      "100초토론",
      "data"
    ],
    "contents": "\n\nContents\n데이터를 팔아서 먹고 살 수\n있나요?\n\n\nPhoto by\nEmily\nMorter on\nUnsplash\n클럽하우스에서 모더레이터를 조금씩 해보고 있습니다. 정기로 스케줄\n잡고 하면 좋을 것 같은데 못하고 있습니다. 핑계를 대보자면 할 말이\n많겠지만, 아직 잘 모르겠네요.\n아무튼! 오늘은 새로운 시도를 공유합니다. 제가 100초\n토론 이라는 클럽을 만들고, 여러 주제로 대화를 나누고 있습니다.\n이번에 처음 토론 내용을 정리해서 블로그에 써보려고 합니다.\n데이터를 팔아서 먹고 살 수\n있나요?\n\n먼저, 여러 분들이 참여해서 공유해준 이야기 임을 밝힙니다.\n\n날씨 데이터\n당장 데이터 그 자체로 판매가 되고 있는 것으로 날씨 데이터를 이야기\n해주셨습니다. 날씨 데이터는 보험 등의 분쟁에서 사용됩니다. 정확한 과거\n데이터 저장은 이런 다른 산업과의 연계로 돈이 됩니다. 계속된 시계열\n데이터로 돈을 벌고 있는 사례라고 할 수 있습니다.\n박박사 띵크!\nIBM의 웨더컴퍼니가 대표적이라고 할 수 있겠습니다. 법적인 이슈가 있는\n데이터를 정기적으로 수집해서 판매하는 bm이 가능할 것으로 보입니다. 바로\n머릿속에 떠오른 것은 기사나 기사에 달린 댓글이었는데요. 유튜버들이 올린\n영상들도 가능할 것 같습니다. 이 부분은 명예훼손 등의 증거가 되기 때문에\n가능할 것 같습니다.\n딥러닝 학습 데이터\n딥러닝은 이제 명실상부한 ai를 대표하는 기술이 되었습니다. 그로 인해\n새로운 산업이 만들어 지고 있는데, 바로 학습용 데이터 공급 사업입니다.\n이미 데이터 라벨링은 새로운 인형 눈붙이기다 라고 하면서 조명을 받고\n있었는데요. 클럽하우스 방에서는 2가지 특수한 분야에 계신 분들이 사례를\n소개해 주셨습니다. 하나는 방위산업 이었고, 다른 하나는\n의료산업이었습니다.\n방위 산업은 딥러닝용 데이터를 수급하기 위해서 보안 관련 법을 준수해야\n한다고 합니다. 의료 산업은 아무래도 개인 정보 보호법을 준수해야 하구요.\n그래서 학습용 데이터가 다른 일반 분야에 비해서 비싼 편인 것\n같습니다.\n의료의 경우는 희소 데이터 문제도 있는데요. 개인정보 문제도 있겠지만,\n이 부분을 생성 모델로 해결해서 데이터를 공급하는 스타트업도 있다고\n합니다.\n박박사 띵크!\n확실히 데이터를 파는데 제가 이해하기 쉬운 분야였습니다. 법적인 이슈로\n특별히 비싼 데이터가 필요한 산업도 있다는 부분이 재미있었습니다. 다른\n분야 중에도 비슷한 문제가 있지 않을까 싶네요.\n설문 데이터\n큰 설문 대행 회사에서 일하시는 분이 내용을 공유해주셨습니다. 우선\n기본적인 bm은 패널들에게 설문을 포인트를 통해 수집하여 설문 결과를\n원하는 고객사에게 전달합니다. 이때 설문지 작성 컨설팅, 추가 설문 등이\n돈을 버는 부분인 것 같습니다.\n\n패널이란 원래 위원회라는 뜻입니다. 여기서는 설문 회사에서 모집해 둔\n설문을 작성할 수 있는 후보 사람들을 뜻합니다.\n저에게는 사람이 입력하는 것에 대한 불신이 좀 있는 편인데요. 아마 설문\n조사에 대해서도 비슷한 문제 제기를 해봤습니다. 위 회사는 업력이 충분한\n만큼 이런 문제를 해결하려는 많은 장치를 가지고 있었습니다. 예를 들어,\n지속적으로 성실하게 응답하는 패널인지는 경향으로 가질 수 있는 데이터여서\n처리할 수 있다고 합니다.\n고객사에서 300명, 500명으로 설문을 요청하기도 하는데요. 현재는\n1,000명, 3,000명씩 설문 조사를 의뢰한다고 하네요. 300명 정도로는 지역별,\n연령대별, 성별 등으로만 나눠도 개별 샘플이 매우 적어지기\n때문이랍니다.\n박박사 띵크!\n설문에 큰 비용이 발생하던 때 부터 서베이라는 분야는 계속 데이터를\n판매해 오고 있는 것 같습니다. 사람의 마음을 기계로 바로 뽑아내지 못하는\n이상, 앞으로도 유망한 분야라고 생각합니다. 특히 사람의 입력을 보정하기\n위한 끊임 없는 노력이 결국 경쟁력을 만들지 않을까 싶네요.\n상품 리뷰\n현재 이커머스 분야가 계속 성장하면서 결국 리뷰 텍스트 데이터가 가치가\n높아질 것 이라고 전망하신 분이 있었습니다. 이것은 현재 판매가 된다기\n보단 예상이 있었고, 그렇게 이야기는 끝나고 말았습니다.\n박박사 띵크!\n아마 텍스트 자체가 돈이 되기는 어려워 보입니다. 보통 리뷰 텍스트를\n공개로 노출하는 것이 판매에 큰 영향을 미치기 때문입니다. 아마 재가공해서\n다른 정보를 뽑아내던지, 필터를 제공하던지 하는 모델은 가능할 것\n같습니다.\n유전체 데이터\n개인의 유전체를 분석해주는 사업이 나타나고 있습니다. 향후의 질병\n가능성, 비만, 대머리 등을 추정해 줍니다. 이 분석 의뢰도 돈을 받는\n서비스인데요. 유전체 데이터를 판매하는 사업도 있다고 합니다.\n박박사 띵크!\n간단히 검색해보니 유전체\n가명정보에 대해서는 아직 결정되지 않은 것 같습니다. 유전체 자체가\n꽤나 거대한 개인정보를 담고 있기도 하고, 가명화 처리 방법이 추가로\n개발되어야 한다는군요. 가명화 판매 보다는 아직 사용 동의 판매의 형태를\n취하고 있는 것 같네요. 새로운 시대의 건강 관리 및 예방조치여서 앞으로\n시장은 점점 커질 것으로 보입니다.\n블록체인 데이터\n블록체인은 17년 붐때부터도 소위 ICO등을 통해 데이터 주인에게 권한을\n돌려주자는 제안이 많이 나타났습니다. 클하 방에서 자신의 사업 아이템을\n소개해주신 분은 꽤 자주 제가 얼굴을 뵌 분인데요. 데이터를 중앙집중\n관리하지 않는 방식을 제안하셨습니다. 각 데이터 생산 주체(예>\n스마트폰)가 데이터를 보유하는 방식인데요. 중앙에서는 각 클라이언트에\n개인을 식별할 수 없는 데이터만 쿼리해 오는 방식입니다. 아마 쿼리당\n보상이 설계되어 있을 것 같은데요.\n제 스마트폰에 앱을 설치해두고, 스마트폰에만 데이터를 쌓도록 합니다.\n그리고 쿼리 요청자가 예를 들어 강남역에 1월 17일에 있었던 사람이라고\n찾으면 몇명이라는 집계 데이터를 얻을 수 있죠. 개인정보 침해나 동의\n문제를 많이 해결하면서도 필요한 데이터를 제공하는 사업을 진행할 수\n있습니다.\n박박사 띵크!\n새로운 시대의 설문조사 같다는 인상을 받았습니다. 마치 연합 학습에서\n실제 학습용 데이터는 개별 클라이언트에 두고 학습 파라미터만 전송하는\n방식이 떠올랐는데요. 응용할 수 있는 다른 방법들도 있지 않을까 싶습니다.\n한가지 우려는, 최근의 스마트폰은 각 앱이 사용자 정보를 보기 점점 어렵게\n만들고 있다는 점인데요. 전에는 확보할 수 없었던 혹은 비용이 매우 높았던\n데이터를 얻을 수 있는 통로로 활용 가능해 보입니다.\n상권 분석\n직접 데이터를 판매하는 것은 아니지만, 데이터를 가공하여 지표를\n판매하는 산업이 있습니다. 상권 분석이 가장 대표적일텐데요. 카드 사용\n데이터, PG사의 영수증 데이터, 통신사의 인구 이동 통계량 등을 사용해서\n지표를 산출합니다.\nPG 업계에서 일하시는 분의 말에 따르면, 마이데이터 사업 때문에 업종\n추천 api를 판매하기도 한답니다. 가게 이름은 공개되어 있지만, 업종은\n카드사 마다 다르거나, 정보로써 가공하기가 쉽지 않은데요. b2b 판매로\n가능한 api 사업으로 보입니다.\n박박사 띵크!\n다행히 카드사 경험도, 포인트 적립 스타트업 경험도 있어서 이해하기\n쉬운 분야였습니다. 특히 저도 영수증 정보의 중요성을 계속 생각하고\n있었는데요. 제가 영수증 정보 수집 사업을 포기한 이유가 몇 가지 있습니다.\n하나는 그냥 총액이 나오는 영수증이 아닌, 항목이 표기되는 POS기가 설치된\n매장이 우리나라의 카드 결제기 중 10% 정도만을 차지합니다. 물론 알아볼\n당시의 값이니 지금은 달라졌겠지만 말이죠. 그리고 영수증 데이터가\n생각보다 중구 난방인데다, 데이터가 잘리는 경우도 매우 많습니다.\n이런 여러가지 역경을 뚫고 사업화를 진행하시는 많은 분들께 박수를\n보냅니다. 저는 기계과로 학사를 시작해서 그런지 데이터의 대표성이나\n완전성을 너무 따지게 되더라구요.\n후기\n이번 주제는 저도 많이 배우고, 사람들과 자유롭게 이야기 할 수 있어서\n매우 좋았습니다. 특히 돈을 버는 내용이다 보니 다양한 분이\n관심가져주시고, 이야기 나누어 주셨습니다. 앞으로도 좋은 내용으로 방을\n열고, 지속적으로 이렇게 공유해 나가도록 하겠습니다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/120314187-ee058200-c315-11eb-8043-de1e53e78958.jpg",
    "last_modified": "2022-11-27T05:11:11+00:00",
    "input_file": {}
  },
  {
    "path": "post/KoNLP-설치-방법/",
    "title": "KoNLP 설치 방법",
    "description": "install.packages(\"KoNLP\", \n  repos = \"https://forkonlp.r-universe.dev\",\n  INSTALL_opts = c(\"--no-multiarch\")\n)",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2021-06-01",
    "categories": [
      "KoNLP",
      "install",
      "install.packages",
      "R-universe"
    ],
    "contents": "\n\nContents\n1. jdk 설치\n2. KoNLP 설치\n전체 코드\n조심해야 할\n점\n\n\nKoNLP는 한국어 형태소 분석 R 패키지입니다. KoNLP\n패키지는 java로 제작된 한나눔 형태소 분석기를 사용합니다. java를\n사용하기 때문에 크게 2가지 단계로 패키지 설치를 진행합니다. jdk란 자바\n개발 킷의 줄임 표현으로 자바 언어를 사용하기 위해 설치하는\n프로그램입니다.\njdk 설치\nKoNLP 패키지 설치\njdk의 설치는 원래 어려웠습니다. KoNLP 패키지가 2020년 2월 1일부로\ncran에서 내려가서 설치가 어려워졌습니다. 두 단계 모두 접근하기 좋은\n방법을 소개합니다.\n1. jdk 설치\njdk 설치는 확인과 설치 단계로 진행합니다.\n1.1 jdk 설치 확인\n기존에 잘 동작하는 jdk가 설치되어 있는지 확인합니다. 확인은 rJava 패키지의 초기화 함수를\n사용합니다. rJava 패키지는\nR에서 자바 프로그램을 사용하기 위한 패키지입니다.\ninstall.packages(\"rJava\")\n초기화 함수로 설치되어 있는지 확인합니다.\nrJava::.jinit()\n[1] 0\n0 이라는 출력이 없을 수도 있습니다. 위 함수를 실행하고\n에러가 없다면, jdk가 잘 설치되어 있는 것입니다. 그러니 jdk 설치 단계를\n건너서 2. KoNLP 설치 단계로 가세요.\n1.2 jdk 설치하기\njdk를 설치하기 위해 multilinguer\n패키지를 사용합니다. jdk는 다운로드하고, 설치하고, 실행 경로를 등록하는\n과정으로 설치합니다. multilinguer\n패키지는 jdk를 설치하는 복잡한 과정을 대신해줍니다.\ninstall.packages(\"multilinguer\")\nmultilinguer::install_jdk()\n\nmultilinguer::install_jdk() 을 실행하면 R 새션을 재시작합니다.\n\njdk 설치 확인을 한번 더 해보고, 동작하면 아래 KoNLP 설치 과정으로\n넘어갑니다.\n2. KoNLP 설치\n아래 코드로 KoNLP 패키지를 설치하세요.\ninstall.packages(\"KoNLP\", \n    repos = \"https://forkonlp.r-universe.dev\",\n        dependencies = TRUE,\n    INSTALL_opts = c(\"--no-multiarch\")\n  )\n이제 사용해서 잘 동작하는지 확인하겠습니다.\nlibrary(\"KoNLP\")\nSimplePos09(\"안녕하신가요?\")\n설명\n현재 KoNLP 패키지는 CRAN에서 내려가 있는 상태입니다.\n그래서 다른 패키지 저장소인 r-universe.dev에 빌드에서\n업로드를 해둔 상태입니다. r-universe.dev는 사설 패키지\n저장소라고 보시면 될 것 같습니다.\n그래서 install.packages() 명령에 추가 저장소 주소를\n더하는 줄을 추가하였습니다. 다른 패키지들은 기본 CRAN을 사용하므로 함께\n작성하였습니다. 패키지 설치시 32비트와 64비트를 모두 설치하는 것이 기본\n동작인 듯합니다. 현재 java 64bit 만 설치되어 있으므로 기본 64bit\n패키지만 설치하라는 옵션을 추가했습니다.\n전체 코드\n설치만 진행하는 전체 코드를 정리합니다. 꼭 한 줄 씩\n실행해주세요.\ninstall.packages(\"multilinguer\")\nmultilinguer::install_jdk()\ninstall.packages(\"KoNLP\", \n    repos = \"https://forkonlp.r-universe.dev\",\n    INSTALL_opts = c(\"--no-multiarch\")\n  )\n조심해야 할 점\nmultilinguer\n패키지의 install_jdk() 함수는 기존에 jdk가 설치되어 있는지\n등을 확인하지 않습니다. 환경 변수를 건드리는 동작이 있기 때문에 기존에\n설치된 부분이 꼬여서 동작하지 않을 수 있습니다. 혹시 문제가 발생하면 패키지\n이슈에 알려주세요.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/120210866-3a47b800-c26b-11eb-928e-f980c286a03d.jpg",
    "last_modified": "2022-11-27T05:09:36+00:00",
    "input_file": {}
  },
  {
    "path": "post/좋은-코드라는-블로그-글을-읽고/",
    "title": "좋은 코드라는 블로그 글을 읽고",
    "description": "좋은 코드는 잘 읽히는 코드라는 다른 블로그 글을 봤는데, 아마 그럼 영어 네이티브가 유리하려나 라는 생각이 들었습니다.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2021-06-01",
    "categories": [
      "thoughts",
      "OOP",
      "goocode",
      "english"
    ],
    "contents": "\n\n개발을 잘 하고 싶다는 생각을 계속하고 있어서 관련 글도 열심히\n찾아보고, 책도 열심히 뒤적뒤적하는 중이다. 이 와중에 좋은\n코드라는 블로그 글을 보게 되었다.\n\n나에게 뼈때리는 문구를 발췌해보자면\n\n대부분의 사람들은 동작하는 코드를 만들수 있다. 어떤 사람들은 \n동작하는 코드를 만들수 있다. 그보다 적은 수의 사람들은 \n코드를 만든다.\n\n어쩜 이렇게 명언들을 쏟아내셨는지.\n\n코드를 만들때는 각자 자기의 성을 짓는것과 같다. 그런데 몇년후 자신이\n만든 성에 들어가서도 우리는 길을 잃는다. 현실에서 회사는 남이 만든\n초가집을 성이라 우기며 아름다운 탑을 몇개 더 붙이라고 요구한다.\n\n블로그 주인님이 생각하는 좋은 코드에 대한 정의는\n당연하게 읽히는 코드 라고 한다. 그 와중에 좋은 코드를 만든\n사람의 예시도 들고, 반대의 경우도 설명한다.\n\n이제 막 학교를 졸업한 어린이(?) 엔지니어들의 코드는 읽으면서 감탄사가\n나온다. 여과해  이 정도로\n표현해야겠다.\n\n이렇게 열심히 읽고 이해하려고 노력하다가 갑자기 생각이 들었다. OOP는\n주어와 동사로 읽히는 문법을 표현하려고 노력한 걸거다. 한국어는 물건을\n주어화하는 건 거의 없다. 영어는 꽤 있다고 알고 있다. 그럼 영어\n네이티브인 사람들이 더 생각하기 수월하지 않을까? 다른 사람들이 어떻게\n생각할지 궁금해서 글을 남겨둔다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/120228661-881de980-c286-11eb-8ed0-86d198bbf21f.jpg",
    "last_modified": "2022-11-27T05:11:08+00:00",
    "input_file": {}
  },
  {
    "path": "post/distill로-옮깁니다/",
    "title": "distil로 옮깁니다",
    "description": "드디어 블로그를 단순하게 유지하기 위해 distill로 옮깁니다.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2021-01-28",
    "categories": [
      "anounce",
      "blog"
    ],
    "contents": "\n\nContents\nblogdown의 대안을 찾아서\ndistill 소개\n\n\nblogdown의 대안을 찾아서\nblogdown은 꽤 오랫동안 사용한 블로그 패키지다. 여전히 좋은 패키지라고\n생각한다. blogdown 또한 rstudio에서 관리하며,\n최근 버전\n1.0.0 을 출시했다.\n대안이 필요한 이유는 blogdown 자체의 문제만은 아니지만, 여전히\n문제다.\n한글 윈도우 rstudio 에서 빌드시 경로 문제가 발생할 때가 있다.\n캐쉬 동작을 이해하지 못해서 빌드 결과가 다르다.\nrstudio가 글 작성 도구로써 매우 좋다고 할 수 없다.\nrstudio가 글 작성 도구로써 매우 좋다고 할 수 없는 이유는, 우선 매우\n무겁기 때문이다. 오죽하면 Rmd 전용 글 작성 도구만 따로 만들까 고민하던\n적이 있기도 하다.(지금도 유효하다.)\ndistill 소개\ndistill 은 rstudio 의 패키지로 동명의 논문 사이트인 distill의 출력 포멧을 기준으로 만든\n블로그 패키지다.\n\nDistill for R Markdown is based on the Distill web framework, which\nwas originally created for use in the Distill Machine Learning Journal.\nDistill for R Markdown combines the technical authoring features of\nDistill with R Markdown, enabling a fully reproducible workflow based on\nliterate programming.\n\n패키지에서 소개하는 강점은 아래와 같다.\n모바일 최적화\n기술 문서 작성을 위한 기술들(ex> LaTeX, footnotes)\n유연한 그림 출력\n유연한 테이블 출력\n블로그와 웹사이트 구조 지원\n사용하면서 느낀 장점은 많은 표준 도구를 도입하여 편리하다.\n댓글, google analytic 붙이기, 쿠키 허용 팝업, 라이선스 명시가\n설정으로 해결된다. 아주아주아주아주 좋았다.\n아직 해결해야 하는 건 에드센스 붙이는거다. 얼마 되지도 않는 광고\n수입이 들어오지도 않고 있는 상태다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/119273060-17524e00-bc44-11eb-9d8a-e7feb5063005.png",
    "last_modified": "2022-11-27T05:09:42+00:00",
    "input_file": {}
  },
  {
    "path": "post/rtips-불리는-패키지가-없습니다-해결-방법/",
    "title": "[Rtips] 불리는 패키지가 없습니다 해결 방법",
    "description": "패키지 설치가 잘 진행되지 않으시면 한번 시도해보세요.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2020-01-11",
    "categories": [
      "R",
      "Rtips",
      "library",
      "package",
      "tech"
    ],
    "contents": "\n\n\n이라고 불리는 패키지가 없습니다.\n이 에러는 library()함수를 사용할 때 나오는 문구입니다.\n정확히는 패키지가 설치되어 있지 않다고 알려주는 것이지요. 그래서 이\n문제를 해결하는 가장 간단한 방법은 패키지를 설치하는 것입니다. 예를 들어\nvars 라는 이름의 패키지를 사용해 보겠습니다.\ninstall.packages(\"vars\")\nlibrary(vars)\n언제나 깔끔하게 설치되면 좋겠지만, 문제가 발생하는 경우가 있습니다.\n사실 경험이 부족한 입장에서는 인스톨 과정이 문제 없이 잘 끝났는지\n인지하는 것도 쉬운 일이 아닙니다. 아래 스크린샷을 그 대표적인\n예시입니다.\n\n커뮤니티에 조진형 님이 올려주신\n질문입니다.\n스크린샷을 보아하니 설치 명령은 수행하셨지만 모종의 이유로 설치\n과정에서 에러가 났습니다. 에러에 설명이 되어 있기는 한데, 영어다보니\n이해하기가 쉽지 않습니다.\n필요한 문구는 library(vars) 명령어 이전 줄 중에 가장\n마지막 줄입니다.\n\nTry removing 'c:\\Users\\enieh\\Documents\\R\\win-library\\3.6/00LOCK'\n\n저 언급한 경로의 00LOCK 파일을 지우고, 다시 설치해보라는\n것인데요. 지금 설치가 실패한 패키지는 vars이긴 합니다만,\n의존성이 있는 zoo 패키지가 실패한 것입니다. 그래서\n00LOCK 파일을 지우면서도, 그 폴더가 패키지들이 설치되는\n곳이니 zoo 폴더를 함께 지워줍니다. 이 후에 다시 패키지를\n설치하면 문제없이 설치될 것 입니다.\n문제가 무엇이었나?\n항상 그런 것은 아니지만, zoo 패키지가 메모리에 올라가\n사용 중인 상태였을 수 있습니다. 순수 R 코드로 이루어진 패키지들에게\n생기는 문제는 아니고, cpp가 함께 있는 패키지에서 이런 문제가 있을 수\n있는데요. 패키지를 메모리에 올려 사용하고 있는 상태에서는 패키지 폴더를\n삭제할 수 없습니다. 파일을 사용 중인 상태이기 때문이죠.\n그래서 보통 패키지를 설치하려고 할 때 몇몇 패키지를 불러온 상태라면\n재시작을 하고 설치할꺼냐고 물어보기는 합니다. 모든 잘못된 동작을\n막기에는 부족한 것 같습니다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106514270-651d3c00-6517-11eb-8b5f-54dfb9c3470b.png",
    "last_modified": "2022-11-27T05:10:07+00:00",
    "input_file": {}
  },
  {
    "path": "post/correttor-r을-위해서-java를-설치해보자/",
    "title": "[correttor] R을 위해서 JAVA를 설치해보자",
    "description": "`multilinguer::install_java()`를 쓰세요.(MacOS는 컴퓨터 비밀번호가 필요)",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2019-08-10",
    "categories": [
      "R",
      "java",
      "rJava",
      "package",
      "correttor"
    ],
    "contents": "\n\n한줄요약\nmultilinguer::install_java()를 쓰세요.\n앞서 R에서 python을 설치해서 사용하기 위해\nconda를 설치하는 방법을 살펴봤습니다. 이번에는\njava입니다.(두둥)(엄근진)\njava를 설치하기 위해서 corretto 배포판을\n선택했습니다. corretto\n배포판의 설치를 지원하는 correttor 패키지는\nWindows 32 bit, 64 bit, MacOS를 지원합니다.\nconda4r\n패키지와 마찬가지로 correttor 패키지는 multilinguer\n패키지군의 일원입니다.\nmultilinguer\n패키지가 직접 인스톨 코드 등을 가지도록 개발하고 있습니다.\n이 포스트는 두말 않고 진행해보겠습니다.\n\n\ninstall.packages(\"multilinguer\")\nlibrary(multilinguer)\ninstall_java()\n\n\n\ninstall_java() 함수의 목표는 rJava를 설치하여 문제 없이\n동작하게 만드는 것입니다. install_java() 함수는 현재\n컴퓨터에 java가 설치되어 있는지 확인합니다. 없다면 설치를\n시작합니다. Windows 에서는 사용자 계정 별 폴더에 corretto\n폴더를 만들고 저장합니다. 그리고 유저 환경변수를 설정합니다. MacOS\n에서는 /Library/Java/JavaVirtualMachines/ 경로에\njava11 버전으로 명시하여 저장합니다. 말씀 드린 것 처럼,\nMacOS는 앞의 위치에 설치하기 위해서 컴퓨터 비밀번호가 필요합니다.\n문제있는 동작은 없으니 걱정되시면 소스를\n확인해 주세요.\n앞의 설치는 마지막에 재시작을 하고 rJava 패키지를\nbinary로 설치한 후 다시 재시작합니다. .jinit()\n함수를 수행하면서 마무리를 하기 때문에 문제가 있다면 이 단계에서 에러를\n출력합니다. 혹시 에러가 발생하면 꼭 알려주세요.\n위 설치로 바로 사용해 볼 수 있는 패키지는 역시 KoNLP 입니다.\n\n\ninstall.packages(\"KoNLP\")\nlibrary(KoNLP)\n\n\n\n## Checking user defined dictionary!\n위 메세지가 실행된다면, 자바를 사용하는 R 패키지를 문제없이 사용할 수\n있는 상태가 되었다는 뜻입니다.\n업데이트: 문제없이 cran 버전이 동작하고 있습니다. 현재\nMacOS에서 R 버전이 3.5.X 버전일 때 문제가 있는 것을\n파악했습니다.\nmultilinguer\ncorrettor 패키지\n개발에 도움을 주신 많은 분들께 다시 한번 감사드립니다. 빨리 여러 곳에서\n안정적으로 동작하는 패키지가 되도록 노력하겠습니다. 감사합니다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106564199-45663200-6570-11eb-894c-d89fa3c860f4.png",
    "last_modified": "2022-11-27T05:09:41+00:00",
    "input_file": {}
  },
  {
    "path": "post/conda4r-r을-위해서-conda를-설치해보자/",
    "title": "[conda4r] R을 위해서 conda를 설치해보자",
    "description": "`multilinguer::install_conda()`를 쓰세요. (응?)",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2019-07-31",
    "categories": [
      "R",
      "python",
      "reticulate",
      "conda",
      "conda4r",
      "package"
    ],
    "contents": "\n\nContents\n업데이트\nconda4r 패키지 개발을\n중단합니다.\n\n\n업데이트\nreticulate::install_miniconda() 를 사용해주세요.\nconda4r 패키지 개발을\n중단합니다.\nreticulate\n패키지에 install_miniconda() 함수가 포함되기로 결정되어서\n패키지 개발을 중단합니다.\nmultilinguer\n패키지의 install_conda() 함수는 reticulate 패키지의\n함수를 사용하는 것으로 변경 중입니다.\n블로그 내의 함수 동작도 우선은 전부 멈춰두었습니다. 이후 reticulate 패키지의\ncran 버전에 포함되면 위 이야기대로 동작하도록 하겠습니다.\n한줄요약\nmultilinguer::install_conda()를 쓰세요. (응?)\nconda는 다양한 언어를\n위한 패키지 매니저로 개발중입니다. anaconda로 익히 알려지면서 python\n배포판의 일종으로 쓰이고 있습니다. 최근 파이썬은 딥러닝 프레임워크들의\n인기에 힘입어 많은 사람들의 관심을 받고 있습니다. 개발과 연구라는 두\n마리 토끼를 잡기 위해서 많은 프레임워크가 파이썬으로 개발되었습니다.\n이런 환경에서 R은 취약한 자체적인 프레임워크를 해결하기 위해 python을\n품는 결정을 합니다. 그 결과로 나온 부산물이 reticulate\n패키지입니다. Rstudio 팀은 tensorflow와 keras를 이용하기 위해서\nreticulate 패키지를\n개발합니다. 이는 놀라운 생산성으로 이어졌습니다. R 패키지는 python\n패키지에서 api 변경만 따라가면 되는 상황이 되었습니다. 내부 로직을 전부\npython 패키지에 위임함으로써 R 패키지의 유지보수관리에 혁신적인 효율성을\n확보한 셈이죠.\n이 때 중요하게 권장하는 사항이 conda 패키지 매니저를\n사용하는 것입니다. 헌데 R 사용자에게 다른 개발 언어를 설치하는 것은\n어려운 일일 수 있습니다. 그 중에 conda 패키지 매니저는 매우\n쉬운 축에 속합니다…만, 뭔가 화면 하나하나, 옵션 하나하나 어떤 것인지\n아는 것은 확실히 어려운 일입니다. 그런거 다 알꺼면 왜 R로\n스크립팅하나요…\n그래서 conda4r 패키지를\n준비했습니다. conda4r\n패키지는 Windows 32bit, 64bit, MacOS, Linux를 지원하는 miniconda를\n설치하는 함수를 제공합니다.\n설치 방법\nconda4r 패키지는 R\n사용자를 위한 다른 개발 언어 설치를 지원하는 프로젝트인 multilinguer\n패키지군의 일원입니다. conda4r 패키지는\n인프라로써 설치를 위한 개별 함수들을 제공합니다. multilinguer\n패키지는 has_conda() 함수를 제공합니다.\nhas_conda() 함수는 제가 할 수 있는 한의 테스트를 통해서\nconda가 동작하는 상태를 만드는 것을 목표로 합니다.\n\n\n# install.packages(\"remotes\")\nremotes::install_github(\"mrchypark/multilinguer\")\n\n\n\n사용법\n위에 설명드린 대로 has_conda() 함수를 실행하면\n끝입니다.\n\n\nlibrary(multilinguer)\nhas_conda()\n\n\n\n그럼 기존에 설치된 conda가 있는지 확인합니다. 있으면\n그대로 종료, 아니라면 conda 설치를 시작합니다. 우선\n다운로드 받고, 표준 경로에 miniconda를 설치합니다.\nWindows에서 ssl 관련된 문제가 있어 수정합니다. 그리고\nconda 버전을 업데이트 합니다. 버전 업데이트를 진행하고 싶지\n않다면 update 옵션을 FALSE를 주면 됩니다. 잘\n됬는지 확인하기 위해 conda를 사용하는 패키지를 설치, 실행해\n보겠습니다.\n\n\nremotes::install_github(\"haven-jeon/KoSpacing\")\n\n\n\nKoSpacing\n패키지는 KoNLP 패키지의 개발자이신 고감자님이 만든 띄어쓰기\n패키지입니다. python의 keras 패키지를 사용하기\n때문에, 패키지를 사용하기 위해서 reticulate 패키지와 conda가 필요합니다.\n\n\nlibrary(KoSpacing)\n\n\n\nKoSpacing\n패키지는 버전이 0.1.1 이상인지 꼭 확인하셔야 합니다. 이전 버전은 설치에\n문제가 있어서 동작하지 않습니다.\n\n\npackageVersion(\"KoSpacing\")\n\n\n\nKoSpacing\n패키지의 설치에서는 conda가 필요하지 않습니다만,\nlibrary(KoSpacing)을 실행시 나오는 안내 문구처럼\nset_env() 함수를 실행할 때 필요합니다. 앞서\nhas_conda()를 잘 실행하셨다면 이제 set_env()\n실행할 때 문제가 생기지 않으면 좋을 것 같습니다.(응?)\n\n\nset_env()\n\n\n\n아마 위에 함수가 잘 끝나면 세션을 재시작할 것입니다. 이제 동작을\n확인해보겠습니다.\n\n\nlibrary(KoSpacing)\nspacing(\"김형호영화시장분석가는'1987'의네이버영화정보네티즌10점평에서언급된단어들을지난해12월27일부터올해1월10일까지통계프로그램R과KoNLP패키지로텍스트마이닝하여분석했다.\")\n\n\n\n2019-08-10 03:28:32.102292: I T:\\src\\github\\tensorflow\\tensorflow\\core\\platform\\cpu_feature_guard.cc:141] Your CPU supports instructions that this TensorFlow binary was not compiled to use: AVX2\nloaded KoSpacing model!\n[1] \"김형호 영화시장 분석가는 '1987'의 네이버 영화 정보 네티즌 10점 평에서 언급된 단어들을 지난해 12월 27일부터 올해 1월 10일까지 통계 프로그램 R과 KoNLP 패키지로 텍스트마이닝하여 분석했다.\"\n첫 실행 이후에는 위 메세지 없이 결과만 출력합니다.\n잘 동작하시나요? 혹시라도 안되시는 분들은 댓글로 남겨주시면\n감사하겠습니다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106564003-fe783c80-656f-11eb-948f-7896c100b4db.png",
    "last_modified": "2022-11-27T05:09:40+00:00",
    "input_file": {}
  },
  {
    "path": "post/rtips-윈도우-계정-한글일때-문제-해결하기-1탄-임시-폴더-위치-바꾸기/",
    "title": "[Rtips] 윈도우 계정 한글일때 문제 해결하기 1탄 임시 폴더 위치 바꾸기",
    "description": "\"임시 폴더의 위치를 조정해서 윈도우 계정이 한글일때 생기는 문제를 해결합니다.\"",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2019-05-26",
    "categories": [
      "R",
      "Rtips",
      "temp",
      "tempdir"
    ],
    "contents": "\n\nContents\n업데이트\n2022-04-20\n\n\n업데이트 2022-04-20\nR 4.2.0 이후 윈도우 버전의 비 latin 계열 언어의 인코딩 문제가\n해결되었습니다.\n한줄요약\nTemp(임시 폴더)의 위치를 .Renviron 파일에\n써서 바꾸세요.\nKRSG에 질문글이\n올라와서 아는 내에서 해결책을 공유하고자 합니다.\n우선 공유해 주신 에러 화면을 보겠습니다.\n\n우선 hist() 함수를 사용하는데, 에러가 발생한다고 문제를\n공유해주셨습니다. 그림을 출력하기 위해서는 그림을 저장하고, 화면에\n뿌리는 과정을 진행합니다. 위 과정을 프로그램(rstudio)이 진행해 주기\n때문에 과정을 알 필요는 없는데요. 이 때 그림 저장을 임시 폴더에 합니다.\n프로그램이 기본으로 사용하는 임시 폴더의 위치는 tempdir()\n함수로 확인할 수 있습니다. 저의 컴퓨터는 아래 결과를 확인할 수\n있었습니다.\n\n\ntempdir()\n\n\n\n[1] \"C:\\\\Users\\\\MRCHYP~1\\\\AppData\\\\Local\\\\Temp\\\\RtmpkNMIVs\"\n이 위치는 윈도우의 사용자 계정 이름(mrchypark)의 하위\n폴더입니다. 저는 영어로 계정이름을 만들어서 문제 없이 동작하는데요.\n질문자의 경우 저 경로에 ??????로 되어 있는 것으로 봐서\n윈도우의 사용자 계정이 한글로 되어 있는 것 같습니다.\n가장 좋은 해결책은 윈도우 계정을 한글로 바꾸는 것이기는 한데요. 😭\n현실적으로 다시 만들어서 다시 환경을 설정하는 것은 쉬운일이\n아닙니다.\n그래서 임시 폴더 위치를 변경하는 방법을 소개합니다.\n우선 경로에 한글이 없을만한 임시 폴더를 하나 만듭니다. 저는\nC:/에 바로 만들려고 합니다.\n\n\n\nC:/rtemp 라는 폴더를 만들었습니다. 이제\nusethis 패키지를 설치합니다.\ninstall.packages(\"usethis\")\nusethis 패키지에는 R의 환경 변수를 관리하는\n.Renvron 파일을 수정할 수 있게 열어주는 함수를\n제공합니다.\n\n\nlibrary(usethis)\nedit_r_environ()\n\n\n\n그럼 .Renvron 파일을 수정할 수 있게 스크립트 창에서\n열어줍니다.\n\n이제 아래 3줄을 .Renvron 파일에 저장합니다.\nTMPDIR=C:/rtemp\nTMP=C:/rtemp\nTEMP=C:/rtemp\n\n그리고 새션 재시작(ctrl+shit+F10)을 한 후\ntempdir() 함수로 경로가 잘 변경되었는지를 확인합니다.\n이제 hist(iris$Sepal.Length) 같은 명령어로 동작하는지\n확인합니다.\n\n이 방법은 프로그램이 사용하는 임시 폴더의 경로를 바꿈으로써 문제를\n해결합니다. 그렇기 때문에 사용자의 계정 폴더를 사용하는 다른 문제에\n대해서 해결하는지 알 수 없습니다. 혹시 위 방법으로도 비슷한 에러가\n나오는 사례를 알려주시면 감사하겠습니다.\n감사합니다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106563781-a17c8680-656f-11eb-8578-fe866238dc8e.png",
    "last_modified": "2022-11-27T05:10:10+00:00",
    "input_file": {}
  },
  {
    "path": "post/josaplay-rmd로-만드는-한글-보고서의-친구/",
    "title": "[josaplay] Rmd로 만드는 한글 보고서의 친구",
    "description": "`을(를)` 이 눈에 거슬린다면 `josaplay`가 문제를 해결해 줄 겁니다.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2019-05-15",
    "categories": [
      "R",
      "josaplay",
      "package",
      "Rmd"
    ],
    "contents": "\n\n한줄요약\n을(를) 이 눈에 거슬린다면 josaplay가\n문제를 해결해 줄 겁니다.\n개인적인 일들이 많이 있어서 정신을 못차리고 있는 중입니다.\n데이터홀릭을 계속하는 만큼, R코홀릭도 좀 어떻게 해야할텐데 말이죠.\n그동안 정기 보고서를 만들 때 한글만의 문제를 해결하는 패키지가 없어서\n벼르고만 있었습니다만, 드디어 만들었습니다!\n이름하야 josaplay\n패키지입니다.\n혹시 마우스을(를) 선택하셨습니다. 같은 멘트를 보신 적이\n있으신가요? 앞의 단어가 어떤 것이 올지 결정나지 않았을 때, 그에 붙을\n조사 또한 결정나지 않습니다. 위와 같이 경우를 다 작성해두는 선택을 한\n사람들이 참 많습니다.\njosaplay\n패키지는 이 때, 앞 단어의 마지막이 모음인지 자음인지를 보고\n을/를 중 선택하여 출력해 줍니다.\n설치는 아래 코드를 사용하면 됩니다.\ninstall.packages(\"josaplay\")\n코드가 동작하는 것을 살펴볼까요?\n\n\nlibrary(josaplay)\n\njsp_gwawa(\"상품\")\n\n\n[1] \"상품과\"\n\njsp_gwawa(\"텀블러\")\n\n\n[1] \"텀블러와\"\n\njsp_eunneun(\"사랑\")\n\n\n[1] \"사랑은\"\n\njsp_eunneun(\"탁자\")\n\n\n[1] \"탁자는\"\n\njsp_iga(\"고객\")\n\n\n[1] \"고객이\"\n\njsp_iga(\"모니터\")\n\n\n[1] \"모니터가\"\n\njsp_eulleul(\"패키지\")\n\n\n[1] \"패키지를\"\n\njsp_eulleul(\"컵\")\n\n\n[1] \"컵을\"\n\njsp_iga(\"145\")\n\n\n[1] \"145가\"\n\njsp_iga(\"k146\")\n\n\n[1] \"k146이\"\n\n그럼 어떻게 쓰면 좋을까요? Rmd로 보고서 등을 작성할 때, 위처럼\n코드청크를 사용하는 것이 아닌 경우가 있습니다. 백틱(`)을 하나만 사용하는\n형식으로 인라인 코드를 작성할 수 있는데요. 이때 josaplay가\n힘을 발휘합니다.\n\n\ndata1 <- \"병아리\"\n\n\n\n\n병아리이(가) 성장하였습니다.\n\n라고 작성하는 것을\n\n병아리가 성장하였습니다.\n\n로 고치면 data1의 글자에 따라 적절한\n이/가를 선택해 출력해줍니다.\n앞으로 진행할 프로젝트에 적용할 생각을 하니 너무 즐겁네요. 한글이\n들어간 자동화 보고서를 생성할 때 꼭 필요한 인프라 패키지를 만들게 되서\n영광입니다.\n현재 josaplay는\n4개의 함수에 완성형 한글과 숫자를 커버합니다. 자음 모음의 한글이나 영어,\n특수문자는 아직 동작하지 않습니다. 영어 알파벳 발음에 대응하는 것은\n필요한 일 같다는 생각이 듭니다.\n문의나 질문 사항은 언제나 환영합니다. 댓글로 문의 주시면 제가 할 수\n있는 최대로 답변드리도록 노력하겠습니다. 감사합니다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106563544-43e83a00-656f-11eb-9629-f220d82e2792.png",
    "last_modified": "2022-11-27T05:09:45+00:00",
    "input_file": {}
  },
  {
    "path": "post/python과-r-어떤-걸-공부-해야-할까/",
    "title": "Python과 R 어떤 걸 공부 해야 할까",
    "description": "무엇이든 빨리 배울 수 있는 것으로 시작하세요.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2019-03-20",
    "categories": [
      "R",
      "Python"
    ],
    "contents": "\n\n원글\n당신이 학생이라면, 회사에 들어가기 전에 충분히 숙달할 시간과 자신이\n있다면 아무거나 해라. 두 언어 모두 기계의 효율성보다는 사람의 생산성을\n우선하는 언어다.\n당신이 취업을 앞둔 학생이라면, Python을 해라. 어떤\n직업이 되었건 R만 특화하여 명시적으로 뽑는 자리는 없지만,\n반대는 매우 많다.\n당신이 직업이 있다면, 개발일이 더 적성에 맞는 것 같다면\nPython을 배워라. Python은 범용 개발언어로서\n당신이 Python을 할 줄 안다면 결국 개발자에 가까운 일을 하게\n될 것이다.\n당신이 하는 일에 개발에 개자도 끼지 않을 것 같았는데, 그럴 기미가\n보인다면 R을 공부해라. R은 그 어떤 언어보다도\n직관적으로 이해하는 것을 중시한다. 평생 개발일은 안할 것같지만 업무에\n30-40퍼센트 미만으로 필요할 것 같다면 R은 적은 시간을\n공부하고도 많은 시간 공부한 것 같은 효과를 줄 것이다.\n당신이 머신 러닝 프로젝트를 많이 해야한다면 미안한 말이지만 둘다해라.\n데이터를 다루는데는 R이, 머신러닝 모델 개발에는\nPython이 좋다. 물론 지금 그렇다는거다. 미래를 보건데 충분한\n지원을 받는 좋은 패키지는 거의 모든 언어에서 사용하는걸 목표로 한다.\n대표적인 것이 xgboost 이다. 모두 해보고 마음가는걸 메인,\n아닌걸 서브로 공부해라.\n당신이 딥러닝을 연구할 계획이라면 이 조언이 필요치 않다.\n당신이 딥러닝을 활용해보려면 R을 해라.\nR에는 이미 훌륭하게 Keras 패키지가 좋은 회사의\n지원을 받으며 성장하고 있다. 왜 Python이 아니냐고 묻는다면\nPython을 해야하는 사람들은 이미 스스로 판단할 능력을 가지고\n있다.\n당신이 개발자라면 어떤 경우에서건 Python을 해라. 위에서\n언급했듯 R은 직관에 가까운 언어기때문에 이미 다른 문법에\n익숙해져 있다면 R은 괴상한 문법 체계인 것처럼 느껴질\n것이다.\n당신이 숫자를 다루는 일을 한다면 R을 배워라. 어떤 언어든\n부동소수점 문제나 다른 연산등의 문제에서 자유로울수 없지만,\nR은 참 많은 고려가 되어 있다.\n당신옆에 개발자가 있다면 위의 모든 것을 무시하고\nPython을 배워라. 질문에 대답을 들을 수 있는 환경은 그 어떤\n것보다 강력하다.\n페이스북에서 흥한 김에 기록용으로 포스트합니다.\n어떤 내용의 댓글도 환영합니다. 감사합니다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106563355-ff5c9e80-656e-11eb-84e0-439b14c1b9c1.png",
    "last_modified": "2022-11-27T05:09:48+00:00",
    "input_file": {}
  },
  {
    "path": "post/rtips-dbi-소스의-tbl의-요약-정보-확인하기-glimpse/",
    "title": "[rtips] DBI 소스의 tbl의 요약 정보 확인하기 glimpse()",
    "description": "src_dbi인 tbl의 str()을 확인할 때는 dplyr::glimpse() 함수를 사용하세요.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2019-01-25",
    "categories": [
      "R",
      "glimpse",
      "str",
      "tbl",
      "dbi",
      "dplyr"
    ],
    "contents": "\n\n한줄요약\nsrc_dbi인 tbl의 str()을 확인할 때는 dplyr::glimpse() 함수를\n사용하세요.\nstr() 함수는 매우 유용합니다. 복잡한 데이터의 구조를\n한눈에 보여주는 R의 효자 함수지요. 그런데 DBI을 이용한 table 객체를\n사용할 때 문제가 있습니다.\n문제상황을 만들기 위해 sqlite를 사용해서 테이블을 만들어\n보겠습니다.\n\n\nlibrary(DBI)\nlibrary(RSQLite)\nlibrary(dplyr)\ntb <- dbConnect(SQLite(), \":memory:\")\ntb\n\n\n<SQLiteConnection>\n  Path: :memory:\n  Extensions: TRUE\n\ncopy_to(tb, mtcars)\nmtcars_sql <- tbl(tb, \"mtcars\")       \n\n\n\n유용한 내장 데이터인 mtcars 데이터셋을 sqlite로\n저장하고, dplyr::tbl() 함수로 테이블 객체를 불러왔습니다.\n이제 데이터를 살펴볼 때 유용한 함수인 str()로 데이터를\n확인해보겠습니다. 우선 R 객체인 mtcars를 확인해 볼까요?\n\n\nstr(mtcars)\n\n\n'data.frame':   32 obs. of  11 variables:\n $ mpg : num  21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...\n $ cyl : num  6 6 4 6 8 6 8 4 4 6 ...\n $ disp: num  160 160 108 258 360 ...\n $ hp  : num  110 110 93 110 175 105 245 62 95 123 ...\n $ drat: num  3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...\n $ wt  : num  2.62 2.88 2.32 3.21 3.44 ...\n $ qsec: num  16.5 17 18.6 19.4 17 ...\n $ vs  : num  0 0 1 1 0 1 0 1 1 1 ...\n $ am  : num  1 1 1 0 0 0 0 0 0 0 ...\n $ gear: num  4 4 4 3 3 3 3 4 4 4 ...\n $ carb: num  4 4 1 1 2 1 4 2 2 4 ...\n\n그리고 테이블 객체로 저장한 mtcars_sql을\n확인해보겠습니다.\n\n\nstr(mtcars_sql)\n\n\nList of 2\n $ src:List of 2\n  ..$ con  :Formal class 'SQLiteConnection' [package \"RSQLite\"] with 8 slots\n  .. .. ..@ ptr                :<externalptr> \n  .. .. ..@ dbname             : chr \":memory:\"\n  .. .. ..@ loadable.extensions: logi TRUE\n  .. .. ..@ flags              : int 70\n  .. .. ..@ vfs                : chr \"\"\n  .. .. ..@ ref                :<environment: 0x7fb2c8244820> \n  .. .. ..@ bigint             : chr \"integer64\"\n  .. .. ..@ extended_types     : logi FALSE\n  ..$ disco: NULL\n  ..- attr(*, \"class\")= chr [1:4] \"src_SQLiteConnection\" \"src_dbi\" \"src_sql\" \"src\"\n $ ops:List of 2\n  ..$ x   : 'ident' chr \"mtcars\"\n  ..$ vars: chr [1:11] \"mpg\" \"cyl\" \"disp\" \"hp\" ...\n  ..- attr(*, \"class\")= chr [1:3] \"op_base_remote\" \"op_base\" \"op\"\n - attr(*, \"class\")= chr [1:5] \"tbl_SQLiteConnection\" \"tbl_dbi\" \"tbl_sql\" \"tbl_lazy\" ...\n\n확실히 기대하는 모양이랑 좀 다릅니다. 테이블 객체 자체에 대한 정보를\n보여주는군요.\n제가 다루는 db의 테이블들은 컬럼이 몇 십개씩 있거나 하기도\n합니다.\ntibble 자료형이 매우 좋은 요약정보를 제공합니다만,\n컬럼이 많아지면 한눈에 보기 불편한 문제가 있습니다.\n\n\nlibrary(nycflights13)\nflights\n\n\n# A tibble: 336,776 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>\n 1  2013     1     1      517            515         2      830\n 2  2013     1     1      533            529         4      850\n 3  2013     1     1      542            540         2      923\n 4  2013     1     1      544            545        -1     1004\n 5  2013     1     1      554            600        -6      812\n 6  2013     1     1      554            558        -4      740\n 7  2013     1     1      555            600        -5      913\n 8  2013     1     1      557            600        -3      709\n 9  2013     1     1      557            600        -3      838\n10  2013     1     1      558            600        -2      753\n# … with 336,766 more rows, and 12 more variables:\n#   sched_arr_time <int>, arr_delay <dbl>, carrier <chr>,\n#   flight <int>, tailnum <chr>, origin <chr>, dest <chr>,\n#   air_time <dbl>, distance <dbl>, hour <dbl>, minute <dbl>,\n#   time_hour <dttm>\n\n이렇게 화면을 벗어나게 컬럼이 많으면 값들의 일부조차도 요약해서\n보여주죠. 물론 컬럼 출력 옵션을 조정할 수 도 있습니다. 하지만 그런\n커스텀이 많아지는걸 저는 좋아하지 않습니다.\n대신 dplyr::glimpse() 함수를 제공한다는 사실을\n알게되었습니다. 대체 dbi src str 같은 검색을 죽어라 할 때는\n없더니… 등잔밑이 어둡다가 정말 이럴때 쓰는 말인가 싶더군요.\n\n\nglimpse(mtcars_sql)\n\n\nRows: ??\nColumns: 11\nDatabase: sqlite 3.38.2 [:memory:]\n$ mpg  <dbl> 21.0, 21.0, 22.8, 21.4, 18.7, 18.1, 14.3, 24.4, 22.8, 1…\n$ cyl  <dbl> 6, 6, 4, 6, 8, 6, 8, 4, 4, 6, 6, 8, 8, 8, 8, 8, 8, 4, 4…\n$ disp <dbl> 160.0, 160.0, 108.0, 258.0, 360.0, 225.0, 360.0, 146.7,…\n$ hp   <dbl> 110, 110, 93, 110, 175, 105, 245, 62, 95, 123, 123, 180…\n$ drat <dbl> 3.90, 3.90, 3.85, 3.08, 3.15, 2.76, 3.21, 3.69, 3.92, 3…\n$ wt   <dbl> 2.620, 2.875, 2.320, 3.215, 3.440, 3.460, 3.570, 3.190,…\n$ qsec <dbl> 16.46, 17.02, 18.61, 19.44, 17.02, 20.22, 15.84, 20.00,…\n$ vs   <dbl> 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1…\n$ am   <dbl> 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1…\n$ gear <dbl> 4, 4, 4, 3, 3, 3, 3, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 4, 4…\n$ carb <dbl> 4, 4, 1, 1, 2, 1, 4, 2, 2, 4, 4, 3, 3, 3, 4, 4, 4, 1, 2…\n\ndb를 소스로 사용하는 테이블 객체를 살펴볼 때 필수 함수가 아닐까\n싶습니다. flights 데이터로 한번 더 비교하면서 글\n마무리하겠습니다. 감사합니다.\n\n\ncopy_to(tb, flights)\nflights_sql <- tbl(tb, \"flights\")\nstr(flights_sql)\n\n\nList of 2\n $ src:List of 2\n  ..$ con  :Formal class 'SQLiteConnection' [package \"RSQLite\"] with 8 slots\n  .. .. ..@ ptr                :<externalptr> \n  .. .. ..@ dbname             : chr \":memory:\"\n  .. .. ..@ loadable.extensions: logi TRUE\n  .. .. ..@ flags              : int 70\n  .. .. ..@ vfs                : chr \"\"\n  .. .. ..@ ref                :<environment: 0x7fb2c8244820> \n  .. .. ..@ bigint             : chr \"integer64\"\n  .. .. ..@ extended_types     : logi FALSE\n  ..$ disco: NULL\n  ..- attr(*, \"class\")= chr [1:4] \"src_SQLiteConnection\" \"src_dbi\" \"src_sql\" \"src\"\n $ ops:List of 2\n  ..$ x   : 'ident' chr \"flights\"\n  ..$ vars: chr [1:19] \"year\" \"month\" \"day\" \"dep_time\" ...\n  ..- attr(*, \"class\")= chr [1:3] \"op_base_remote\" \"op_base\" \"op\"\n - attr(*, \"class\")= chr [1:5] \"tbl_SQLiteConnection\" \"tbl_dbi\" \"tbl_sql\" \"tbl_lazy\" ...\n\nglimpse(flights_sql)\n\n\nRows: ??\nColumns: 19\nDatabase: sqlite 3.38.2 [:memory:]\n$ year           <int> 2013, 2013, 2013, 2013, 2013, 2013, 2013, 201…\n$ month          <int> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, …\n$ day            <int> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, …\n$ dep_time       <int> 517, 533, 542, 544, 554, 554, 555, 557, 557, …\n$ sched_dep_time <int> 515, 529, 540, 545, 600, 558, 600, 600, 600, …\n$ dep_delay      <dbl> 2, 4, 2, -1, -6, -4, -5, -3, -3, -2, -2, -2, …\n$ arr_time       <int> 830, 850, 923, 1004, 812, 740, 913, 709, 838,…\n$ sched_arr_time <int> 819, 830, 850, 1022, 837, 728, 854, 723, 846,…\n$ arr_delay      <dbl> 11, 20, 33, -18, -25, 12, 19, -14, -8, 8, -2,…\n$ carrier        <chr> \"UA\", \"UA\", \"AA\", \"B6\", \"DL\", \"UA\", \"B6\", \"EV…\n$ flight         <int> 1545, 1714, 1141, 725, 461, 1696, 507, 5708, …\n$ tailnum        <chr> \"N14228\", \"N24211\", \"N619AA\", \"N804JB\", \"N668…\n$ origin         <chr> \"EWR\", \"LGA\", \"JFK\", \"JFK\", \"LGA\", \"EWR\", \"EW…\n$ dest           <chr> \"IAH\", \"IAH\", \"MIA\", \"BQN\", \"ATL\", \"ORD\", \"FL…\n$ air_time       <dbl> 227, 227, 160, 183, 116, 150, 158, 53, 140, 1…\n$ distance       <dbl> 1400, 1416, 1089, 1576, 762, 719, 1065, 229, …\n$ hour           <dbl> 5, 5, 5, 5, 6, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, …\n$ minute         <dbl> 15, 29, 40, 45, 0, 58, 0, 0, 0, 0, 0, 0, 0, 0…\n$ time_hour      <dbl> 1357034400, 1357034400, 1357034400, 135703440…\n\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106563142-b1e03180-656e-11eb-8501-f3729df21e9a.png",
    "last_modified": "2022-11-27T05:10:00+00:00",
    "input_file": {}
  },
  {
    "path": "post/2018년-회고/",
    "title": "2018년 회고",
    "description": "첫 목표가 건강이었지만 다른 일을 너무 많이 벌린거 같습니다.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2019-01-04",
    "categories": [
      "blog",
      "retrospect"
    ],
    "contents": "\n\n벌써 1월이 되어 2019년입니다. 회고라는 걸 해봐야지 라고\n생각하고 시간이 이렇게나 지나버렸네요. 2018년을 정리하고 되돌아보는 것이\n중요한 시점이 되어서 늦게라도 작성해 보려고 합니다.\n원래 2018년 계획\n원래 2018년 계획은 건강이었습니다. 2017년 능력에 차지도 않은 강의를\n진행하면서 무리한다는 생각을 많이 했었거든요. 그래서 2018년 계획은 엄청\n단순하게 건강이었습니다. 헌데…\n일어난 일\n결혼 1년차와 아이, 이사\n결혼 1년차와 아이, 이사는 정말 많은 시간이 필요했습니다. 물론 제가\n시간을 썼다기 보단, 정신없이 지나가 버렸다고나 할까요?\n이직\n이직이 있었습니다. 이직을 하는 바람에 원래 1년 계획이었던 음성 인식은\n안드로메다로…(눈물) 챗봇으로 좋은 제안이 왔었는데, 이리저리 재보다가\n지금의 회사로 결정했습니다. 회사에서 R을 사용하고 싶다는 욕구와,\n챗봇에서 도망치고 싶은 마음이 겹쳤죠. 독특하게 재무팀에서 일을 하는\n중입니다. 재무팀이 필요한 데이터를 찾고, 만들고, 사용하기 좋은 환경을\n갖추려고 노력하고 있습니다. 물론 놀랍게도 감사를 경험하고 있는 중인데,\n저에게 득인지 실인지 잘 모르겠네요.\n번역\n\n책을\n하나 번역했습니다. 이건 17년에 벌린 일이니 최대한 빨리 마무리해보자는\n생각에 결국 끝낼 수 있었습니다. 물론 5명이나 진행했고, 일을 벌린 것\n이외에는 저는 한게 없는 활동이었습니다만. 덕분에 너무 좋은 분들과\n협업하는 경험을 해보게 되었습니다. 제가 처음 코드 리뷰 프로세스를 코드가\n아닌걸로 겪어보게 된 것이기도 하구요.\n기업 강의\n강의도 하나 했네요. 영우님이 너무 좋은 기회를 만들어 주셨습니다.\n부족한 능력에 과분한 대접도 받아보고, 값진 경험이었습니다. 전업을 충분히\n고민할만 하면서도, 여전히 부족하구나 라는 생각을 하게 되었습니다.\nAI 대회 참여\n\n네이버 ai\n해커톤 2018(와… 레포를 날렸어?!)에 참가했습니다. 어떻게 딱 이직\n타이밍이라 예선을 할 시간이 있었군요. 다행히 결선 범위에 들어갈 수 있게\n되어서 춘천의 커넥트원도 구경할 수 있었습니다. 제 기억에 지식인 질문\n유사도 문제에서 한 9등쯤 했던거 같은데…. 제가 무식하게 제꺼 기록 해둔\n레포도 날렸네요. 덕분에 이런저런 고민을 했던 이벤트이기도 합니다.\nkeras도 많이 쓰고, 그때 멘토셨던 경호님이 좋게 봐주셨던 기분좋은 일도\n있었죠.\n블로그\n어영부영 블로그를 열심히 했습니다. blogdown이란 신박한\n패키지가 드디어 불을 질렀다고나 할까요. 버려진 워드프레스, 텀플러 등등을\n거쳐 드디어 안착하고 18년엔 26개 포스트를 작성했네요.\n\n1년 동안 방문자는 17,466명 입니다. 재방문자 비율이 33% 쯤\n되는군요.\n\n블로그에 붙어 있는 광고로 총 16.16 달러를 벌었군요. 압도적인 1등\n컨텐츠는 R 크롤링에 대한 발표자료입니다. 아마 검색에 잘 걸려서지 않을까\n싶습니다. 2번째는 번역이고, 개발 관련 글이다 보니 독자층이 좀더 넓은\n편이었던 것 같습니다. 상위에 실제 18년 포스트는 4건이 있군요.\n\n쓰면서 느꼈던 점은, 최대한 원소스 멀티유즈 하자였습니다. 새롭게\n컨텐츠를 기획하지 말고 있는 컨텐츠를 발산해야 컨텐츠 생산성이 좋다\n느껴졌습니다.\n패키지\n관리하는 패키지에 변화도 좀 있었고, 새로 만든 것들도 있었습니다. 우선\n드디어 DNH4에 댓글 수집\n기능이 들어갔습니다. 덕분에 서비스에서 키를 관리하는 다른 방법을 배울 수\n있었구요. 이 배움은 뭔가 기록을 남기고 싶은데, 그냥 삽질한거라 잘\n모르겠네요. 아마 최근 시작한 유튜브로 한번 리마인드해보면 좋겠다는\n생각이 듭니다. (네이버(N2H4)와 다음 뉴스의 댓글은\n이제 셀레늄 쓰지 않고 빠르게 수집할 수 있으니 많이 사랑해주세요.)\npresidentSpeechKr\n패키지는 한글 설명을 제거한 presidentSpeech\n패키지로 우선 변환하였습니다. 윈도우에서 나는 경고와 같은 에러는 역시\n사용하는데 많이 불편하더라구요. 우선 이 문제를 Rstudio 1.3 버전\n마일스톤으로 이슈를 제기한\n것으로 만족하려고 합니다. 참고로 Rstduio 현재 안정화 버전은\n1.1.463입니다. (네.. 언제 될지 알 수 없단 뜻이죠…)\n나머지는 대부분 데이터 패키지이고, 야심차게 시작한 건 DBF입니다. 물론 개념만 겨우\n확인한 패키지이지만, 개인적인 쓸모에 의해 만들어서 그런가 아주 애정이\n갑니다. 이제 잘 다듬고, 워크플로우에 잘 녹여 사용해야겠죠.\n또 메일 서버가 세팅되어 있으면 좋겠지만, 없는 곳에서 사용하려고 sendgridr를\n만들었습니다. 최초로 클래스 개념으로 패키지를 작성해봤는데, 많은 공부를\n할 수 있었어요. 잘 활용하면 if 지옥을 좀 벗어날 수 있을 것 같은 가능성을\n봤습니다.\n발표자료\n18년은 건강! 쉬자! 라고 생각한 만큼 발표는 전혀 생각하고 있지\n않았습니다. 헌데 어영부영 2번이나 하고 말았습니다.\n데이터야 놀자에서 R과 redshift를\n항해할 때 알아야할 상식사전(+협업) 라는 제목으로 한번 했구요. IBM\n개발자 컨퍼런스에서 R로 만든\n머신러닝 모델을 api로 제공하기 라는 제목으로 다른 한번을 했습니다.\n무슨 부귀영화를 누리겠다고, 내용을 두개나 만들었는지… 덕분에 둘 다\n부실부실해서 안타깝기만 합니다.\n유튜브\n\n여름쯤 시작하려고 했던 유튜브를\n기어이 시작했습니다. 12월 18일에 첫 영상를 촬영하고, 오늘 1월 4일 기준\n구독자 100명이 되었습니다. 데이터 패키지를 만드는 영상은 여러분이\n도와주셔서 100건이 넘는 조회수를 기록했습니다. 7건의 동영상을\n업로드했고, 4건을 한시간씩 하는 무서운 짓을 해버렸습니다. 시작하자마자\n어디 아프고 해서 매일하겠다는 다짐을 지키질 못했네요.\n회사일\n뭔가 프로젝트스럽게 딱 끝낸게 있으면 좋을텐데 아쉽게도 그렇게 하지\n못했습니다. 전부 다 진행 중이기만 하고, 속시원히 마무리한게 아직 없네요.\n새해에는 상상하고 있는 그림이 잘 구현되었으면 좋겠습니다.\n새해 다짐\n우선 크게 3가지 정도 생각하고 있는데요.\n첫째는 역시 건강입니다. 지난 한해는 건강을 생각만\n했다면, 올해는 구체적인 계획을 세워볼까 해요. 운동 계획과 치과 진료\n계획을 세우고 실행하는 것이 목표입니다.\n둘째는 유튜브 입니다. 광고수익을 나눌 수 있는 최소 기준이 구독자\n1,000명입니다. 구독자를 1,000명 모으는 것. 아마도 중요한 목표가 될 것\n같습니다.\n셋째는 다시 회사 일입니다. 역시 업으로 삼고 해야 스스로의 성장에도\n도움이 되는 법입니다. 현실적인 계획으로 작고, 빠르게 실행하는 걸 새롭게\n다짐해보려고 합니다. 기왕하는거 다시 기록도 좀 잘 해서, 일마다 분석하고\n회고할 수 있게 하려구요.\n+알파를 추가하자면 go를 공부하는 겁니다. 이번엔 좀 진짜 해서 손에\n익으면 좋겠다 생각하고 있습니다.\n이렇게 회고글을 써보니 19년은 회고를 위해서 기록을 좀 열심히 해야\n겠다는 생각이 들었습니다. 페이스북 글 분석 같은거로 거창하게 해볼까\n하다가, 뭐든 시간이 걸리면 될 것도 안된다는 마음으로 임하고\n있습니다.\n\n더 작고 더 빠르게\n\n아무리 되뇌어도 적응하기 쉽지 않네요.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106562771-24044680-656e-11eb-8576-052a795b24c4.png",
    "last_modified": "2022-11-27T05:09:35+00:00",
    "input_file": {}
  },
  {
    "path": "post/rtips-사륜안-패키지로-rmd-실시간-결과-preview-확인하기/",
    "title": "[Rtips] 사륜안 패키지로 Rmd 실시간 결과(preview) 확인하기",
    "description": "Rmd 작성할 때 `xaringan::inf_mr()` 실행하고 작업하세요.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2018-12-06",
    "categories": [
      "R",
      "xaringan",
      "rmd",
      "preview"
    ],
    "contents": "\n\n\n\n한줄요약\nRmd 작성할 때 xaringan::inf_mr() 실행하고\n작업하세요.\n오타쿠 감성 넘치는 이름의 패키지 xaringan(사륜안)은 이름과는\n완전히 무관하게 Web Presentation 도구입니다. 제 발표자료는 전부 이\n패키지를 활용했다고 해도 과언이 아닌데요. xaringan 패키지에는\n발표자료를 작성할 때 유용한 함수를 제공합니다. 바로\nxaringan::inf_mr() 입니다.\n실시간 프리뷰 보기\nmarkdown은 매우 광범위하게 사용되는 문서 양식입니다. Rstudio에서는\nR의 코드 청크를 실행하여 markdown 문서에 결과를 추가하여 작성하는 Rmd\n양식을 지원합니다. 주피터 노트북과 비슷하다고 할 수 있습니다. 물론 저는\nR과 Rmd가 익숙할 뿐입니다. ㅎㅎ\nRmd는 여러 패키지의 열열한 지원에 힘입어 많은 양식을 결과물로 내놓을\n수 있게 되었습니다. 여러 Web Presentation 발표자료 도구들이 나왔지만,\n저는 xaringan가 가장\n마음에 들더군요. 가장 마음에 든 기능이 실시간 프리뷰 함수를 제공하는\n것이었습니다.\nxaringan::inf_mr() 함수를 실행하면\nxaringan을 결과물로 만드는 Rmd 파일을 저장할 때 마다 실시간\n프리뷰를 보여줍니다! 가장 기가 막힌 부분은 지금부터인데요. 이게 모든 Rmd\n형식에서 지원합니다! 물론 html이 결과물 양식일 때\n입니다.\nRmd 파일을 실시간\n프리뷰를 보면서 작업하기\nxaringan::inf_mr() 함수는 Rmd 파일이 저장될 때 마다\n자동으로 knitr::render() 함수를 실행해서 결과를 보여주는\n효과가 있습니다. 아래 gif는 중간 제목에 test 글자를 추가하는 과정을\n보여줍니다.\n\n\n\nxaringan::inf_mr() 함수는 Addin을 제공하고 있어서 Knit\n버튼처럼 클릭으로 진행할 수도 있습니다. 아 설치방법이 궁금하실 수도 있을\n것 같습니다. xaringan은 github에서의 설치만을\n지원합니다.\n# remotes 패키지가 없다면 아래 패키지 설치 함수를 실행해주세요.\n# install.packages(\"remotes\")\nremotes::install_github('yihui/xaringan')\n이후에는 Rmd 파일을 작성하실 때 gif 같이 사용하시면 됩니다.\n감사합니다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106562406-97f21f00-656d-11eb-8bfe-e9caa338d2c9.png",
    "last_modified": "2022-11-27T05:10:08+00:00",
    "input_file": {}
  },
  {
    "path": "post/usehelp-r의-help-글을-포스트에서-활용하기/",
    "title": "[usehelp] R의 help 글을 포스트에서 활용하기",
    "description": "다른 좋은 접근이 많아서 개발을 중지하였습니다. \n포스트나 발표자료에서 함수를 설명할 일이 많아서 `usehelp`라는 패키지를 만들었습니다.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2018-11-26",
    "categories": [
      "R",
      "usehelp",
      "package",
      "blog"
    ],
    "contents": "\n\nContents\n업데이트\n\n\n업데이트\n다른 좋은 접근이 많아서 개발을 중지하였습니다. # TODO: 좋은 접근\n링크 공유.\n한줄요약\n포스트나 발표자료에서 함수를 설명할 일이 많아서\nusehelp라는 패키지를 만들었습니다.\n저는 R 언어를 매우 사랑합니다. 이미 문법이 익숙해서, 다른 걸\n사용하는게 매우 불편하죠. 이 블로그도 blogdown 패키지를\n이용하고 있고, 발표자료는 xaringan으로 만들어\n공유합니다. 포스트를 작성할 때 마다 대문 이미지를 계속 넣어왔는데요.\nimg 태그를 쓰다가 결국, htmltools로 바꿨습니다.\n아주 마음이 편하네요. ㅎㅎㅎ 잠시 딴길로 샜는데, 어쩄든 포스트나\n발표자료를 R로 만들다 보니, 함수 설명할 일이 매우 많습니다.\n매번 제가 직접 작성하고 있었는데… 생각해보니 설명서에 제목이며,\n설명이며 다 있는 겁니다! 그래서 그 텍스트를 가져와서 출력해주는 패키지를\n생각해보게 되었습니다.\nusehelp\n당장 가볍게 만들다보니, 설명서의 텍스트를 R 객체로 가져오는 선에서\n끝나고 있습니다. 이제 시작인 셈인데요. github 버전만 있어서 우선\nremotes::install_github() 함수로 설치해야 합니다.\n\n\nremotes::install_github(\"mrchypark/usehelp\")\n\n\n\n그럼 이제 사용해 봅시다.\n\n\nlibrary(usehelp)\nget_help(\"usehelp\",\"get_help\")\n\n\n{html_document}\n<html>\n[1] <head>\\n<title>R: get help<\/title>\\n<meta http-equiv=\"Content-T ...\n[2] <body>\\n<div class=\"container\">\\n\\n<table style=\"width: 100%;\"> ...\n\nget_help() 함수는 패키지 이름, 함수 이름을 받아\nhelp의 글자를 전부 가져와서, help 클래스로\n만듭니다. help 클래스의 출력를 조정해야 하지만, 이제\n0.0.0.9000 버전일 뿐이니 우선 넘어가죠. help 클래스라고\n했는데, 지금 모양은 xml_document 입니다. 여러 양식으로\n제공해주던데, 제가 다루기 쉬운 xml로 처리하기로 했습니다.\n일부 데이터를 가져오는 것은 당연히 rvest를 사용했습니다.\n\n\nget_help(\"usehelp\",\"get_help\") %>% \n  get_title()\n\n\n[1] \"get help\"\n\n그래서 필요한 글자를 가져오는 함수들은 전부 rvest를 덮어서 만들었습니다.\n아직은 title과 description, usage\n만 있지만 차츰 추가해 나가겠습니다.\n향후 계획\n우선 포스트와 발표자료에 예쁘게 사용하기 위해 html\n출력을 추가할 계획입니다. help 클래스의 콘솔 출력도\n조정해야 할 것 같구요. 마지막으로 가능하다면 번역기를 붙여서 한글자료\n만들 때 어설픈 채로라도 사용할 수 있게 조정해볼 계획입니다.\n마지막은 정말 희망사항이네요 ㅎㅎ\n여기까지 usehelp\n패키지 소개였습니다. 아직 사용할 수준은 아니지만, 사용하시게 되면 이슈나\nPR 대환영입니다. 콘솔 출력과 html 형태 삽입만 마무리되면\ncran에 등록할 계획입니다.\n감사합니다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106562157-3fbb1d00-656d-11eb-8c40-6740e14ecc1f.png",
    "last_modified": "2022-11-27T05:10:50+00:00",
    "input_file": {}
  },
  {
    "path": "post/회고-tqk-업데이트-수정-종가-반영-및-param-조정/",
    "title": "[회고] tqk 업데이트 수정 종가 반영 및 param 조정",
    "description": "tqk 패키지를 버전업하면서 배운 점을 작성해보았습니다.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2018-11-22",
    "categories": [
      "R",
      "tqk",
      "adjusted",
      "announce"
    ],
    "contents": "\n\n이번 0.1.0 버전 업데이트는 다음 소스 추가로 인한 속도 향상 및\n수정주가 반영입니다. 거기에 tq_get()함수를 모방하기로 한\n주제에 param 설계가 달라서 맞춰주는 작업을\n수행했습니다.\n배운 점\n새롭게 json을 처리하면서 purrr::transpose(),\ndplyr::select_if()를 알게 되었습니다. json을\ntibble::as_tibble() 로 처리한 후\ntidyr::unnest() 시 발생하는 문제의 원인을 알게\n되었습니다.\ntibble자료형과\nas_tibble() 함수\ntibble, tbl 자료형은 현대적인 R을\n사용하는데 근간이 되는 자료형입니다. base R의 data.frame의\n현대적 버전이라고 할 수 있는데요. 매우 많은 장점이 있습니다.\n우선 dim(), head(), class()\n개별 컬럼의 class()가 객체를 출력하는 것으로 한번에\n해결됩니다. 출력량도 화면에 기반하여 제한하고 있어서, 많은 출력으로\n멈추거나 하는 문제를 사전에 방지하고 있습니다. 좀 불편하다면, 컬럼도\n출력 제한을 한다는 점 정도 인데요.\n보통 matrix 나 data.frame을\ntibble 자료형으로 바꾸려면 as_tibble() 함수를\n사용합니다. json으로 들어온 list는 웹 데이터를\n다룰 때 많이 겪게 되는데요. 2단 구조의 list일 때\nas_tibble()이 동작한다면 아주 편할 것 같습니다.\n예를 들어 보겠습니다.\n\n\ncol_first_list <- list(a = list(1, 2, 3), b = list(4, 5, 6))\ncol_first_list\n\n\n$a\n$a[[1]]\n[1] 1\n\n$a[[2]]\n[1] 2\n\n$a[[3]]\n[1] 3\n\n\n$b\n$b[[1]]\n[1] 4\n\n$b[[2]]\n[1] 5\n\n$b[[3]]\n[1] 6\n\n2단 구조를 만들 때 헷갈리지 않기 위해서 1단은 이름을 지어서, 2단은\n이름없이 2단 list를 만들었습니다. 간단히 대응하면 1,2,3\n데이터를 가지는 a 컬럼과 4,5,6 데이터를 가지는\nb 컬럼의 table일 수 있을 것 같습니다. 컬럼 단위로\n묶어서 데이터를 보냈으므로, 저는 col_first_list라고\n이름지어 봤습니다.\n\n\nlibrary(dplyr)\ncol_first_list %>% \n    tibble::as_tibble()\n\n\n# A tibble: 3 × 2\n  a         b        \n  <list>    <list>   \n1 <dbl [1]> <dbl [1]>\n2 <dbl [1]> <dbl [1]>\n3 <dbl [1]> <dbl [1]>\n\n음… tibble로는 된거 같은데, 뭔가 이상합니다. 찾아보니\ntibble은 컬럼의 자료형이 list가\n가능하더라구요. 그럼 평소에 알고 있는 모습으로 바꾸는 작업이 필요할 것\n같습니다.\n새롭게 배운 함수 1\ntidyr::unnest()\nNest and unnest\n\nDescription\nNesting creates a list-column of data frames; unnesting flattens it back out into regular columns. Nesting is implicitly a summarising operation: you get one row for each group defined by the non-nested columns. This is useful in conjunction with other summaries that work with whole datasets, most notably models.\n\nLearn more in vignette(\"nest\").\n\nUsage\nnest(.data, ..., .key = deprecated())\n\nunnest(data, cols, ..., keep_empty = FALSE, ptype = NULL,\n  names_sep = NULL, names_repair = \"check_unique\",\n  .drop = deprecated(), .id = deprecated(), .sep = deprecated(),\n  .preserve = deprecated())\n제목과 설명을 보면 딱 필요한 함수 같아 보입니다. 한번 사용해\n볼까요?\n\n\ncol_first_list %>% \n  tibble::as_tibble() %>% \n  tidyr::unnest()\n\n\n# A tibble: 3 × 2\n      a     b\n  <dbl> <dbl>\n1     1     4\n2     2     5\n3     3     6\n\n깔끔하게 결과가 나왔습니다.\n하지만 보통 json을 웹서비스에서 받을 때 반대로 되어 있는 경우가\n많습니다.\n\n\nrow_first_list <- list(list(a = 1, b = 4), list(a = 2, b = 5), list(a = 3, b = 6))\nrow_first_list\n\n\n[[1]]\n[[1]]$a\n[1] 1\n\n[[1]]$b\n[1] 4\n\n\n[[2]]\n[[2]]$a\n[1] 2\n\n[[2]]$b\n[1] 5\n\n\n[[3]]\n[[3]]$a\n[1] 3\n\n[[3]]$b\n[1] 6\n\n\n\nrow_first_list %>% \n    tibble::as_tibble()\n\n\nError:\n! Columns 1, 2, and 3 must be named.\nUse .name_repair to specify repair.\nCaused by error in `repaired_names()`:\n! Names can't be empty.\n✖ Empty names found at locations 1, 2, and 3.\n\n우선 tibble::as_tibble()이 바로 처리 해주지를 못합니다.\n컬럼은 이름이 있어야만 한다는 군요. 이때 purrr::transpose()\n가 필요합니다.\n새롭게 배운 함수 2\npurrr::transpose()\nTranspose a list.\n\nDescription\nTranspose turns a list-of-lists \"inside-out\"; it turns a pair of lists into a list of pairs, or a list of pairs into pair of lists. For example, if you had a list of length n where each component had values a and b, transpose() would make a list with elements a and b that contained lists of length n. It's called transpose because x[[1]][[2]] is equivalent to transpose(x)[[2]][[1]].\n\nUsage\ntranspose(.l, .names = NULL)\n\n\nrow_first_list %>% \n    purrr::transpose() %>% \n    tibble::as_tibble() %>% \n    tidyr::unnest()\n\n\n# A tibble: 3 × 2\n      a     b\n  <dbl> <dbl>\n1     1     4\n2     2     5\n3     3     6\n\n이렇게 2단 으로 구성된 json 파일은 쉽게 tibble\n자료형으로 고쳐서 R에서 다룰수 있습니다.\ntidyr::unnest() 함수의\n문제점\n이제 얼마든지 json 데이터를 사용하기 좋게\ntibble로 바꿀 수 있게 된 것 같았습니다. (2단 구성이라면\n말이지요.) 하지만 어찌된 일인지 상황에 따라 에러가 계속 발생하더군요.\n찾아보니 컬럼에 null이 있을 때가 문제였습니다.\nlist 자료형은 그대로 null을 가지고 있는 반면,\ntidyr::unnest()가 동작할 때 null이 없어져서\n다른 컬럼과 갯수가 맞지 않게 되는 것이었습니다.\n\n\ninclud_null <- list(a = list(1, 2, 3), b = list(4, NULL, 6.5))\ninclud_null %>% \n  tibble::as_tibble()\n\n\n# A tibble: 3 × 2\n  a         b        \n  <list>    <list>   \n1 <dbl [1]> <dbl [1]>\n2 <dbl [1]> <NULL>   \n3 <dbl [1]> <dbl [1]>\n\n이렇게 tibble::as_tibble() 함수는 null을\n유지한 채로 동작했습니다. 하지만 tidyr::unnest()은 처리하지\n못하고 에러가 발생하네요.\n\n\ninclud_null %>% \n  tibble::as_tibble() %>% \n  tidyr::unnest()\n\n\n# A tibble: 3 × 2\n      a     b\n  <dbl> <dbl>\n1     1   4  \n2     2  NA  \n3     3   6.5\n\n또 전체가 null인 컬럼도 있으면 안됩니다.\n\n\nall_null <- list(a = list(1, 2, 3), b = list(NULL, NULL,NULL))\nall_null %>% \n  tibble::as_tibble()\n\n\n# A tibble: 3 × 2\n  a         b     \n  <list>    <list>\n1 <dbl [1]> <NULL>\n2 <dbl [1]> <NULL>\n3 <dbl [1]> <NULL>\n\nall_null %>% \n  tibble::as_tibble() %>% \n  tidyr::unnest()\n\n\n# A tibble: 3 × 2\n      a b    \n  <dbl> <lgl>\n1     1 NA   \n2     2 NA   \n3     3 NA   \n\n이 두 가지는 다른 처리방법을 사용해야 할 것 같습니다. 전체가\nnull인 컬럼은 제거하고, 일부가 null인 컬럼은\nnull을 다른 값으로 대체해야 겠네요. 전체가\nnull인 컬럼 이름을 하드코딩할 수도 있겠지만, 찾아서\n제거하는 것이 더 좋아보였습니다.\n새롭게 배운 함수 3\ndplyr::*_if()\ndplyr 패키지에는 muate() 함수나\nselect() 함수 뒤에 _if()가 붙은 조건 계열의\n함수가 있습니다. 이걸 이용해서 컬럼내 데이터가 전체 null인\n것을 제외하고 select() 하겠다가 가능할 것 같습니다.\n\n\nnulls_party <- list(a = list(1, 2, 3), \n                    b = list(NULL, NULL,NULL),\n                    c = list(NULL, 1,2),\n                    d = list(1,NULL,NULL),\n                    e = list(1,NULL,3))\nnulls_party %>% \n  tibble::as_tibble() %>% \n  dplyr::select_if( ~ !all(is.null(unlist(.x))))\n\n\n# A tibble: 3 × 4\n  a         c         d         e        \n  <list>    <list>    <list>    <list>   \n1 <dbl [1]> <NULL>    <dbl [1]> <dbl [1]>\n2 <dbl [1]> <dbl [1]> <NULL>    <NULL>   \n3 <dbl [1]> <dbl [1]> <NULL>    <dbl [1]>\n\n조금 복잡한데요. ~은 익명 함수를 작성하는\n줄임표현입니다. ~ sum(.x)는\nfuncion(x) sum(x)와 같은 표현이죠. !는\n논리형을 반대로 바꿔라는 뜻이구요. all() 함수는\nis.null() 함수는 데이터가 null인지를 확인하는\n함수 입니다. select_if() 함수 내에서 익명 함수 문법을\n사용하게 되면, .x는 컬럼을 뜻하게 됩니다. 지금은 컬럼이\n리스트기 때문에 unlist()로 vector로\n바꾸었습니다.\n그럼 설명해보면\n... %>% \n  dplyr::select_if( ~ !all(is.null(unlist(.x))))\nselect_if(): 조건에 맞는 것만 선택할꺼야.\n~: 함수를 조합해야 하니까 익명함수를 쓸께. !:\n뒤에 논리형 결과가 나오면 반대로 바꿔줘. all(): 안에 모두가\nTRUE면 TRUE하나를, 하나라도 아니라면\nFALSE를 반환해. is.null: 값이\nNULL이면 TRUE를 주세요. unlist():\nlist 자료형을 vector로 풀어줘.\n.x: 익명 함수에서 입력을 대표해.\n입니다.\n그러고 보니…\n... %>% \n  dplyr::select_if(~ .x %>% unlist() %>% is.null() %>% all() %>% !.)\n이렇게 해도 되는군요. 조금 가독성이 좋아졌습니다.\n이제 전체 NULL인 컬럼을 제거 했으니, 일부가\nNULL인 경우 우선 0으로 대체 해보겠습니다.\nmap’s party\n우선 결론 먼저 쓰고 시작해보면,\n\n\nnulls_party %>% \n  tibble::as_tibble() %>% \n  dplyr::select_if(~ .x %>% unlist %>% is.null %>% all %>% !.) %>% \n  purrr::map_dfc(~ .x %>% purrr::map(is.null) %>% ifelse(0,.x) %>% unlist())\n\n\n# A tibble: 3 × 4\n      a     c     d     e\n  <dbl> <dbl> <dbl> <dbl>\n1     1     0     1     1\n2     2     1     0     0\n3     3     2     0     3\n\n입니다.\n새롭게 배우게 된 함수는 purrr::map_dfc() 였습니다.\npurrr::map()함수는 기본적으로 list를\n인풋으로 받습니다. 결과도 마찬가지로 list를\n출력해줍니다.\n복잡하게 결과가 나와야 한다면, 전처리를 따로 하기위해서\nlist 아웃풋은 좋은 선택입니다. 하지만 vector로\n나올법한 결과(ex> sum()같이 개별 리스트당 하나의 결과가\n나오거나 하는 등)라면 vector로 아웃풋이 나와도 좋을 것\n같습니다.\n그렇게 해주는 함수가 purrr::map_*()계열 함수입니다. *\n에는 lgl, dbl, chr같이 자료형이\n들어가 있죠. 당연한 설계입니다. vector는 모든 요소가 같은\n자료형이어야 하니까요.\n그럼 data.frame 형태로 받을수는 없을까요? 찾아보니\npurrr::map_df*()가 그 역할을 하더라구요. 그냥\ndf와 dfr, dfc 3개의 접미사를\n제공합니다. dfr과 dfc는 각각 데이터를\nrow 방향과 col 방향으로 합치겠다는\n뜻입니다.\nmap()함수는 data.frame 자료형에서\n기본적으로 col을 list 처럼 받아서 처리합니다.\n그럼 각 컬럼별로 개별 요소에 NULL이 있는지 확인하고 만약\nNULL이라면 0으로 바꿔라 라고 해보겠습니다.\n... %>% \n  purrr::map_dfc(~ .x %>% purrr::map(is.null) %>% ifelse(0,.x) %>% unlist())\n이것도 조금 어렵네요… 우선 골치 아파지는 이유가 각 컬럼이\nlist이기 때문입니다. map()을 이중으로 써야\n하는군요.\npurrr::map_dfc()는 위에서 충분히 설명한 것 같습니다.\n그러면 익명함수 다음부터 확인해 볼 껀데요.\n각 컬럼내의 list요소가 각각 NULL인지\n확인합니다. 이때! purrr:map()때문에, .x가 각\n컬럼을 대표하지 않고, 각 셀을 대표하는 상태로 변합니다.\n\n\nmaps_party <- nulls_party %>% \n  tibble::as_tibble() %>% \n  dplyr::select_if(~ .x %>% unlist %>% is.null %>% all %>% !.)\nmaps_party\n\n\n# A tibble: 3 × 4\n  a         c         d         e        \n  <list>    <list>    <list>    <list>   \n1 <dbl [1]> <NULL>    <dbl [1]> <dbl [1]>\n2 <dbl [1]> <dbl [1]> <NULL>    <NULL>   \n3 <dbl [1]> <dbl [1]> <NULL>    <dbl [1]>\n\n그냥 purrr:map()을 사용해서 .x가\nNULL인지 체크해보겠습니다.\n\n\nmaps_party %>% \n  purrr::map(~ .x %>% is.null)\n\n\n$a\n[1] FALSE\n\n$c\n[1] FALSE\n\n$d\n[1] FALSE\n\n$e\n[1] FALSE\n\n4개 컬럼에 FALSE라는 결과를 list로\n출력해줬네요. 이건 슬프게도 컬럼이 NULL이냐 물어본 것이라\n당연히 전부 FALSE가 나와야 합니다. 그럼 다시\nmap() in map()으로 작성해서 확인해 보겠습니다.\n\n\nmaps_party %>% \n  purrr::map(~ .x %>% purrr::map(is.null))\n\n\n$a\n$a[[1]]\n[1] FALSE\n\n$a[[2]]\n[1] FALSE\n\n$a[[3]]\n[1] FALSE\n\n\n$c\n$c[[1]]\n[1] TRUE\n\n$c[[2]]\n[1] FALSE\n\n$c[[3]]\n[1] FALSE\n\n\n$d\n$d[[1]]\n[1] FALSE\n\n$d[[2]]\n[1] TRUE\n\n$d[[3]]\n[1] TRUE\n\n\n$e\n$e[[1]]\n[1] FALSE\n\n$e[[2]]\n[1] TRUE\n\n$e[[3]]\n[1] FALSE\n\n2단 list로 결과를 주는데, 결국 전부\nlist이군요? 이제 ifelse() 함수로\nis.null() 결과가 TRUE면 0을,\nFALSE면 원래 값 그대로 넣어보겠습니다.\n\n\nmaps_party %>% \n  purrr::map(~ .x %>% purrr::map(is.null) %>% ifelse(0,.x))\n\n\n$a\n$a[[1]]\n[1] 1\n\n$a[[2]]\n[1] 2\n\n$a[[3]]\n[1] 3\n\n\n$c\n$c[[1]]\n[1] 0\n\n$c[[2]]\n[1] 1\n\n$c[[3]]\n[1] 2\n\n\n$d\n$d[[1]]\n[1] 1\n\n$d[[2]]\n[1] 0\n\n$d[[3]]\n[1] 0\n\n\n$e\n$e[[1]]\n[1] 1\n\n$e[[2]]\n[1] 0\n\n$e[[3]]\n[1] 3\n\n이렇게 보니 ifelse()에 들어가는 .x는 처음에\n사용한 .x가 아니라, 안쪽에 있는 purrr::map()\n함수에서 사용하는 .x인듯합니다.\n\n\nmaps_party %>% \n  purrr::map(~ .x %>% purrr::map(~ifelse(is.null(.x),0,.x)))\n\n\n$a\n$a[[1]]\n[1] 1\n\n$a[[2]]\n[1] 2\n\n$a[[3]]\n[1] 3\n\n\n$c\n$c[[1]]\n[1] 0\n\n$c[[2]]\n[1] 1\n\n$c[[3]]\n[1] 2\n\n\n$d\n$d[[1]]\n[1] 1\n\n$d[[2]]\n[1] 0\n\n$d[[3]]\n[1] 0\n\n\n$e\n$e[[1]]\n[1] 1\n\n$e[[2]]\n[1] 0\n\n$e[[3]]\n[1] 3\n\n같은 결과인거 보니 맞네요.\n이제 리스트를 tibble로 다시 조합해 내야 합니다.\npurrr::map_*()으로 조합해볼까요.\n\n\nmaps_party %>% \n  purrr::map(~ .x %>% purrr::map_dbl(~ifelse(is.null(.x),0,.x)))\n\n\n$a\n[1] 1 2 3\n\n$c\n[1] 0 1 2\n\n$d\n[1] 1 0 0\n\n$e\n[1] 1 0 3\n\n컬럼 단위는 잘 진행된 것 같습니다. 헌데 지금 예시야 숫자만 있지만,\n글자인 컬럼이 있거나 하면 에러가 날겁니다. list를\nvector로 풀면 될 것 같은데… 우리는 이미 그런 동작을 해주는\n함수를 알고 있습니다.\n\n\nmaps_party %>% \n  purrr::map(~ .x %>% purrr::map(~ifelse(is.null(.x),0,.x)) %>% unlist)\n\n\n$a\n[1] 1 2 3\n\n$c\n[1] 0 1 2\n\n$d\n[1] 1 0 0\n\n$e\n[1] 1 0 3\n\n같은 결과가 나왔군요! 패키지 코드에서는 이미 확인했지만, 컬럼이 여러\n자료형이어도 잘 동작합니다. 그럼 이제 만들어진 개별 list를\n컬럼으로 합치기만 하면 되군요! 드디어 처음에 설명했던\npurrr::map_dfc()함수를 사용할 차례인가 봅니다.\n\n\nmaps_party %>% \n  purrr::map_dfr(~ .x %>% purrr::map(~ifelse(is.null(.x),0,.x)) %>% unlist)\n\n\n# A tibble: 3 × 4\n      a     c     d     e\n  <dbl> <dbl> <dbl> <dbl>\n1     1     0     1     1\n2     2     1     0     0\n3     3     2     0     3\n\n중간에 unlist()를 사용하면서, 이미 개별 컬럼이\nlist가 아니게 되었네요. 감사하게 여기서는\ntidyr::unnest() 함수를 사용할 필요가 없어진 것\n같습니다.\n마치며\n다시 한 번 {purrr} 패키지의 강력함과 어려움을 동시에 느낄 수 있었던\n작업이었습니다. map()을 이 중으로 사용하면서\n.x이 대표하는 대상이 달라진다는 점이 재밌었는데요. 앞으로\n복잡한 list(json)를 다룰 때 더 수월하게 할 수\n있을 것 같습니다.\n감사합니다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106561891-dc30ef80-656c-11eb-8f14-e25c99bc7f5a.png",
    "last_modified": "2022-11-27T05:11:57+00:00",
    "input_file": {}
  },
  {
    "path": "post/rtips-데이터-프레임-안의-json을-가져와보자/",
    "title": "[Rtips] 데이터 프레임 안의 json을 가져와보자.",
    "description": "최근의 noSQL, 웹 기술의 발달로 json을 처리해야 하는 상황이 많아졌다. 특별히 data.frame의 셀이 json 텍스트인 경우가 있는데, map + fromJSON 으로 해결할 수 있다. json 이 모두 같은 key를 가지고 있다면, 정리하는데 매우 유용하다.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2018-11-19",
    "categories": [
      "R",
      "purrr",
      "json",
      "map"
    ],
    "contents": "\n\n세줄요약\n최근의 noSQL, 웹 기술의 발달로 json을 처리해야 하는 상황이\n많아졌다.\n특별히 data.frame의 셀이 json 텍스트인 경우가 있는데, map + fromJSON\n으로 해결할 수 있다.\njson 이 모두 같은 key를 가지고 있다면, 정리하는데 매우\n유용하다.\njson 자료형은 웹 시대에 교환 표준으로 자리잡고 있습니다.\n여러 장점이 있겠지만, 휴먼 리더블하면서 머신 리더블하다는게 가장 큰\n장점이지 않을까 싶네요. R도 데이터를 다루는데 json을\nlist자료형에 대응시켜서 적극적으로 활용하고 있습니다.\njson은 R에서\nlist다\n선언하듯 제목을 달았지만, json이 무엇인지 먼저 이해하면\n조금 더 좋을 것 같습니다. json은 공식홈페이지에서 한국어\n정의를 제공하고 있습니다. 가장 중요한 단어는 텍스트\n형식인데요. 맞습니다. json은 텍스트를 작성하는\n규칙입니다. 그러다보니 다양한 언어에서 json 형식에 따라\n작성된 텍스트는 자체 자료형으로 잘 변환해서 불러옵니다. R에서는 그\n자료형이 list 입니다. 매우 많은 패키지가 기능을 제공하지만\n가장 유명하게 사용하는 것은 jsonlite입니다. 많은\n패키지(대표적으로 httr)가\njson을 다루기 위해 jsonlite을 사용하고\n있습니다. 그리고 사용자입장에서는 그게 json은\nlist가 되는 것으로 보이게 처리되어 있죠. json\n자체에 대해 더 공부하고 싶으시면 wiki가 매우 잘 되어\n있습니다.\njson 양식의\n텍스트를 처리해보자\n우선 예시를 할만한 텍스트를 가져와보겠습니다.\n\n\njson_text <- '{\n    \"이름\": \"홍길동\",\n    \"나이\": 25,\n    \"성별\": \"여\",\n    \"주소\": \"서울특별시 양천구 목동\",\n    \"특기\": [\"농구\", \"도술\"],\n    \"가족관계\": {\"#\": 2, \"아버지\": \"홍판서\", \"어머니\": \"춘섬\"},\n    \"회사\": \"경기 수원시 팔달구 우만동\"\n }'\njson_text\n\n\n[1] \"{\\n    \\\"이름\\\": \\\"홍길동\\\",\\n    \\\"나이\\\": 25,\\n    \\\"성별\\\": \\\"여\\\",\\n    \\\"주소\\\": \\\"서울특별시 양천구 목동\\\",\\n    \\\"특기\\\": [\\\"농구\\\", \\\"도술\\\"],\\n    \\\"가족관계\\\": {\\\"#\\\": 2, \\\"아버지\\\": \\\"홍판서\\\", \\\"어머니\\\": \\\"춘섬\\\"},\\n    \\\"회사\\\": \\\"경기 수원시 팔달구 우만동\\\"\\n }\"\n\n\\n는 뉴라인의 표현으로 엔터라고 이해하시면 되겠습니다.\n규칙에 맞게 데이터를 가져오는 것을 파싱이라고 하는데, 이거 스스로\n만들려고 하면 아주 골치 아프게 생겼습니다. json은 매우\n광범위하게 사용하는 범용 양식이라, 많은 언어가 미리 파싱하는 패키지를\n만들어 관리하고 있습니다. R에서는 jsonlite를 가장 많이\n사용한다고 했구요.\n\n\nlibrary(jsonlite)\nfromJSON(json_text)\n\n\n$이름\n[1] \"홍길동\"\n\n$나이\n[1] 25\n\n$성별\n[1] \"여\"\n\n$주소\n[1] \"서울특별시 양천구 목동\"\n\n$특기\n[1] \"농구\" \"도술\"\n\n$가족관계\n$가족관계$`#`\n[1] 2\n\n$가족관계$아버지\n[1] \"홍판서\"\n\n$가족관계$어머니\n[1] \"춘섬\"\n\n\n$회사\n[1] \"경기 수원시 팔달구 우만동\"\n\nlist 자료형으로 잘 처리되었군요.\n그럼 이제 데이터 프레임 내에 있는 json 형식의 글자를\n처리해봅니다. 우선 그런 형태로 만들어 볼까요?\n\n\nnested_json <- data.frame(a = 1:5, b = rep(json_text, 5))\nnested_json\n\n\n  a\n1 1\n2 2\n3 3\n4 4\n5 5\n                                                                                                                                                                                                                                                 b\n1 {\\n    \"이름\": \"홍길동\",\\n    \"나이\": 25,\\n    \"성별\": \"여\",\\n    \"주소\": \"서울특별시 양천구 목동\",\\n    \"특기\": [\"농구\", \"도술\"],\\n    \"가족관계\": {\"#\": 2, \"아버지\": \"홍판서\", \"어머니\": \"춘섬\"},\\n    \"회사\": \"경기 수원시 팔달구 우만동\"\\n }\n2 {\\n    \"이름\": \"홍길동\",\\n    \"나이\": 25,\\n    \"성별\": \"여\",\\n    \"주소\": \"서울특별시 양천구 목동\",\\n    \"특기\": [\"농구\", \"도술\"],\\n    \"가족관계\": {\"#\": 2, \"아버지\": \"홍판서\", \"어머니\": \"춘섬\"},\\n    \"회사\": \"경기 수원시 팔달구 우만동\"\\n }\n3 {\\n    \"이름\": \"홍길동\",\\n    \"나이\": 25,\\n    \"성별\": \"여\",\\n    \"주소\": \"서울특별시 양천구 목동\",\\n    \"특기\": [\"농구\", \"도술\"],\\n    \"가족관계\": {\"#\": 2, \"아버지\": \"홍판서\", \"어머니\": \"춘섬\"},\\n    \"회사\": \"경기 수원시 팔달구 우만동\"\\n }\n4 {\\n    \"이름\": \"홍길동\",\\n    \"나이\": 25,\\n    \"성별\": \"여\",\\n    \"주소\": \"서울특별시 양천구 목동\",\\n    \"특기\": [\"농구\", \"도술\"],\\n    \"가족관계\": {\"#\": 2, \"아버지\": \"홍판서\", \"어머니\": \"춘섬\"},\\n    \"회사\": \"경기 수원시 팔달구 우만동\"\\n }\n5 {\\n    \"이름\": \"홍길동\",\\n    \"나이\": 25,\\n    \"성별\": \"여\",\\n    \"주소\": \"서울특별시 양천구 목동\",\\n    \"특기\": [\"농구\", \"도술\"],\\n    \"가족관계\": {\"#\": 2, \"아버지\": \"홍판서\", \"어머니\": \"춘섬\"},\\n    \"회사\": \"경기 수원시 팔달구 우만동\"\\n }\n\nfor으로 반복해서 하기\n예시 데이터 nested_json 에는 b 컬럼에 같은\njson_text 5개가 들어간 형태입니다. 데이터 프레임의 컬럼을\n다루려먼 어떤 방식이 가장 좋을까요? R이 아직 능숙하지 않으신 분들은\n아마도 for문으로 컬럼내의 셀 한개씩 접근해서 고치는 방법을\n생각해 볼 수 있을 것 같습니다. 데이터가 적다면 좋은 방법입니다! 코드가\n조금 느리더라도, 코드 작성이 오래 걸리는 것 보다는 훨씬 좋은\n방법입니다.\n\n\nfor (i in 1:nrow(nested_json)) {\n    nested_json[i,2] <- fromJSON(nested_json[i,2])\n}\nnested_json\n\n\n  a      b\n1 1 홍길동\n2 2 홍길동\n3 3 홍길동\n4 4 홍길동\n5 5 홍길동\n\n헐… json의 첫번째 데이터만 들어왔습니다. warnings\n잔뜩인거 보니, 그 경고를 주는 것 같네요! 모든 데이터를 얻기는 힘들 것\n같고… 그렇다면 선택적으로 데이터를 취할 수는 있을 것 같습니다.\n\n\nnested_json <- data.frame(a = 1:5, b = rep(json_text, 5))\nresult <- nested_json\nfor (i in 1:nrow(nested_json)) {\n    result[i,2] <- fromJSON(nested_json[i,2])[[\"특기\"]][1]\n    result[i,3] <- fromJSON(nested_json[i,2])[[\"특기\"]][2]\n}\nresult\n\n\n  a    b   V3\n1 1 농구 도술\n2 2 농구 도술\n3 3 농구 도술\n4 4 농구 도술\n5 5 농구 도술\n\n바로 데이터를 덮지 않고, result 객체를 따로 만들어 결과를\n저장했습니다. 이렇게 하지 않으면, 두 번째 특기를 가져올 때 문제가\n생기더라구요. 어떤 문제가 생기는지는 직접 한번 실행해 보시면 좋을 것\n같습니다.\n이거 for문으로 작성하는게 적당히 효율적일 수 있을 거는\n같은데, 좀 더 수월한 방법이 없을까요?\n{dplyr} 패키지의\nmutate() 함수\n{dplyr} 패키지의 mutate() 함수를 이용해서\nfromJSON() 함수를 적용해 볼까요? mutate()\n함수는 컬럼 기반의 연산을 지원하기 때문에 좋은 방법인 것 같습니다.\nlibrary(dplyr)\nnested_json %>% \n  mutate(b = fromJSON(b))\n## Error in mutate_impl(.data, dots) : \n##   Evaluation error: parse error: trailing garbage\n##           <U+0090>시 팔달구 우만동\"  } {     \"이름\": \"홍길동\",   \n##                      (right here) ------^\n이런 문제가 있군요?! 문제가 된다고 하는 곳을 살펴보니,\n} { 사이에 쉼표가 없습니다! 이름이라고 나오는 걸 보니\n새로운 셀의 값인거 같은데, 왜 이게 하나의 데이터인 것처럼 인지하는\n걸까요?ㅜㅠ\n얼른 떠오르기 좋은 방법이 안되는걸 확인했습니다. 그럼 어떻게 해야\n할까요?\n현대적인 방법의 apply :\nmap()\nR 언어는 vector 연산을 고려해서 만들었다고 합니다.\n그래서 for문의 효율이 매우 떨어지죠. apply()\n계열 함수를 사용하도록 권장하는데요. map() 함수는\nApply a function to each element of a list or atomic vector\n라는 제목에 걸맞게 현대적인 방식의 apply 계열의 함수입니다.\n{purrr} 패키지를 설치해야 사용할 수 있습니다.\n{tidyverse} 패키지가 설치되어 있다면, 포함되어 있으니 다시\n설치하지 않아도 됩니다.\ninstall.packages(\"purrr\")\n그럼 이제 mutate() 함수와 map() 함수를\n조합해 볼까요?!\n\n\nlibrary(purrr)\n\nnested_json <- data.frame(a = 1:5, b = rep(json_text, 5))\n\nnested_json %>% \n  mutate(b = map(b, fromJSON))\n\n\n  a\n1 1\n2 2\n3 3\n4 4\n5 5\n                                                                                               b\n1 홍길동, 25, 여, 서울특별시 양천구 목동, 농구, 도술, 2, 홍판서, 춘섬, 경기 수원시 팔달구 우만동\n2 홍길동, 25, 여, 서울특별시 양천구 목동, 농구, 도술, 2, 홍판서, 춘섬, 경기 수원시 팔달구 우만동\n3 홍길동, 25, 여, 서울특별시 양천구 목동, 농구, 도술, 2, 홍판서, 춘섬, 경기 수원시 팔달구 우만동\n4 홍길동, 25, 여, 서울특별시 양천구 목동, 농구, 도술, 2, 홍판서, 춘섬, 경기 수원시 팔달구 우만동\n5 홍길동, 25, 여, 서울특별시 양천구 목동, 농구, 도술, 2, 홍판서, 춘섬, 경기 수원시 팔달구 우만동\n\n드디어!! ,로 연결된거 같이 표시된 결과물이 나왔습니다.\n보기 불편하니 tibble 자료형으로 바꿔서 확인해 볼까요?\n\n\nnested_json %>% \n  mutate(b = map(b, fromJSON)) %>% \n  as_tibble()\n\n\n# A tibble: 5 × 2\n      a b               \n  <int> <list>          \n1     1 <named list [7]>\n2     2 <named list [7]>\n3     3 <named list [7]>\n4     4 <named list [7]>\n5     5 <named list [7]>\n\n무려 list랍니다. 휴… 이게 생각하기 복잡할 수 있지만서도,\n익숙해지면 좋은 구조입니다. 많은 데이터들이 2차원 테이블로만 구성하기가\n어려운 구조를 가지고 있기 때문입니다. 위의 예시 데이터도 b\n컬럼의 셀 안에 다 담기 어려운 구조이죠.\nR 최근 버전부터 이렇게 data.frame 자료형의 컬럼에\nlist를 지원하고 있습니다. 원래는 vector만\n됬었죠. 지금의 선택이 data.frame의 2차원 테이블형의\n직관적인 형태를 유지하면서, list의 자유도를 흡수하는 방법인\n것 같습니다. 대신 저는 그동안 list 자체를 이해하길 포기하고\n있었는데, 지금은 알아야만 하게 됬네요 ㅎㅎ\n마무리\nmap() 함수를 mutate() 함수와 함께 사용할\n수도, 단독으로 사용할 수도 있어서 좀더 어떻게 동작하는지 알아야 할 것\n같습니다. 다른 예시가 있을 때 한번 더 파볼께요. 감사합니다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106561761-983dea80-656c-11eb-8885-d7c0aa27cac8.png",
    "last_modified": "2022-11-27T05:10:07+00:00",
    "input_file": {}
  },
  {
    "path": "post/rtips-dplyr로-db-데이터를-다룰-때-여러-테이블을-union-해보자/",
    "title": "[Rtips] dplyr로 DB 데이터를 다룰 때 여러 테이블을 union 해보자",
    "description": "{dplyr}의 함수들은 `tbl()`과 `DBI::dbConnect()`를 사용해서 db table을 소스로 사용할 수 있다. 여러 테이블로 분산되어 있는 것을 `union()` 하는 것은 자주, 하지만 번거로운 일이다. table 이름을 받아와서 `map` 함수와 엮으면 짧은 코드로 한번에 많은 테이블들을 `union()` 해서 사용할 수 있다.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2018-11-16",
    "categories": [
      "R",
      "purrr",
      "map",
      "dbi",
      "dplyr",
      "postgres",
      "union"
    ],
    "contents": "\n\nContents\n{DBI} + {dplyr}\ndb내에서 테이블들을 rbind\n하려면\n여러\n테이블의 union\n여러 테이블의 union with\nreduce\n여러 테이블의 union\nwith map and reduce\n마치며\n\n\n세줄요약\n{dplyr}의 함수들은 tbl()과\nDBI::dbConnect()를 사용해서 db table을 소스로 사용할 수\n있다.\n여러 테이블로 분산되어 있는 것을 union() 하는 것은\n자주, 하지만 번거로운 일이다.\ntable 이름을 받아와서 map 함수와 엮으면 짧은 코드로\n한번에 많은 테이블들을 union() 해서 사용할 수 있다.\n데이터를 다루는데 있어 기업 환경에서는 데이터베이스에 접근하는 것을\n피할 수 없을 것입니다. R로 접근하여 다루는 것에 대해 자료가 많지 않아서,\n제가 찾은 요령을 공유할 겸 글을 작성해보겠습니다. 이미 {tidyverse}에\n길들여져 있다면, 좋아하실 만한 내용입니다.\n{DBI} 패키지\n{DBI} 패키지는 database interface 라는 뜻으로, perl의\nDBI나 python의 DB-API 같은 db를 연결하기 위한 기반 패키지입니다. R의\n{DBI} 패키지는 r-DBI 팀이 관리하고\n있습니다. {DBI} 뿐만 아니라 여타 DB들의 드라이버 패키지들을 포함해\n{odbc} 등도 제작, 관리하고 있죠. 제가 postgres 를 많이 쓰니까, 우선 R로\npostgres db와 연결하는 방법을 소개해 보겠습니다.\nlibrary(DBI)\nlibrary(RPostgres)\n\nconn <- dbConnect(\n  Postgres(),             # RPostgres에서 지원하는 드라이버 함수 입니다.\n  host = HOST,            # postgres가 있는 주소 입니다. 'ec2-54-83-201-96.compute-1.amazonaws.com'거나 로컬일 수도 있습니다.\n  port = 5432,            # 접근하기 위한 포트넘버 입니다. 5432는 postgres의 기본값이고, db에 설정된 값을 입력하면 됩니다.\n  user = 'postgres',      # 권한을 받은 db 계정입니다.\n  password = 'password',  # 관한을 받은 db 계정의 암호입니다.\n  bigint = \"numeric\",     # db에 저장된 매우 큰 숫자들은 DBI 패키지가 int64를 기본으로 가져옵니다. 익숙하지 않으면 numeric으로 가져오라고 설정합니다.\n  sslmode = \"require\"     # ssl 통신에 대한 설정입니다.\n)\nconn\n<PqConnection> ec2-54-83-201-96.compute-1.amazonaws.com:5439\n이제 db에 연결하는 작업이 끝났습니다. R로, 정확히는 {dplyr} 패키지로\ndb의 테이블들을 소스로 사용하기 위해서는 한가지 작업을 추가해야\n합니다.\n{DBI} + {dplyr}\nlibrary(dplyr)\ntar <- tbl(conn, \"table 이름\")\n{dplyr} 패키지의 tbl() 함수는 conn의 db\n연결 정보를 바탕으로 db 내의 테이블을 R 객체처럼 다룰 수 있게 해줍니다.\n예를 들어 위의 tar객체는 이제 R의\ndata.frame이나 tibble처럼 {dplyr} 문법으로\n이리저리 처리 할 수 있죠.\ntar %>% \n  select(col_name1)\n신경 써야 할 차이라면, tar는 collect() 함수를 사용하지\n않는 이상 DB에 있는 집계 결과 중 첫 몆줄만 보여주게 설계되어 있습니다.\n연산을 local R에서 하는 것이 아니라 DB에서 진행하죠. 그러다 보니 지금\n명령이 db에서 실행되는 것인지, R로 가져와서 실행하는 것인지 신경쓸\n필요가 있습니다. 대부분의 명령이 호환되지만 db에서 지원하지 않는 함수는\n동작하지 않기 때문에 잘 살펴봐야 합니다. 반대로 mutate나 summarise에서\nR에는 없지만 db에서 지원하는 함수를 사용할 수도 있습니다. 이 문제는 다음\n포스트에서 다루기로 하겠습니다.\ndb내에서 테이블들을 rbind\n하려면\nrbind()는 R에서 data.frame을 행방향으로\n합치는 기능을 수행합니다. {dplyr}에서는 bind_rows()함수로\n제공합니다. db src인 상황에서는 둘다 동작하지 않습니다. 아래와 같은\n에러를 뿜죠.\nError in bind_rows_(x, .id) : \n  Argument 1 must be a data frame or a named atomic vector, not a tbl_dbi/tbl_sql/tbl_lazy/tbl\n사실 bind_rows()함수는 데이터를 판단하지 않고, 겹치는\n값에 상관없이 두 테이블을 위-아래 방향으로 합쳐줍니다. 반면에\nunion()함수는 겹치는 행이 있을 때 유일한 값만 두고\n합칩니다.\nunion()\nbind_rows() %>% unique()\n이렇게가 같은 동작이라고 이해하면 좋을까요? {dplyr}에서\nunion() 함수를 지원하고 있습니다만, db에서도 같은 동작을\n지원합니다. 그래서 db src 일때는 union() 함수를\n사용해하죠.\ntar1 <- tbl(conn, \"table1\")\ntar2 <- tbl(conn, \"table2\")\n\ntarAll <- union(tar1, tar2)\n테이블 구조가 다르면 에러가 나는 걸로 알고 있습니다만, 확인해봐야 할\n것 같습니다. 그래도 구조가 같다고 알고 있는 여러 테이블을 합치려면,\nunion()함수가 꼭 필요합니다. 이때 그럼 테이블 갯수가\n많아지면 어떻게 해야 할까요?\n여러 테이블의 union\n{DBI} 패키지에서는 dbListTables()라는 함수를 제공하기\n때문에 테이블 이름을 가져올 수 있습니다. schema에 들어가 있는 테이블\n리스트는 제가 방법을 찾지 못해 쿼리로 해결하였습니다.\nlibrary(DBI)\nlibrary(dplyr)\ntables <- dbGetQuery(conn,\n             \"SELECT table_name FROM information_schema.tables\") %>%\n    arrange(table_name)\ntables\n위 쿼리에 WHERE table_schema = \"schema_name\"를 추가하여\n특정 스키마 내의 테이블만 확인할 수 도 있습니다. 아무튼 테이블 이름을\n전부 가져왔다면, 필요한 테이블만 골라 봅시다. 같은 종류의 테이블을\n합쳐야 하니 보통은 네이밍 규칙에 따라 같은 이름으로 작성된 부분이 있을\n것 입니다. 예를 들어 커머스라면 판매 테이블이 거대한 한가지 일 수도\n있지만, 카테고리나 여러 의미 단위로 잘라져 여러 테이블로 되어 있기도\n합니다. 아마 category_name1_sales_recodes 같은 식이겠죠?\n그럼 _sales_recodes로 끝나는 이름의 테이블들을 전부\n가져오도록 합시다.\ntar_tables <- tables %>% \n  filter(grepl(\"_sales_recodes$\", table_name))\ntar_tables\n이제 이 테이블들을 연결해 보겠습니다. 간단히 생각해보면 for 문을\n돌리면 되겠네요? 여기서 전략이 여러 가지로 갈리겠습니다만, 저는 리스트에\n넣는 방식으로 진행해 보겠습니다.\ntar_list <- list()\nnum_of_tables <- nrow(tar_tables)\nfor(i in 1:num_of_tables) {\n  tar_list[[i]] <- \n    tbl(conn, tar_tables[i, 1])\n}\nunion(tar)\nError in base::union(x, y, ...) : \n  argument \"y\" is missing, with no default\n아 이런! union() 함수가 리스트 내의 db src 들을 인지하지\n못하는군요. 저는 처음에 그래서 최대한 필터링, 전처리 하고\ncollect() 함수로 불러온 결과를 tar_list에\n저장한 후 bind_row()하는 선택을 했었습니다.\ntar_list <- list()\nnum_of_tables <- nrow(tar_tables)\nfor(i in 1:num_of_tables) {\n  tar_list[[i]] <- \n    tbl(conn, tar_tables[i, 1]) %>% \n    filter(exampe) %>% \n    group_by(col_1) %>% \n    summarise(n = n()) %>% \n    collect()\n}\nbind_rows(tar)\n이러면 동작은 잘 하는데, collect() 할 때 연산 시간이\n너무 많이 걸린다는 문제가 있습니다. 이미 거대 데이터를 다루는 건 db에게\n넘기기로 한 이상, 최대한 db에서 연산하도록 하고 한번만 가져오는 것이\n효율적이죠. 그럼 아예 전부 union()하고 그 db src 객체를\n다뤄서 가져오면 좋겠군요?!\n여러 테이블의 union with\nreduce\nreduce() 함수는 list 자료형의 데이터를\n다음에 지정하는 함수로 합쳐주는 기능을 합니다. {purrr}라는 패키지에 속해있죠.\nlist 자료형을 다루는데 매우 효과적이며 익명 함수 같은\n방식으로 작성하기 좋게 되어 있습니다.\nlibrary(purrr)\ntar_list <- list()\nnum_of_tables <- nrow(tar_tables)\nfor(i in seq_len(num_of_tables)) {\n  tar_list[[i]] <- \n    tbl(conn, tar_tables[i, 1])\n}\nreduce(tar_list, function(x,y) union(x,y))  %>% \n  filter(exampe) %>% \n  group_by(col_1) %>% \n  summarise(n = n()) %>% \n  collect()\n저도 찾아서 작성한 코드라 왜 익명 함수로 작성해야 동작하는지 아직\n이해하지 못했습니다만, 어쨌든 합치고 한번만 collect() 할 수\n있게 되었습니다! 물론 저렇게 다 합치고 연산을 했을 때 기대한 결과물이\n나오는 것인지는 세심히 확인해야 할 것 같습니다.\n그런데 {purrr} package는\nmap()이라는 함수도 제공합니다.\n여러 테이블의 union\nwith map and reduce\nmap() 함수는 base R 에서 apply가 담당하는 벡터 연산의\n현대적인 부분을 담당합니다. {purrr}가 {tidyverse}에 속해 있는 걸로\n충분한 설명이 되는 것 같네요. 제가 map() 함수 이야기를\n꺼내는 이유는 for를 없애고 싶기 때문입니다. 리스트 자료형에\n저장하고, i 신경 쓰고 하는 일련의 것들을 버리고\n싶은거죠.\n우선 코드를 작성하고 살펴볼까요?\ntar_tables %>% \n  .$table_name %>% \n  map(~ tbl(conn, .x)) %>% \n  reduce(function(x,y) union(x,y)) %>% \n  filter(exampe) %>% \n  group_by(col_1) %>% \n  summarise(n = n()) %>% \n  collect()\n음? 아까 for로 짜던 부분이 한줄(???!??!!?)이 되었군요?\n(물론 map()이 받을 수 있게 character vector로 변환한 줄까지\n하면 2줄입니다.) 이렇게 하면 테이블 이름을 map()함수가\n받아서 tbl()로 연결 객체를 만들고, reduce() +\nunion()으로 하나의 테이블로 합쳤습니다. 이제 필요한 테이블\n전체를 하나의 테이블로 합친 후 필요한 작업을 하고,\ncollect()하면 끝입니다.\n마치며\nR에서 for 가 느리기 때문에 사용을 자제하며, dplyr의\ncolumn-wise mutate나 apply 계열 함수들을 추천해왔는데요. 이제\npurrr::map()로 더 다양한 조건에서 for를\n배제하고 코드를 작성할 수 있게 되었습니다. 물론 처음 시작할 때부터\n이렇게 작성하는 것은 매우 위험합니다. 자신이 보고 읽어서 이해할 수 있는\n코드가 좋은 코드인 것이죠. 극단적으로 저는 namespace 문제와 여러 함수가\n패키지의 겹침 문제가 있어서 가능하면 namespace를 지정하는 방식으로\n코드를 짭니다. 물론 제가 skimming 할때는 아니지만, 스크립트를 저장할 때\n말이죠.\n마지막 코드의 장점은 같은 구조의 테이블이 얼마나 늘어나던지 상황하지\n않고 전부 합쳐준다는 점입니다. 구조의 변경이 없다는 가정하에 매우 강건한\n코드라고 할 수 있죠.\n그럼 모두 {purrr}의 세계에 한번 깊게 빠져보시기 바랍니다.\n감사합니다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106561491-1ea5fc80-656c-11eb-8b86-055653bef9f7.png",
    "last_modified": "2022-11-27T05:10:00+00:00",
    "input_file": {}
  },
  {
    "path": "post/번역-폴더안의-csv-파일들을-purrr-와-readr-을-이용해서-한방에-불러오기/",
    "title": "[번역]폴더안의 csv 파일들을 {purrr}와 {readr}을 이용해서 한방에 불러오기",
    "description": "{purrr}의 `map_dfr()` 함수로 폴더내의 파일 리스트를 한번에 불러올 수 있습니다.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2018-10-27",
    "categories": [
      "R",
      "purrr",
      "readr",
      "csv",
      "read"
    ],
    "contents": "\n\n본 번역은 원글을\n대상으로 CC-BY 라이선스를\n사용하고 있어 마음껏 번역하였습니다.\n요약 : {purrr}의 map_dfr() 함수로 폴더내의 파일 리스트를\n한번에 불러올 수 있다.\n\n이번 포스트는 tidyverse 패키지에 속한 두\n패키지(purrr&readr)를 사용해서 csv 파일\n리스트를 하나의 data.frame으로 불러오는 방법을 설명합니다. 또한\nfs라는 새로운 파일 시스템 대응 패키지를 사용합니다.\n\n\n# 필요한 패키지를 설치합니다. \n# install.packages(c(\"tidyverse\", \"fs\"))\n\nlibrary(tidyverse)  # purrr와 readr을 불러옵니다.\nlibrary(fs)\n\n\n\n문제 상황 설정\n규칙적인 데이터를 포함하는 CSV 파일들이 한 디렉토리에 있다고\n가정합니다. 즉, 각 데이터 세트의 열이 모두 동일하거나 적어도 중복되는\n열이 동일하다는 것을 의미한다고 가정합니다.\n우리는 디렉토리 안의 모든 CSV 파일을 읽어서 각각의 파일을 불러온 작은\n데이터셋을 합쳐 하나의 큰 데이터셋으로 만들고 싶습니다.\n예제 데이터\n예를 좀 더 구체적으로 설명하기 위해 아일랜드\n정부가 제공한 데이터셋을 사용하겠습니다. 이 데이터셋은 병원 부서별\n연간 온라인 추천수로, 각 년도별로 파일이 구분되어 있습니다.\n데이터는 data.gov.ie에서\n개별 csv 파일들을 다운로드 받거나, 미리 준비한 압축\n파일을 다운 받을 수 있습니다.\n한 폴더 내에 csv 파일들을 다운로드 받았거나, 압축 파일을 풀어놓은\n후에 data_dir 객체에 경로를 지정합니다.\n\n\ndata_dir <- \"ie-general-referrals-by-hospital\"\n\n\n\nfs::dir_ls() 함수를 사용해서 폴더내의 파일 리스트를\n가져올 수 있습니다.\n\n\nfs::dir_ls(data_dir)\n\n\nie-general-referrals-by-hospital/README.txt\nie-general-referrals-by-hospital/general-referrals-by-hospital-department-2015.csv\nie-general-referrals-by-hospital/general-referrals-by-hospital-department-2016.csv\nie-general-referrals-by-hospital/general-referrals-by-hospital-department-2017.csv\nie-general-referrals-by-hospital/general-referrals-by-hospital-department-2018.csv\n\n리스트를 보니 README.txt 파일이 추가로 있습니다. 이\n파일은 우리가 불러오고자 하는 파일이 아닙니다. 그렇기 때문에 폴더 내의\n파일 리스트를 불러올 때 csv 파일 형식으로만 제한할 필요가 있습니다.\n파일명이 .csv로 끝나는 것들만 조건을 주면 좋겠습니다.\n\n\ncsv_files <- fs::dir_ls(data_dir, regexp = \"\\\\.csv$\")\ncsv_files\n\n\nie-general-referrals-by-hospital/general-referrals-by-hospital-department-2015.csv\nie-general-referrals-by-hospital/general-referrals-by-hospital-department-2016.csv\nie-general-referrals-by-hospital/general-referrals-by-hospital-department-2017.csv\nie-general-referrals-by-hospital/general-referrals-by-hospital-department-2018.csv\n\n파일 전체를 불러오기\n우선 한 파일을 불러오기\n각 csv 파일들을 readr::read_csv() 함수를 이용해서 각각\n불러올 수 있습니다. 한 파일만 먼저 예시로 불러와 보겠습니다.\n\n\nreadr::read_csv(csv_files[1])\n\n\n# A tibble: 837 × 6\n   Month_Year Hospital_Name  Hospital_ID Hospital_Depart… ReferralType\n   <chr>      <chr>                <dbl> <chr>            <chr>       \n 1 Aug-15     AMNCH                 1049 Paediatric ENT   General Ref…\n 2 Aug-15     AMNCH                 1049 Paediatric Gast… General Ref…\n 3 Aug-15     AMNCH                 1049 Paediatric Gene… General Ref…\n 4 Aug-15     Bantry Genera…         704 Gastroenterology General Ref…\n 5 Aug-15     Bantry Genera…         704 General Medicine General Ref…\n 6 Aug-15     Bantry Genera…         704 General Surgery  General Ref…\n 7 Aug-15     Bantry Genera…         704 Medicine for th… General Ref…\n 8 Aug-15     Bantry Genera…         704 Outreach Dermat… General Ref…\n 9 Aug-15     Bantry Genera…         704 Outreach Orthop… General Ref…\n10 Aug-15     Bantry Genera…         704 Outreach Surgic… General Ref…\n# … with 827 more rows, and 1 more variable: TotalReferrals <dbl>\n\n전체 파일 불러오기로\n확장하기\n\n디렉토리의 모든 파일을 읽으려면 purrr::map()을 사용하여\nread_csv()를 파일 목록에 매핑(map)합니다.\n그러나 각 list() 내의 요소가 tibble(또는 data.frame)이 될 것이고 각\n데이터 프레임이 동일한 열을 가짐을 알고 있으니, purrr의 타입 지정 함수인\npurrr::map_dfr()를 사용하여 가져온 CSV 파일 각각을 포함하는\n단일 data.frame으로 가져와 보겠습니다. *_dfr()가 추가로\n달려있는 함수들은 각 요소를 행결합(row-binding)하여 data.frame을\n반환하도록 합니다.(이것은 map() %>% bind_rows() 를\n호출하는 것과 같습니다.)\n\n\ncsv_files %>% \n  map_dfr(read_csv)\n\n\n# A tibble: 12,278 × 6\n   Month_Year Hospital_Name  Hospital_ID Hospital_Depart… ReferralType\n   <chr>      <chr>                <dbl> <chr>            <chr>       \n 1 Aug-15     AMNCH                 1049 Paediatric ENT   General Ref…\n 2 Aug-15     AMNCH                 1049 Paediatric Gast… General Ref…\n 3 Aug-15     AMNCH                 1049 Paediatric Gene… General Ref…\n 4 Aug-15     Bantry Genera…         704 Gastroenterology General Ref…\n 5 Aug-15     Bantry Genera…         704 General Medicine General Ref…\n 6 Aug-15     Bantry Genera…         704 General Surgery  General Ref…\n 7 Aug-15     Bantry Genera…         704 Medicine for th… General Ref…\n 8 Aug-15     Bantry Genera…         704 Outreach Dermat… General Ref…\n 9 Aug-15     Bantry Genera…         704 Outreach Orthop… General Ref…\n10 Aug-15     Bantry Genera…         704 Outreach Surgic… General Ref…\n# … with 12,268 more rows, and 1 more variable: TotalReferrals <dbl>\n\n전체 파일을 불러올 때 추가\n설정하기\nMonth_Year 컬럼이 날짜/시간 자료형이 아니라 글자로\n불러와져 있는 것을 알 수 있습니다. read_csv() 함수의 인자를\nread_csv()함수에서 사용하는 것 처럼 map_dfr()\n안에서 사용할 수 있습니다.(역자 주: read_csv() 함수에서\n컬럼의 자료형을 지정하는 형태의 인자를 뜻합니다. 개인적으로는 다음\n방법인 불러온 후 수정하는 방식을 선호합니다.)\n\n\ncsv_files %>% \n  map_dfr(read_csv, col_types = cols(\"Month_Year\" = col_date(format = \"%b-%y\")))\n\n\n# A tibble: 12,278 × 6\n   Month_Year Hospital_Name  Hospital_ID Hospital_Depart… ReferralType\n   <date>     <chr>                <dbl> <chr>            <chr>       \n 1 2015-08-01 AMNCH                 1049 Paediatric ENT   General Ref…\n 2 2015-08-01 AMNCH                 1049 Paediatric Gast… General Ref…\n 3 2015-08-01 AMNCH                 1049 Paediatric Gene… General Ref…\n 4 2015-08-01 Bantry Genera…         704 Gastroenterology General Ref…\n 5 2015-08-01 Bantry Genera…         704 General Medicine General Ref…\n 6 2015-08-01 Bantry Genera…         704 General Surgery  General Ref…\n 7 2015-08-01 Bantry Genera…         704 Medicine for th… General Ref…\n 8 2015-08-01 Bantry Genera…         704 Outreach Dermat… General Ref…\n 9 2015-08-01 Bantry Genera…         704 Outreach Orthop… General Ref…\n10 2015-08-01 Bantry Genera…         704 Outreach Surgic… General Ref…\n# … with 12,268 more rows, and 1 more variable: TotalReferrals <dbl>\n\n날짜 자료형 문제를\n불러오기 이후에 처리하기\nread_csv() 함수의 인자를 설정하면, 대부분의 파일에서 잘\n동작합니다. 하지만, 2016년에 Month_Year의 양식이\nJan-15에서 Jan-2016로 바뀌어서 2016년과 2017년\n데이터가 NA로 불러와지고 말았습니다.\n이것을 고치는 가장 쉬운 방법은, 글자 자료형 그대로 불러온 후에\nlubridate 패키지의 날짜 변환 함수를 사용하는 것입니다.\nreadr의 col_date() 함수는 하나의 포멧만 허용하기 때문입니다.\n\n\nlibrary(lubridate)\n\ncsv_files %>% \n  map_dfr(read_csv) %>%\n  mutate(Month_Year = myd(Month_Year, truncated = 1))\n\n\n# A tibble: 12,278 × 6\n   Month_Year Hospital_Name  Hospital_ID Hospital_Depart… ReferralType\n   <date>     <chr>                <dbl> <chr>            <chr>       \n 1 2015-08-01 AMNCH                 1049 Paediatric ENT   General Ref…\n 2 2015-08-01 AMNCH                 1049 Paediatric Gast… General Ref…\n 3 2015-08-01 AMNCH                 1049 Paediatric Gene… General Ref…\n 4 2015-08-01 Bantry Genera…         704 Gastroenterology General Ref…\n 5 2015-08-01 Bantry Genera…         704 General Medicine General Ref…\n 6 2015-08-01 Bantry Genera…         704 General Surgery  General Ref…\n 7 2015-08-01 Bantry Genera…         704 Medicine for th… General Ref…\n 8 2015-08-01 Bantry Genera…         704 Outreach Dermat… General Ref…\n 9 2015-08-01 Bantry Genera…         704 Outreach Orthop… General Ref…\n10 2015-08-01 Bantry Genera…         704 Outreach Surgic… General Ref…\n# … with 12,268 more rows, and 1 more variable: TotalReferrals <dbl>\n\n파일명 컬럼 추가하기\n데이터를 사용하다보면 보고 있는 값이 어느 파일에서 나온 것인지\n확인하고 싶을 떄가 있습니다(역자주: 지금의 구조에서는 년도로 구분되어\n있기 때문에 날짜 컬럼을 확인하면 됩니다만, .id 인자는\nbind_rows() 함수에서도 유용하게 사용하는 것이니 알아두면\n좋습니다.). map_dfr() 함수의 .id 인자를\n지정하고 싶은 컬럼명(지금은 source)을 작성하는 것으로\n사용하면, source 컬럼이 해당 파일이름이 추가되어 최종\n데이터셋에 반영됩니다.\n\n\ncsv_files %>% \n  map_dfr(read_csv, .id = \"source\") %>%\n  mutate(Month_Year = myd(Month_Year, truncated = 1))\n\n\n# A tibble: 12,278 × 7\n   source        Month_Year Hospital_Name Hospital_ID Hospital_Depart…\n   <chr>         <date>     <chr>               <dbl> <chr>           \n 1 ie-general-r… 2015-08-01 AMNCH                1049 Paediatric ENT  \n 2 ie-general-r… 2015-08-01 AMNCH                1049 Paediatric Gast…\n 3 ie-general-r… 2015-08-01 AMNCH                1049 Paediatric Gene…\n 4 ie-general-r… 2015-08-01 Bantry Gener…         704 Gastroenterology\n 5 ie-general-r… 2015-08-01 Bantry Gener…         704 General Medicine\n 6 ie-general-r… 2015-08-01 Bantry Gener…         704 General Surgery \n 7 ie-general-r… 2015-08-01 Bantry Gener…         704 Medicine for th…\n 8 ie-general-r… 2015-08-01 Bantry Gener…         704 Outreach Dermat…\n 9 ie-general-r… 2015-08-01 Bantry Gener…         704 Outreach Orthop…\n10 ie-general-r… 2015-08-01 Bantry Gener…         704 Outreach Surgic…\n# … with 12,268 more rows, and 2 more variables: ReferralType <chr>,\n#   TotalReferrals <dbl>\n\n마무리\n본 포스트는 fs 패키지, purrr 패키지,\nreadr 패키지를 활용해서 폴더 내의 파일들 리스트를 가져와서\ntidyverse 패키지의 도구들도 분석하기 좋은 상태인 하나의\ndata.frame으로 불러오는 작은 예제를 제공한다.\n한번에 동작하는 코드 전체는 아래와 같다.\ndata_dir %>% \n  dir_ls(regexp = \"\\\\.csv$\") %>% \n  map_dfr(read_csv, .id = \"source\") %>% \n  mutate(Month_Year = myd(Month_Year, truncated = 1))\ndir_ls() 함수로 data_dir 폴더내의 파일 리스트를\n가져와서, read_csv() 함수를 map_dfr() 함수와\n함께 리스트의 파일들을 한번에 불러옵니다. .id 인자로\nsource 컬럼을 추가하여 어느 파일에서 나온 데이터인지 최종\n데이터셋에서 확인할 수 있습니다. 이제 dplyr 패키지로\n데이터를 처리 할 준비가 되었습니다.\n코드는 조금만 바꿔서 SAS 파일이나 Excel 파일 같은 다른 파일 형식을\n위한 형태로 고칠 수 있습니다. read_csv() 함수를\nhaven::read_sas()나 readxl::read_xlsx()로\n바꾸고 regexp 인자를 해당 확장자명으로 고치는 것입니다.\nIn future posts, we’ll also look at other ways we merge a folder of\ndata files besides “stapling” them together row-wise with map_dfr().\n(역자주: stapling이 어떤 의미인지 이해하지 못해서 마지막\n문장은 원문으로 두었습니다.)\n역자 의견\npurrr 패키지는 저도 아직\n이해를 잘 못하고 있지만, 제대로 쓰기를 기대하는 패키지 중 하나 입니다.\nR이 for문의 성능이 떨어지기 때문에 apply계열 함수를 잘 사용해야 한다는\n이야기들을 하지만, 모던 R 프로그래밍에서는 purrr 패키지의\nmap_*() 계열 함수를 잘 사용해야 하는 것 같습니다.\nKRUG에서\n언뜻 map()으로 어떤 처리코드보다도 빠르게 동작하는 코드를\n공유해주신 분을 기억합니다. 덕분에 관심만 두고 있었는데, 빨리 더\n살펴봐야 겠네요.\n글의 내용과는 무관하게 본 포스트는 총 4줄의 코드를 설명하고 있습니다.\n반성을 많이 하게 되네요.\n\n\n\n",
    "preview": {},
    "last_modified": "2022-11-27T05:11:00+00:00",
    "input_file": {}
  },
  {
    "path": "post/r과-python-중에-어떤-것을-공부해야-할까/",
    "title": "R과 Python 중에 어떤 것을 공부해야 할까",
    "description": "우선 뭐든지 시작하세요!",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2018-10-10",
    "categories": [
      "R",
      "python",
      "study",
      "discuss"
    ],
    "contents": "\n\nContents\n어디에\n사용할 것인가?\npython이 왜 이렇게\n인기인가?\n뭘 기준으로 선택하면\n좋을까?\n왜 이런 기준을 세웠는가?\n그럼\nIDE는 R은 Rstudio, python은 jupyter | pycharm 을 써야 하나?\n다시\n돌아가서 결론은?\n다른\n기준이 또 있나?\n각각의 생태계가 다르다던데\n\n\n한줄요약\n뭐든지 우선 시작하세요!\n이미 한물가고 필요없는 논의일 수도 있지만, 개인적을 생각을 정리한다고\n생각하고 글을 시작해보겠습니다. R을 충분히 사용하고 있는 사용자로서,\npython은 뭐 1년 이상은 쓴 사용자로서 느끼는 점을 공유하고자 합니다.\n개인적인 의견이므로 토론 대환영, 제가 모르는 정보 제공 대환영입니다.\n어디에 사용할 것인가?\n물론 데이터를 분석하는데 사용할 것입니다. R과 python은 지위가 매우\n비슷합니다. 물론 python은 좀더 본격적인 범용 개발언어이고, R은 다 할 수\n있지만, 통계쪽으로 특화된 패키지가 많습니다. C, Cpp, fortran 등 저수준\n언어로 만들었고, 문법이 쉽습니다. 여러 외부의 리소스를 잘 활용하는\n편입니다. 데이터 분석이라는 분야에서 유명합니다.\n뭐가 다른가?\n터미널, bash, 쉘 이라는 단어를 모르신다면 배워야 하는 것이 python,\n몰라도 되는 것이 R입니다. 물론 Unix 계열에서 사용하시면 어짜피 그걸\n쓰신다는건 안다는 소리니 패스입니다. OOP가 뭔지 알아야 python은 좀 잘 쓸\n수 있고, R을 몰라도 됩니다. 이 차이는 제가 느끼기엔 python은 뭔가\n사용자가 개발자이어서 만드는 소스 모두가 패키지이기를 기대하는 것\n같았습니다. R은 패키지 사용자가 개발을 잘 모르기 때문에 쉽게\n만들어주어야 한다는 느낌이 있습니다. 패키지 수 등을 보면 python 생태계가\n10배쯤 큰데요. 물론 범용이기 때문이기도 하지만, R은 패키지 제작자도 많지\n않고 좀 어려운 느낌이 있습니다.\npython이 왜 이렇게 인기인가?\n저는 딥러닝 때문이라고 봅니다만, 잘 모르겠습니다. 건너 듣기로는\npython 배우는 건 어렵다는 걸 사람들이 알기 시작했다고 하기도 하고.\n그렇다고 그 사람들이 사용하기에 R이 좋은가 하면 그렇지도 않은 것\n같습니다. 암튼 제 생각은 python이 R보다 좋다기 보단, 그냥 유행인거 라고\n생각해봅니다. (물론 제가 R 사용자니 사견이 많이 담긴 해석일 수\n있습니다.)\n뭘 기준으로 선택하면 좋을까?\n저는 고독한 R 사용자(?)로 거의 영어 문서에 기반해서 독학했습니다.\n물론 덕분에 패키지 개발등 좀더 유틸리티 패키지 개발자로 역할을 할 수\n있었겠지요. 제 작은 희망이 있다면, R 사용자와 함께 회사일을 하는\n것입니다. 그렇기에 직장인과 학생으로 나누어 조언을 하자면, 학생은 컴공\n베이스라면 python을, 아니라면 R을 추천드립니다. 요즘은 워낙 기본서도\n많이 나와있는 편이라, 어느 정도의 삽질을 통해 독학하거나 공부하실 수\n있습니다. 직장인이라면, 직접 물어볼 수 있는 사람중에 python과 R 사용자가\n있는지를 기준으로 보면 좋을 것 같습니다. 뭐가 다른가? 에서 파이썬이 더\n많이 공부해야 하는 것처럼 묘사했지만, 봐줄 사람이 있다면 넘지 못할\n공부도 아닙니다. 숫자 시작이 0이라는 건 익숙해지면 될 일인거죠. 물론\n제가 OOP를 작성하거나 사용하는 법을 이해하는데 2년쯤\n걸렸습니다만….(…)\n왜 이런 기준을 세웠는가?\npython과 R은 사실 공생관계입니다. python의 pandas는 R의 기본 자료형인\ndata.frame을 모방한 패키지입니다. R에는 reticulate 패키지가 python의\nnative-wrapper 패키지로 동작합니다. 덕분에 python 패키지 모두를 R에서\n사용할 수 있죠. python에서도 마찬가지로 rpy2 패키지로 R을 모두 사용할 수\n있습니다.\n그럼\nIDE는 R은 Rstudio, python은 jupyter | pycharm 을 써야 하나?\n저도 상황에 따라 사용하긴 합니다만, 처음 배운 도구에서 벗어날 수 없는\n것처럼 저는 jupyter가 너무 싫습니다. rstudio에서 이제 python을 지원하기\n때문에 마음껏 rstudio 사용하면 됩니다. 기다린 보람이 있어서, python에서\n만든 객체를 R에서 사용하는 등 호환이 좋네요. jupyter는 반대로 꽤 일찍\nR을 사용할 수 있었습니다. 원체 범용 repl 도구로 개발되었었고, 최근\njupyter hub 같이 좀더 ide 같아지면서 좀 쓸만해졌다고는 합니다. pycharm은\n제가 잘 안쓰게 되서 잘 모르겠습니다. 더욱 개발자들인 분들이 쓰기 좋은\n기능들을 많이 가지고 있는 인상이었습니다. 제가 쓰는 수준에서는 Rstudio로\n충분했습니다. 이것도 한번 소개해야 겠네요. 저는 rstudio server 버전이\n있어서 docker랑 호환이 좋은게 너무 좋네요.\n다시 돌아가서 결론은?\n저만 봐도 R을 주력으로 쓰지만, Python, node 등 가리지 않고 사용하는\n편입니다. (물론 Java는 정말 싫어해서 처다보고 있지도 않습니다만,\n사용자층이 두터운데는 이유가 있겠죠.) 한줄 요약에도 있지만, 뭐가 되었든\n우선 시작하세요. 하루라도 빨리 배우시는게 자신의 미래의 위해서 좋은 것\n같습니다. 자신이 무엇을 모르는지 모르는 단계에서 벗어나셔야 성장할 수\n있습니다.\n다른 기준이 또 있나?\n상황을 개인만으로 한정해 보자면, 개발과 비개발로 나누어 자신의 성향이\n좀더 개발쪽이면 python, 비개발쪽이면 R을 하라고 이야기해준 적이\n있습니다. 또 범용 개발 언어라는 특성이 있어, 좀 더 일반적인 개발을 함께\n할 계획이라면 python을, 아니라면 R을 추천했었습니다. 다양한 일을 해야\n된다고 하면 저라면 단연 R을 추천드리겠습니다만, python이 조금 더 나은\n선택일 수 있습니다. 단적인 예로 마우스 오토메이션 관련된 패키지가\npython에는 5개 이상인데, R에는 2개(모두 기능이 제한적임) 뿐입니다.\n각각의 생태계가 다르다던데\n맞습니다. python은 단연코 개발자 생태계입니다. 우리 나라에도 회사에서\n주변을 보면(it 회사라면) python 하시는 분들이 참 많습니다. R은 해외의\n통계학자들과 생물통계학자들을 위한 도구로 성장했기 때문에 학계\n생태계입니다. 놀랍게도 C++을 함께 사용하는 것이 당연한 분들이\n많습니다.(저는 아직 멀었습니다. 흑흑) 최근에는 비즈니스로 사용하시는\n분들이 많아지는 추세이긴 합니다.\n위에서도 이야기했지만, 저의 “인상”을 작성한 것이기 때문에 사실과\n괴리가 매우 클 수 있습니다. 언제든 내용 수정, 토론, 의견, 대환영입니다.\n감사합니다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106514604-d2c96800-6517-11eb-8766-1641b8626a6e.png",
    "last_modified": "2022-11-27T05:10:10+00:00",
    "input_file": {}
  },
  {
    "path": "post/업무자동화-r로-마우스를-조작하려면-rmouse/",
    "title": "[업무자동화] R로 마우스를 조작하려면 rMouse",
    "description": "java 의존성이 없는 KeyboardSimulator패키지가 소개되었습니다. Windows 에서만 동작합니다.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2018-10-08",
    "categories": [
      "R",
      "rmouse",
      "automation",
      "mouse"
    ],
    "contents": "\n\nContents\n업데이트\n\n\n업데이트\njava 의존성이 없는 KeyboardSimulator\n패키지가 소개되었습니다. Windows 에서만 동작합니다.\n한줄요약\nR 스크립트로 키보드/마우스를 다루는 rMouse 패키지를 사용할 수\n있다.\n메일을\n보내는 포스트를 작성하고 아니 업무자동화 키워드에 해당하는 패키지에\n관심이 생겼습니다. 많은 업무가 웹에서 이루어진다면, 웹 api로\n제공해주거나 브라우저 자동화 등을 사용할 텐데요. 어쩔 수 없이 브라우저\n밖의 프로그램 들을 자동화할 일들이 있습니다. 이때 사용하는 것이\n키보드/마우스 메크로 입니다.\nR 스크립트로 동작하는 것이 없는지 찾아봤는데요. 놀랍게도 있었습니다!\n바로 rMouse\n패키지입니다. 무려 작년 중순께 나온 싱싱한(?) 패키지입니다. 놀라운건\n코드 공개를 안하셔서 문의를 메일로 해야 하네요 ㅎㅎ\n설치\n자바 의존성이 있는 패키지라 자바와 rJava 패키지가 필요합니다. 지난\n포스트에 설명이 잘 나와있어서 이제 자바 의존성 패키지가 두렵지\n않습니다!\ninstall.packages(\"rMouse\")\nlibrary(rMouse)\nsetAutoDelay()\n처음에 패키지가 실행되는 시간이 필요해서 setAutoDelay()\n함수를 제공해준다고 합니다. library(rMouse) 다음에 연속으로\n붙여 놓으면 좋겠네요!\n기능 설명\nrMouse 패키지는 크게 3가지 기능과 한 가지 중요한 옵션을\n제공합니다.\n딜레이\n마우스 입력\n키보드 입력\n긴급 중단 옵션\n딜레이 먼저 볼까요?\n딜레이\nSys.sleep() 함수와 같은 기능을 제공하는\ndelay() 함수가 있습니다. 이건 설명이 별로 필요없겠네요.\ndelay(1000) \n긴급 중단 옵션\n이제 다른 것들을 설명하기 전에 긴급 중단 옵션을 먼저 볼까 합니다.\nrMouse 패키지에서 제공하는 거의 모든 함수는\nfailSafe 파라미터를 가지고 있습니다. 기본 값은\nT인데요. 마우스를 화면 왼쪽 위 끝(x = 0, y = 0)으로 옮기면\n스크립드를 중단하겠다는 뜻입니다. 키보드/마우스 자동화 단계에서 얼마나\n긴급 중단이 중요한지는 아마 사용해보셨다면 잘 아실겁니다. 자기 마음대로\n움직이는데, 중간에 뭘 할 수 없으면 엄청 답답하거든요.ㅎㅎ\n키보드 입력\n키보드 입력은 총 2가지 함수를 제공합니다. type() 함수와\nspecialKey() 함수입니다. 직접 키를 입력하는 함수와 기능\n키를 입력하는 함수군요 키 입력 함수는 자바와 R의 키값이 달라서 많은 특수\n문자들(+한글)이 동작하지 않는다고 합니다. 엉엉\ntype(\"This is a sentence.\")  # 대부분의 특수 문자를 제외한 글자들로 영어만 가능\ntype(\"!\")                    # 에러가 발생함\nspecialKey(\"ESC\")            # ESC 키 사용\nspecialKey(\"ENTER\")          # ENTER 키 사용\n마우스 입력\n마우스 입력은 어떤 좌표로 움직이고, 오른쪽/왼쪽 클릭을 수행하는\n함수를 제공합니다.\nmove(0,0)       # 모니터 가장 왼쪽 위(0,0)로 이동\nmove(50,30)     # 좌표 x = 50, y = 30 로 이동\nleft()          # 왼쪽 클릭\nright()         # 오른쪽 클릭\n마우스의 위치를 잡아주는 coord() 함수와\npos() 함수도 제공합니다. coord() 함수는\nlist 자료형으로 x, y 위치를 제공하구요. pos()\n함수는 x, y 위치를 콘솔에 출력해줍니다. pos() 함수가\ncoord() 함수로 만든 cat()(출력 함수) 함수인\n것으로 보아 편한 방식으로 사용하시면 좋을 것 같습니다.\ncoord()       # 리스트 자료형으로 결과 제공\npos()         # 콘솔에 출력\n#> move(x,y)\n안타깝게도 rMouse 패키지가 사용하는 자바 패키지에는\n마우스 클릭 동작을 기록하는 기능을 제공하지 않는답니다.\n보통 마우스 메크로에서 recode라고 하면 클릭 할 때\n딜레이와 위치, 어느 쪽 클릭인지를 기록해주는데요. 대신 비슷하게 동작을\n흉내내는 recode() 함수를 제공한다고 합니다.\n# 3초 간격으로 3번 기록\nrecord(n = 3, timeInterval = 3) \n#> delay(2000); move(412,668); left()\n#> delay(2000); move(155,636); left() \n#> delay(2000); move(387,697); left()\n옵션에 n과 timeInterval 이 있는데요. n은\n기록하는 갯수라는 뜻입니다. 이게 아마도 클릭하는 횟수를 흉내내려는 것\n같네요. timeInterval 은 클릭을 잡지 못하니 위치를 캐치하기\n위해서 어느 시간 마다 동작함같은 방식을 사용한 것 같습니다.\n아래 이미지를 보시면 조금 감이 오실 것 같습니다.\n\n\n\n사용평\n간단한 자동화를 위해서는 제공하는 기능도 단순하고 이해하기 쉬워서\n좋을 것 같습니다. 하지만 드래그를 지원하지 않는다던가, 제대로된\n기록 기능을 제공하지 않는 점이 아쉬운 것 같습니다.\n매크로 프로그램들\n윈도우로만 한정하면 GUI까지 잘 제공하는 무료 프로그램이 몇 개\n있습니다.\nG Macro\nG Macro은 2버전이 2003년에\n나오고 지금도 관리자 권한으로 실행하면 win10에서 잘 동작한다고 합니다.\n나무위키에 자세하게 설명이\n잘 나와있네요.\n\n\n키보드/마우스 매크로\n키보드/마우스 매크로라는\n이름으로 v1, v2, 비활성화 윈도우 버전 총 3개를 제공합니다. v1은 단순\n버전, v2는 고급 버전이라고 하네요.\n\n\n이것도 12년 정도에 제작하시고 이후에 업데이트가 없긴 하군요. 그래도\n무리없이 작동하는 것 같습니다.\n기타\n오토 마우스류라고 불리는 프로그램들이 게임 쪽에서 많이\n사용되었습니다. 대표적으로는 졸라빨라\n같은 프로그램이 있는데요. 이것도 개발이 중간에 중지된 모양입니다. 그리고\n게임 광클에 맞게 개발된 프로그램이라 업무자동화에는 조금 맞지\n않습니다.\n맥용은 없는가?\n맥은 검색해보면 몇 가지 나오기는하는데, 제가 시도해보지를 못하고\n있네요. 맥은 AppleScript와 Automator를 자체적으로\n지원합니다. 뭔가 다른 세상 이야기 같네요. 혹시 잘 정리된 글이 있으면\n추가, 공유하도록 하겠습니다. 사실 한국에서 화면 자동화 니즈는 윈도우\n전용 클라이언트들(은행의 기업용 프로그램이라던가..)이기 때문에 필요성을\n못 느끼겠네요.\n언제나처럼, 오타 질문 등등 대환영입니다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106513782-bbd64600-6516-11eb-8dd2-ed780e8ee85a.png",
    "last_modified": "2022-11-27T05:11:03+00:00",
    "input_file": {}
  },
  {
    "path": "post/업무자동화-r로-이메일을-보내려면-sendgridr/",
    "title": "[업무자동화] R로 이메일을 보내려면 sendgridr",
    "description": "메일 보내기는 업무 자동화를 위해서 꼭 필요한 기능이다. 기존의 패키지인 mailR, sendmailR은 자바 의존성이 있거나 smtp 서버를 활용하는 형태이다. sendgrid 서비스가 매일 100건 평생 무료로 준대서 패키지를 만들어봤다.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2018-10-02",
    "categories": [
      "R",
      "automation",
      "email",
      "gmail",
      "sendgridr"
    ],
    "contents": "\n\nContents\nsendgridr\ngmail로 받을\n때\n업무자동화에서 메일\n보내기란\n\n\n세줄요약\n메일 보내기는 업무 자동화를 위해서 꼭 필요한 기능이다.\n기존의 패키지인 mailR, sendmailR은 자바 의존성이 있거나 smtp 서버를\n활용하는 형태이다.\nsendgrid 서비스가 매일 100건 평생 무료로 준대서 패키지를\n만들어봤다.\n업무 자동화는 매우 매력적인 키워드입니다. 세상에\n내가 하는 일을 컴퓨터가 대신 하게 해준다니! 여러 가지 작업을 코딩할 수\n있겠지만, R의 장점은 결과에 대한 보고서 딜리버리라고 생각합니다. 전달의\n완성은 역시 이메일이죠! 물론 최근에는 슬랙같은 도구도 많이 사용하기\n때문에 slackr같은\n도구가 더 좋을 수 도 있을 것 같습니다.\n그래도 역시 이메일이지! 라고 생각하는 분들을 위해 R로 이메일을 보내는\n법을 좀 찾아봤습니다. 대체 최근 스타일의 메일 보내는 도구가 없더군요.\n가장 잘 관리되고 있는 패키지는 mailR 이었습니다.\n문제는 두 가지 허들이 있더군요.\n하나는 아파치 지원 프로젝트인 commons을\n사용한다는 점 이었습니다. 이게 java라 rJava가 필요하죠. rJava는 지난\n포스트인 Windows에서\nrJava 스트레스 없이 설치하기를 참고해주세요. 이곳에\n훌륭한 튜토리얼이 있습니다.\n다른 문제는 smtp 서버를 사용한다는 점입니다. 많이 사용하는 gmail의\nsmtp 서버를 사용하려면 위의 튜토리얼에서도\ngoogle 서비스 접근에 대한 보안 수준을 낮춰야 한다고 알려주고 있습니다.\n그렇다고 smtp 서버를 직접 구축할 수 도 없는 노릇인거죠.\n\n보안 수준을 낮춰야 한다니… 불안하기만 하다\n대신 안정적으로 동작하는 패키지라는 걸 아파치의 지원 프로젝트를\n활용하기 때문에 신뢰할 수 있습니다. 2016년이 마지막 업데이트인데요. 메일\n기능이 더 업데이트 할 만한게 뭐가 있을까 싶기도 합니다.\n두 번째로 조금 더 오래됬지만, 매달 5,000 다운로드가 발생하는 대중적인\n패키지로 sendmailR이\n있습니다. 거의 같은 사용성을 보여주고 있는데요. 이건 감사하게도 java\n의존성 같은게 없는 훨씬 단순한 구조입니다. 역시나 허들은 smtp 메일\n서버가 있어야 한다는 점입니다.\n그래서 뭔가 api로 메일 전송 서비스를 제공해주는 곳이 어디 없나\n찾아봤습니다.\n\n메일 전송 api를 제공해주는 서비스들\nmailchimp는 세상 유명한\n서비스입니다. 이메일 마케팅을 하시는 분들이라면 잘 활용하면 좋을\n서비스이지요. sendinblue, sendgrid 모두 경쟁사입니다.\n제가 찾는 api는 이메일을 보낼 수 있으면 충분합니다. 세 서비스 중에\n가장 일별 무료 전송량이 적지만(일 100건), api가 단순한 서비스는 sendgrid\n였습니다.\n\n낙점!\nsendgridr\n이제 sendgrid api의 wrapper 패키지인 sendgridr을 소개합니다.\n\nsendgridr은 크게 2가지 기능을 담당합니다.\n1. sendgrid api 키 등록 및\n확인\n우선 sendgrid를 이용에 메일을 보내기 위해서는 당연히도 회원가입을\n해야 합니다.\nsendgrid 회원가입\n\n우선 sendgrid 홈페이지로\n가주세요. Sign up 버튼을 누르면 어떤 플랜을 선택할지 물어봅니다.\n\n우리는 당연히 free 플랜을 선택합니다.\n\n이제야 익숙한 아이디, 비번, 이메일을 입력하라고 하는군요.\n\n기업 고객 유치를 위해서 추가 정보를 요구합니다.\n\n서비스에겐 미안하지만 아무 정보나 입력했습니다.\n\n드디어 회원가입을 끝냈습니다.\n\n서비스를 사용하기 위해서는 이메일을 확인해야 합니다. 가입때 사용한\n이메일에 들어가보면 확인 메일이 와있을 텐데요.\n\nConfirm Email Address 버튼을 눌러서 계정을 활성화해\n주세요.\napi key 발급\n우선 패키지를 설치해보겠습니다.\n\n\n# remotes::install_github(\"mrchypark/sendgridr\")\nlibrary(sendgridr)\n\n\n\n이제 api 서비스를 사용하기 위해 api key를 발급받아 보겠습니다. sendgridr 패키지는 auth_set() 함수를\n이용해 키를 등록합니다.\n\n영어로 질문이 나오면서 3가지 선택지가 나오는데요. No에 해당하는 것\n2개와 Yes에 해당하는것 1개가 다양한 표현으로 나옵니다. 생각없이 선택하는\n걸 방지하려고 이런 설계를 한 모양이네요.(읭? usethis 함수를 사용한\n겁니다. ㅋㅋ)\n\n이미 api key가 있냐고 물어보네요. 저는 아니오에 해당하는 1을\n입력하겠습니다.\n\n그럼 api key를 신청할 수 있는 페이지를 열어줍니다! 제 스크린샷에는\n이미 2개의 키가 만들어져 있지만, 여러분은 아마도 비어있을 것입니다. 우선\nrstudio에서의 작업을 마저하도록 할까요?\n\n2번째 질문이 나옵니다. 이제 등록해야 할 api key를 R 사용 환경\n전체에서 쓸 것인지, 현재 프로젝트에서만 사용할 것인지 물어봅니다.\nrstudio는 project라는 관리 단위를 나누는 기능을 제공합니다. 잘\n모르신다면 yes를 선택하시고, 아신 다면 상황에 맞게 선택해주세요. 저는\nyes에 해당하는 3번을 입력했습니다. 계속 yes의 위치가 바뀌니 화면을 따라\n3을 입력하지 마시고, 선택지를 잘 확인해주세요.\n\nsendgridr 패키지는 api key를 .Renviron\n파일에 관리하는 것을 권장합니다. .Renviron 파일은 R의 환경\n변수를 기록하고 Sys.getenv() 함수로 값을 사용할 수 있게\n해줍니다. 변수명은 SENDGRID_API로 기록하면 되는군요. 이제\n다시 브라우저로 돌아가서 key를 만들어 볼까요?\n\n오른쪽 위에 Create API Key를 클릭합니다.\n\nkey를 관리할 이름을 정합니다. 저는 그냥 test라고 작성했습니다. 권한는\nFull Access로 설정해주세요.\n\napi key를 발급받았습니다! 매우 긴 문자열로 이걸 복사해서 아까\n.Renviron 파일에 저장하면 되겠네요. 글자를 클릭하면\n자동으로 복사를 수행해 줍니다.\n\n복사를 해야만, 다음 화면으로 넘어갈 수 있군요. 참고로 지금 한번\n알려주고 끝입니다. 복구고 뭐고 아예 없어요. 대신 지우고 새로 만들면\n됩니다. ㅎㅎ 저도 맘편히 스크린샷에 공개했는데요. 진작에 지웠습니다.\n\n.Renviron 파일에 저장한 모습입니다. 이 파일을 저장하고\n나면 적용하기 위해서 R session을 재시작해야 합니다. rstudio를 껏다가\n켜도 좋고, Ctrl+Shift+F10을 입력해도 됩니다. 저는\nrstudioapi::restartSession() 함수로 재시작했습니다. 이제 잘\n동작하는지 확인해 볼까요?\n\nauth_check() 함수는 api key가 잘 등록되어 있는지,\n동작하는 키인지 서비스에 확인하는 작업을 합니다. 잘 동작한다니 드디어\nkey 설정을 완료했습니다!\n2. mail 작성 및 보내기\nsendgrid는 mail에 대한 정보를 json 형태로 받습니다. 막상\n양식에 맞는 형태로 작성하려고 하면 불편한 부분이 있더라구요.\nsendgridr 패키지는 mail(), to(),\ncc(), from 등 메일을 보내기 위한 정보를\n구성하는 함수들을 제공하고 있습니다. 여기에서\n어떤 것을 제공하는지 확인해보세요.\n파이프 연산자%>%를 지원할 수 있게 작성하려고\n노력했습니다.\n\n\nlibrary(sendgridr)\nmail() %>% \n  from(\"example1@mail.com\", \"example name for display\") %>% \n  to(\"example2@mail.com\", \"example name for display 2\") %>% \n  subject(\"test mail title\") %>% \n  content(\"hello world!\")  %>% \n  ## attachments is optional\n  attachments(\"report.html\") %>% \n  send()\n\n\n\n테스트 할 때는 한글도 문제없이 동작하는 것을 확인했습니다. 전송이 잘\n이루어진다면 위 코드를 수행했을 때 NULL이 출력될 것입니다.\n혹시 NULL이외의 출력(대부분 에러 메세지입니다.)이 나오면 여기에\n알려주세요.\ngmail로 받을 때\n회사에서 G Suits를 사용하고 있다보니 회사 메일이 gmail 입니다. 메일의\nbody 부분(패키지에서는 content)에 html로 전송을 지원하길래\n시도해봤는데요. rmd로 만든 html 파일을 사용하니, 삽입된 그림은 막고,\n여러 스타일을 제거해서 보여주는 것을 확인했습니다. 아직은 사용하기\n어렵겠네요.ㅜㅠ 우선은 첨부파일로 해결이 가능할 것 같기는 한데요. 메일\n본문에 요약된 내용을 추가하는 방법을 찾아봐야 할 것 같습니다.\n첨부하는 파일 확장자를 rmd로 받고, rendering과 후처리를 패키지내에\n포함하는 것이 좋겠네요.\n업무자동화에서 메일 보내기란\n업무 자동화는 데이터 소스의 접근, 처리, 보고서 생성, 전달, 스케줄러\n등 다양한 기능을 해야 합니다. 그 중에 메일 보내기는 최종 단계로 꼭\n필요하다고 할 수 있죠. 회사에서 smtp 서버를 운용하는 중이라면\nsendmailR 패키지가 좋은 선택일 것입니다. 스케줄러로\n정기적으로 메일을 보내게도 할 수 있을 것이구요. 이렇게 업무자동화에\n도움이 되는 패키지들을 만들거나 소개하는 것을 좀 해봐야 겠습니다.\n언제나처럼 문의, 오타 제보 등 대환영입니다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106548932-49d02200-6553-11eb-9afd-aa6b97a11c13.png",
    "last_modified": "2022-11-27T05:11:07+00:00",
    "input_file": {}
  },
  {
    "path": "post/rtips-tbl-자료형에서-소수점을-출력해보자/",
    "title": "[Rtips] tbl 자료형에서 소수점을 출력해보자",
    "description": "options(pillar.sigfig=10) 함수는 tibble 자료형에서 소수점 자리수를 조절하는 기능을 제공합니다.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2018-08-22",
    "categories": [
      "R",
      "tbl",
      "tibble",
      "digit",
      "options"
    ],
    "contents": "\n\n한줄요약\noptions(pillar.sigfig=10)\ntidyverse 생태계는 R의 현재 부흥기를 이끌고 있습니다.\nmagrittr 패키지가 쏘아올린 %>%(파이프 연산자)가\n이렇게 될꺼라고 상상이나 했을까요. 해들리\n위컴이 발표한 tidy data와 함께\ntidyverse에서는 없는게 상상도 할 수 없는 것이 많습니다.\n이런 tidyverse에서 data를 담당하는 패키지가 tibble입니다.\n\ntibble은\ntbl, tbl_df 등등의 자료형으로 표현됩니다. 위에\n그림에도 보이는 것처럼 data.frame과 같은 역할을 하면서, 더\n세련됬다고 할까요.\n그 와중에 tibble의 출력을\n담당하는 패키지가 pillar입니다.\n\n\n# install.packages(\"pillar\")\nlibrary(pillar)\nx <- 123456789 * (10 ^ c(-3, -5, NA, -8, -10))\nx\n\n\n[1] 1.234568e+05 1.234568e+03           NA 1.234568e+00 1.234568e-02\n\npillar(x)\n\n\n<pillar>\n      <dbl>\n123457.    \n  1235.    \n    NA     \n     1.23  \n     0.0123\n\n마크다운에는 디테일이 표현되지 않아 사진을 첨부합니다. \n3자리 마다 쉼표로 표시하는 관행을 출력해주기 위해, pillar 패키지는 밑줄을\n사용합니다. 보기 참 좋아진거 같습니다!\n그러다 보니… 소수점 표기의 출력 옵션이 기존의\ndata.frame과 다릅니다. 찾아보니\noptions(pillar.sigfig)를 조절하면 된다는군요!\noptions(pillar.sigfig)\n## Error in options(pillar.sigfig) : object 'pillar.sigfig' not found\n기본 값이 없는거 같습니다….(;;;) 패키지에는 3이 기본값이라고 하는데\n어떻게 보는지 모르겠네요;;; 이젠 tibble에서 확인해 볼까요?\n\n\nmy_numbers <-  c(233, 486, 565, 785)\ntbl_num <- tibble::tibble(\n  big = 1000 * my_numbers + 23,\n  stradle = my_numbers / 1000 + 100,\n  small = my_numbers / 100000\n)\ntbl_num\n\n\n# A tibble: 4 × 3\n     big stradle   small\n   <dbl>   <dbl>   <dbl>\n1 233023    100. 0.00233\n2 486023    100. 0.00486\n3 565023    101. 0.00565\n4 785023    101. 0.00785\n\n출력을 보면 stradle 컬럼의 첫번째 데이터가 100.라고 되어\n있습니다. 100이 아니고 100.이라고 출력해주면서\n소수점 숫자가 있음을 알려주는데요. 관련\n이슈도 있으니 읽어보시면 좋을 것 같구요.\n\n\noptions(pillar.sigfig = 7)\ntbl_num\n\n\n# A tibble: 4 × 3\n     big stradle   small\n   <dbl>   <dbl>   <dbl>\n1 233023 100.233 0.00233\n2 486023 100.486 0.00486\n3 565023 100.565 0.00565\n4 785023 100.785 0.00785\n\npillar의\nsigfig 옵션은 사실 소수점에 해당하는 옵션이 아닙니다.\n유효숫자에 대한 옵션이죠. 유효숫자는 또 큰 주제니까 다음에 다루기로\n하구요.\npillar에서는 출력에\n대한 옵션을 제공하고 있습니다.\n\n한번 읽어보시면 취향껏 고치는데 도움이 되지 않을까요?ㅎㅎ\n감사합니다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106503266-c4278480-6508-11eb-9ef3-67adb5ed64ce.png",
    "last_modified": "2022-11-27T05:10:03+00:00",
    "input_file": {}
  },
  {
    "path": "post/패키지-소개-nosql-데이터베이스를-다루는-nodbi/",
    "title": "[패키지 소개]NoSQL 데이터베이스를 다루는 nodbi",
    "description": "이제 R로 MongoDB, Redis(server based), CouchDB, Elasticsearch, etcd를 다룰 수 있습니다.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2018-08-08",
    "categories": [
      "R",
      "nosql",
      "dbi",
      "package"
    ],
    "contents": "\n\n한줄요약\n이제 R로 MongoDB, Redis(server based), CouchDB, Elasticsearch,\netcd를 다룰 수 있습니다.\nR에는 여러가지 데이터 베이스를 다루는 도구들이 있습니다. MS의 표준\nSQL 드라이버인 ODBC를 사용하는 odbc 패키지(r-dbi 팀), java의\n표준 SQL 드라이버인 JDBC를 사용하는 RJDBC 패키지(rJava 개발자 Simon\nUrbanek), r-dbi팀이 직접 관리하는 DBI 패키지가 대표적입니다.\n이외에도 개인들이 개발하거나 각 데이터베이스에 맞춰 만든 도구들이\n있는데요. 대부분 위의 패키지들을 사용해서 연결 부분을 쉽게하거나, 데이터\n베이스가 통신 프로토콜을 지원해서 wrapper를 만든다거나 하는 경우인거\n같습니다.\n아무튼!\n데이터베이스는 관계형이라고 말하는 RDB 계열과 문서형이라고 부르는\nNoSQL 계열이 있습니다. 특별히 NewSQL 계열이라고 말하는 부류도 있습니다.\n위에서 이야기한 DBI 등등의 드라이버는 표준 SQL 문법을 지원하는 관계형\nDB들을 다룰 때 사용합니다. 이제 그에 대응하는 NoSQL을 다루기 위한 R\n패키지가 등장했는데요. 바로 nodbi 패키지입니다.\n문서에 따르면 nodbi\n패키지는 대표적인 NoSQL 데이터베이스인 mongoDB에서부터 엘라스틱서치까지\n총 5개의 NoSQL 데이터베이스를 지원합니다. ropensci 팀이 r-dbi 팀이 부러웠는지 공통으로\n사용할 수 있는 패키지를 제작하기 시작했네요. 이제 0.1.0 버전으로 초기\n단계라고 볼 수 있습니다. 그동안 각 디비 api에 맞춰 개별로 관리되고 있는\n패키지들이 있었습니다. 현재 유지관리가 되고 있는 패키지들은\nMongoDB : mongolite\nRedis : redux\nCouchDB : sofa\nElasticsearch : elastic\netcd : etseed\n각자 쉬운 문법을 사용하기 위해 노력했지만 가장 큰 문제점은 dplyr 패키지와의\n호환성이었습니다. Elasticsearch의 경우는 파이프 연산자를 지원하는 elasticdsl 패키지가\n있지만, 자신의 특수한 문법만 사용할 수 있습니다.\n위의 개별 패키지들과는 다르게 nodbi는 dplyr 패키지와의 호환성을\n목표로 개발이 시작되었습니다. 갈길이 구만리이긴 하겠지만, dplyr로 대동단결하면 할\n수록 R 사용자들는 추가적인 공부없이 많은 패키지들을 다룰 수 있게\n되겠지요.\nsparklyr도 써봐야\n하는데, 새로 생기는 것만 늘어가는 군요.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106499231-b02d5400-6503-11eb-8995-40307c1ace35.png",
    "last_modified": "2022-11-27T05:11:13+00:00",
    "input_file": {}
  },
  {
    "path": "post/패키지-소개-암호화폐-시세와-인덱스를-제공하는-ubci-패키지를-소개합니다/",
    "title": "[패키지 소개] 암호화폐 시세와 인덱스를 제공하는 ubci 패키지를 소개합니다",
    "description": "ubci 패키지 개발을 시작하였습니다.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2018-05-18",
    "categories": [
      "R",
      "ubci",
      "crypto",
      "package"
    ],
    "contents": "\n\nContents\n함수 예\n라이선스\n문제\n패키지 계획\n\n\n세줄요약\n암호화폐 관련 시세와 인덱스 정보를 제공하는 ubci\n패키지를 공개함.\nubci는 upbit에서\n제공하는 데이터로 비영리 배포는 자유라고 해서 개발함.\n데이터 라이선스는 또 다른 문제이니 ubci 가서 확인바람.\n암호화폐는 2017년의 붐을 기점으로 사회 곳곳에 그 존재감을 드러내고\n있습니다. 여러 이슈가 있긴 하지만 국내에는 4대 거래소(빗썸, 업비트,\n코빗, 코인원)외에도 새로운 거래소들이 속속 나타고 있는 중입니다.\n이외에도 카카오와 라인(네이버)이 각각 암호화폐 전문 자회사를 세우는 등\n기업의 관심이 그 어느때보다 높습니다.\n아직 이슈가 안정적인 분야가 아니다 보니 이슈 파이팅이 그 어느\n분야보다 중요한데요. 현시간 코인마켓캡 기준 전세계 거래량 6위쯤 되는\nupbit가 코인 인텍스를 들고나왔습니다. 바로 UBCI입니다. 저도 관심이 가는\n내용이라 사이트를 둘러보았는데, 데이터를 깨끗하게 제공하더라구요. 그래서\n간단하게 R 패키지화 해보았습니다. 놀랍게도 패키지 이름은 ubci입니다.\n## github에서 패키지 설치\nremotes::install_github(\"mrchypark/ubci\")\n한글 데이터가 포함되어 있으니 인코딩이 UTF-8인지 확인해\n주세요.\n\n\nSys.getlocale()\n\n\n[1] \"en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\"\n\n함수 예\n패키지가 리드미와 설명서를 제공하고 있지만 저도 다시 사용해\n보겠습니다.\n인덱스 코드 가져오기\nubci_index_options() 함수는 인덱스를 가져오기에 앞서\n인덱스의 이름과 설명을 알려줍니다.\n\n\nlibrary(ubci)\nubci_index_options()\n\n\n# A tibble: 26 × 4\n   index    name                                cate           smry   \n   <chr>    <chr>                               <chr>          <chr>  \n 1 UBMI     UBMI(Upbit Market Index)            Market Indexes \"It is…\n 2 UBMI_ST  UBMI BTC quote(Upbit Market Index)  Market Indexes \"It is…\n 3 UBAI     UBAI(Upbit Altcoin Index)           Market Indexes \"It is…\n 4 UBAI_ST  UBAI BTC quote(Upbit Altcoin Index) Market Indexes \"It is…\n 5 UTTI     UBMI 10(Upbit Top 10)               Market Indexes \"It is…\n 6 UTHI     UBMI 30(Upbit Top 30)               Market Indexes \"It is…\n 7 THMIDX20 NFT & Collectibles                  Theme Indexes  \"\"     \n 8 THMIDX21 Oracles                             Theme Indexes  \"\"     \n 9 THMIDX22 IoT                                 Theme Indexes  \"\"     \n10 THMIDX23 Smart Contracts                     Theme Indexes  \"\"     \n# … with 16 more rows\n\n자료형은 tbl로 되어 있네요. 주식 분석 패키지의 최강자인\ntidyquant와\n상성을 고려한 선택이었습니다. ubci_index_options() 함수는\nlang 인자로 언어를 변경할 수 있습니다.\n\n\nubci_index_options(lang=\"ko\")\n\n\n# A tibble: 26 × 4\n   index    name                                cate        smry      \n   <chr>    <chr>                               <chr>       <chr>     \n 1 UBMI     UBMI(Upbit Market Index)            시장 인덱스 업비트 거…\n 2 UBMI_ST  UBMI BTC quote(Upbit Market Index)  시장 인덱스 UBMI 인덱…\n 3 UBAI     UBAI(Upbit Altcoin Index)           시장 인덱스 업비트 거…\n 4 UBAI_ST  UBAI BTC quote(Upbit Altcoin Index) 시장 인덱스 UBAI 인덱…\n 5 UTTI     UBMI 10(Upbit Top 10)               시장 인덱스 업비트에 …\n 6 UTHI     UBMI 30(Upbit Top 30)               시장 인덱스 업비트에 …\n 7 THMIDX20 대체불가능 토큰                     테마 인덱스 NFT 자산… \n 8 THMIDX21 오라클                              테마 인덱스 오라클을 …\n 9 THMIDX22 아이오티                            테마 인덱스 사물인터… \n10 THMIDX23 스마트컨트랙                        테마 인덱스 스마트컨… \n# … with 16 more rows\n\n인덱스 데이터\nubci_index() 함수는 인덱스의 일별 시가, 고가, 저가,\n종가, 거래량을 제공합니다. from,to 인자로\n기간을 조절할 수 있습니다.\n\n\nloi<-ubci_index_options()\nloi$index[1]\n\n\n[1] \"UBMI\"\n\nubci_index(loi$index[1])\n\n\n# A tibble: 1,000 × 6\n   index date           open     high      low    close\n   <chr> <date>        <dbl>    <dbl>    <dbl>    <dbl>\n 1 UBMI  2022-11-27 4169.728 4202.541 4166.047 4202.135\n 2 UBMI  2022-11-26 4163.247 4220.241 4156.564 4169.203\n 3 UBMI  2022-11-25 4165.747 4181.392 4077.474 4162.018\n 4 UBMI  2022-11-24 4188.249 4239.917 4109.620 4164.367\n 5 UBMI  2022-11-23 4092.360 4199.336 4074.616 4188.578\n 6 UBMI  2022-11-22 4019.895 4106.151 3952.450 4090.442\n 7 UBMI  2022-11-21 4108.105 4113.075 3965.345 4018.276\n 8 UBMI  2022-11-20 4234.354 4246.282 4084.146 4108.012\n 9 UBMI  2022-11-19 4224.501 4256.329 4193.015 4231.954\n10 UBMI  2022-11-18 4193.600 4255.915 4188.623 4222.896\n# … with 990 more rows\n\ntail(ubci_index(loi$index[1], from=\"2018-05-15\"))\n\n\n# A tibble: 6 × 6\n  index date           open     high      low    close\n  <chr> <date>        <dbl>    <dbl>    <dbl>    <dbl>\n1 UBMI  2020-03-08 1619.383 1619.598 1461.665 1469.803\n2 UBMI  2020-03-07 1652.306 1673.211 1614.623 1618.661\n3 UBMI  2020-03-06 1628.410 1654.108 1617.966 1650.650\n4 UBMI  2020-03-05 1589.399 1642.027 1587.862 1629.091\n5 UBMI  2020-03-04 1592.225 1605.803 1572.432 1588.396\n6 UBMI  2020-03-03 1621.643 1623.557 1576.700 1591.382\n\nubci_index(loi$index[1], to=\"2018-05-15\")\n\n\n# A tibble: 0 × 6\n# … with 6 variables: index <chr>, date <date>, open <dbl>,\n#   high <dbl>, low <dbl>, close <dbl>\n\nubci_index(loi$index[1], from=\"2018-05-10\", to=\"2018-05-15\")\n\n\n# A tibble: 0 × 6\n# … with 6 variables: index <chr>, date <date>, open <dbl>,\n#   high <dbl>, low <dbl>, close <dbl>\n\n암호화폐 코드\nubci_get_options() 함수는 취급하는 암호화폐의 종류를\n이름과 코드로 제공합니다.\n\n\nubci_get_options()\n\n\n# A tibble: 1,056 × 5\n   code           name             exchange tradeStatus marketState\n   <chr>          <chr>            <chr>    <chr>       <chr>      \n 1 UPBIT.KRW-BTC  Bitcoin          UPBIT    ACTIVE      ACTIVE     \n 2 UPBIT.KRW-DASH Dash             UPBIT    DELISTED    DELISTED   \n 3 UPBIT.KRW-ETH  Ethereum         UPBIT    PREVIEW     ACTIVE     \n 4 UPBIT.BTC-NEO  NEO              UPBIT    DELISTED    DELISTED   \n 5 UPBIT.BTC-ETH  Ethereum         UPBIT    PREVIEW     ACTIVE     \n 6 UPBIT.BTC-LTC  Litecoin         UPBIT    DELISTED    DELISTED   \n 7 UPBIT.BTC-XRP  Ripple           UPBIT    PREVIEW     ACTIVE     \n 8 UPBIT.BTC-ETC  Ethereum Classic UPBIT    PREVIEW     ACTIVE     \n 9 UPBIT.BTC-OMG  OmiseGo          UPBIT    PREVIEW     ACTIVE     \n10 UPBIT.BTC-CVC  Civic            UPBIT    PREVIEW     ACTIVE     \n# … with 1,046 more rows\n\nubci_get_options() 함수 역시 한글 옵션을 제공합니다.\n\n\nubci_get_options(lang=\"ko\")\n\n\n# A tibble: 1,056 × 5\n   code           name           exchange tradeStatus marketState\n   <chr>          <chr>          <chr>    <chr>       <chr>      \n 1 UPBIT.KRW-BTC  비트코인       UPBIT    ACTIVE      ACTIVE     \n 2 UPBIT.KRW-DASH 대시           UPBIT    DELISTED    DELISTED   \n 3 UPBIT.KRW-ETH  이더리움       UPBIT    PREVIEW     ACTIVE     \n 4 UPBIT.BTC-NEO  네오           UPBIT    DELISTED    DELISTED   \n 5 UPBIT.BTC-ETH  이더리움       UPBIT    PREVIEW     ACTIVE     \n 6 UPBIT.BTC-LTC  라이트코인     UPBIT    DELISTED    DELISTED   \n 7 UPBIT.BTC-XRP  리플           UPBIT    PREVIEW     ACTIVE     \n 8 UPBIT.BTC-ETC  이더리움클래식 UPBIT    PREVIEW     ACTIVE     \n 9 UPBIT.BTC-OMG  오미세고       UPBIT    PREVIEW     ACTIVE     \n10 UPBIT.BTC-CVC  시빅           UPBIT    PREVIEW     ACTIVE     \n# … with 1,046 more rows\n\n암호화폐 시세 정보\nubci_get() 함수 또한 암호화폐의 일별 시가, 고가, 저가,\n종가, 거래량을 제공합니다.\n\n\nloc<-ubci_get_options()\nloc$code[1]\n\n\n[1] \"UPBIT.KRW-BTC\"\n\nubci_get(loc$code[1])\n\n\n# A tibble: 400 × 7\n   code       date           open     high      low    close    volume\n   <chr>      <date>        <dbl>    <dbl>    <dbl>    <dbl>     <dbl>\n 1 UPBIT.KRW… 2022-11-27 22646000 22761000 22634000 22756000  460.3398\n 2 UPBIT.KRW… 2022-11-26 22677000 22862000 22605000 22660000 2148.776 \n 3 UPBIT.KRW… 2022-11-25 22735000 22794000 22370000 22676000 3000.133 \n 4 UPBIT.KRW… 2022-11-24 22985000 23220000 22566000 22738000 4151.701 \n 5 UPBIT.KRW… 2022-11-23 22599000 23121000 22525000 22985000 4524.894 \n 6 UPBIT.KRW… 2022-11-22 22220000 22719000 22031000 22584000 4830.107 \n 7 UPBIT.KRW… 2022-11-21 22763000 22810000 22000000 22220000 5410.355 \n 8 UPBIT.KRW… 2022-11-20 23082000 23128000 22651000 22788000 4008.068 \n 9 UPBIT.KRW… 2022-11-19 23062000 23197000 22928000 23081000 2254.611 \n10 UPBIT.KRW… 2022-11-18 22982000 23330000 22900000 23061000 3545.620 \n# … with 390 more rows\n\ntail(ubci_get(loc$code[1], from=\"2018-05-15\"))\n\n\n# A tibble: 6 × 7\n  code        date           open     high      low    close    volume\n  <chr>       <date>        <dbl>    <dbl>    <dbl>    <dbl>     <dbl>\n1 UPBIT.KRW-… 2021-10-29 73028000 75405000 72676000 74568000  7156.550\n2 UPBIT.KRW-… 2021-10-28 71833000 74707000 71028000 73122000  8654.621\n3 UPBIT.KRW-… 2021-10-27 73293000 74200000 70180000 71845000 14503.83 \n4 UPBIT.KRW-… 2021-10-26 76250000 76480000 73002000 73293000  8258.181\n5 UPBIT.KRW-… 2021-10-25 74501000 77024000 74210000 76200000  6856.578\n6 UPBIT.KRW-… 2021-10-24 74830000 75530000 73635000 74501000  6110.379\n\nubci_get(loc$code[1], to=\"2018-05-15\")\n\n\n# A tibble: 0 × 7\n# … with 7 variables: code <chr>, date <date>, open <dbl>,\n#   high <dbl>, low <dbl>, close <dbl>, volume <dbl>\n\nubci_get(loc$code[1], from=\"2018-05-10\", to=\"2018-05-15\")\n\n\n# A tibble: 0 × 7\n# … with 7 variables: code <chr>, date <date>, open <dbl>,\n#   high <dbl>, low <dbl>, close <dbl>, volume <dbl>\n\n라이선스 문제\nubci와 시세는\n라이선스가 다를텐데요. ubci는 메인 페이지에서\n데이터 라이선스와 법적 이슈에 대해 고지하고 있습니다. 시세는 제가\n못찾은건지 데이터관런 라이선스 고지를 찾을 수가 없네요.\nubci는 비영리 배포에\n대해 허용하고 있어 마음껏 작성하였구요. 시세는 하는김에 라는 느낌이라서\n업비트에서 뭐라고 하면 내릴 계획입니다.\n패키지 계획\n만들다 보니 ubci의\n세부 정보(ex> 구성 화폐시세와 비율, 추가 설명 등)가 함께 있으면\n좋겠다 싶어서 추가하려고 계획하고 있습니다. 시세쪽은 지금은 데일리만\n있는데, 분단위 정보를 제공하기는 하더라구요. 비정상 이용에 대해 막을\n가능성이 높긴 하지만, 제한적으로나마 분단위나 15분 단위의 데이터를\n제공하는 함수를 만들 수 있을 것 같습니다.\n깃헙주소는 https://github.com/mrchypark/ubci 입니다. 재밌게 보신\n분들은 별이라도 한번 눌러주시구요. 설명의 추가나 위에 예정중인 함수\n작성, 테스트 케이스 작성등 패키지 개발을 위해서 아직 남은 일이 많은데요.\n도움 주시는 분이 계시면 정말 감사할 것 같습니다.\n언제나처럼 문의나 잘못된 점 등 알려주시면 반영하겠습니다.\n감사합니다.\np.s 간단한 분석을 포함한 영문 포스팅을 해주실 용자분을 찾습니다.\n해외에서도 관심가질만한 주제라고 생각해서 소개하고 싶은데, 제가 능력이\n안되네요. 감사합니다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106495895-9558e080-64ff-11eb-9fd5-9d5ffeea0fcc.png",
    "last_modified": "2022-11-27T05:11:51+00:00",
    "input_file": {}
  },
  {
    "path": "post/패키지-소개-네이버-뉴스와-다음-뉴스의-댓글-가져오기/",
    "title": "[패키지 소개] 네이버 뉴스와 다음 뉴스의 댓글 가져오기",
    "description": "DNH4가 댓글 수집을 드디어 지원합니다. 덕분에 N2H4도 함께 홍보합니다.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2018-05-14",
    "categories": [
      "R",
      "N2H4",
      "DNH4",
      "comment",
      "forkonlp"
    ],
    "contents": "\n\n한줄요약\nDNH4가 드디어(!) 댓글\n수집을 지원합니다.\n처음 naverNewsParser를\n습작처럼 시작하고, N2H4\n패키지로 이전하면서 여러 경험을 했습니다. naverNewsParser는\n기가막히게도 책에 실린 모양이더군요. 고학력자들에게 석사 논문 낭독이\n거대한 괴롭힘이듯 naverNewsParser가\n약간 저에게 그런 역할을 해주는 것 같습니다. (물론 사용해 주시는 모든\n분들 감사드립니다.)\n이렇게 저렇게 패키지를 뭐라도 만들어 보고, 그 이후로도 많은 일들이\n있었습니다. N2H4 패키지는\n저에게 많은 생각을 하게 만들어주었죠.\n조금 익숙해지고 난 이후에는 다음 뉴스를 대상으로 하는 비슷한 패키지를\n만들어야 겠다는 생각을 했습니다. 그래서 몇 시간만에 N2H4 패키지의 골격을 가져와\n모양만 갖춘게 DNH4\n패키지입니다. 날짜를 보니 2016년 11월이네요. 이것저것 되게 하려고\n노력하다가 의외의 장애물이 댓글 수집이었습니다. 방법을 몰라 방치한지 2년\n가까이 된 패키지를 포스트에 올리는 이유는 드디어(!) 댓글 수집을\n지원합니다.\n다음 뉴스 수집 패키지 DNH4\nDNH4 패키지는 N2H4처럼 github에서 호스팅하고 있습니다. 아래의 코드로\n설치 & 로드하여 사용할 수 있습니다.\n\n\n# remotes::install_github(\"forkonlp/DNH4\")\nlibrary(DNH4)\n\n\n\nN2H4 패키지와 함수명이 같기 때문에 library()는 조심해\n주셔야 합니다. DNH4 패키지는 6개의 함수를 우선 지원합니다.참조\ngetContent() 함수는 역시 기사 url을 입력으로 받아 관련\n내용을 크롤링해 옵니다. getMainCategory() 함수는 기사의\n대분류 항목을 가져옵니다. getSubCategory() 함수는 기사의\n소분류 항목을 가져옵니다. 다음 뉴스는 카테고리가 대분류와 소분류만\n있습니다. getUrlListByCategory() 함수는 뉴스 리스트\n페이지에서 기사의 제목과 링크를 가져옵니다. getMaxPageNum()\n함수는 뉴스 리스트 페이지의 마지막 페이지 번호를 가져옵니다.\ngetComment() 함수는 기사 url을 입력으로 받아 그 기사의 댓글\n정보를 가져옵니다.\n말씀드린 것처럼, 다음 뉴스의 댓글 수집은 여러 권한 단계를 거쳐 제\n짧은 실력으로는 그 동안 가져오지 못했습니다. 물론 셀레늄을 사용하면 이런\n고민을 하지 않습니다만, 역시 속도 문제를 무시할 수 없는 것 같습니다.\n그럼 이제 getComment() 함수를 사용해 보겠습니다.\n댓글 수집 함수\n우선 댓글이 많은 뉴스를 하나 골라봅시다. 제가 작성하는 시점으로\n댓글이 3,000개가 넘는 기사로\n해보겠습니다.\n\n\ncomments <- DNH4::getComment(\"http://v.media.daum.net/v/20180513202105651\")\ncomments\n\n\n# A tibble: 10 × 25\n          id   postId forumId parentId type    status flags rating\n       <int>    <int>   <int>    <int> <chr>   <chr>  <int>  <int>\n 1 250018687 31383325     -99        0 COMMENT S        256      0\n 2 250019139 31383325     -99        0 COMMENT S          0      0\n 3 250023503 31383325     -99        0 COMMENT S        256      0\n 4 250021353 31383325     -99        0 COMMENT S        256      0\n 5 250020406 31383325     -99        0 COMMENT S        256      0\n 6 250022883 31383325     -99        0 COMMENT S        256      0\n 7 250019409 31383325     -99        0 COMMENT S        256      0\n 8 250019687 31383325     -99        0 COMMENT S          0      0\n 9 250022914 31383325     -99        0 COMMENT S        256      0\n10 250019357 31383325     -99        0 COMMENT S        256      0\n# … with 17 more variables: content <chr>, createdAt <chr>,\n#   updatedAt <chr>, childCount <int>, likeCount <int>,\n#   dislikeCount <int>, user_id <int>, user_status <chr>,\n#   user_providerId <chr>, user_displayName <chr>,\n#   user_commentCount <int>, user_providerUserId <chr>,\n#   user_flags <int>, user_username <chr>, user_title <chr>,\n#   user_roles <chr>, user_type <chr>\n\ngetComment() 함수는 몇 가지 옵션이 있습니다.\nlimit은 가져오는 댓글의 갯수로 기본 10개로 설정되어\n있습니다. 전체 댓글수를 가져오는 함수가 필요하다는 것을 확인하는\n시점이네요. parentId는 대댓글등을 가져올 때 사용하는\n옵션으로, 기본값 0에서 바꾸실 일이 거의 없을 겁니다. sort는\n역시 추천순와 최신순 두 가지 옵션을 제공합니다. type은\n결과값을 주는 형태를 의미합니다. 옵션은 df와\nlist가 있으며 원래 제공하는 자료형이 json이기\n때문에 list가 익숙하진 분들은 list 자료형을\n권장합니다. 기본값은 df 입니다. 댓글의 상황에 따라\nWarning messages가 나오는데 무시하셔도 좋습니다. 내용상\n신경이 쓰이시면 list를 직접 다루어 보시는 것도 좋은 공부가\n될 것입니다.\n네이버 뉴스 댓글 가져오기\n네이버 뉴스 수집 패키지 역시 같은 함수를 가지고 있습니다. 우선 아래\n코드로 패키지를 설치하고 로드합니다.\n\n\n# remotes::install_github(\"forkonlp/N2H4\")\nlibrary(N2H4)\n\n\n\n대상이 될만한 기사를 선정하려고 하다보니, 기왕 같은 뉴스면 좋겠다\n싶어 가져왔습니다.\n\n\ncomments <- N2H4::getComment(\"http://news.naver.com/main/read.nhn?mode=LSD&mid=sec&sid1=101&oid=214&aid=0000833933\")\ncomments\n\n\n# A tibble: 10 × 81\n   ticket objectId     categoryId templateId commentNo parentCommentNo\n   <chr>  <chr>        <chr>      <chr>      <chr>     <chr>          \n 1 news   news214,000… *          default_e… 13435975… 1343597525     \n 2 news   news214,000… *          view_econ… 13435957… 1343595725     \n 3 news   news214,000… *          default_e… 13435895… 1343589535     \n 4 news   news214,000… *          view_econ… 13435368… 1343536845     \n 5 news   news214,000… *          view_econ… 13434077… 1343407745     \n 6 news   news214,000… *          view_econ… 13433325… 1343332545     \n 7 news   news214,000… *          view_econ… 13433135… 1343313585     \n 8 news   news214,000… *          view_econ… 13432001… 1343200155     \n 9 news   news214,000… *          view_econ… 13431857… 1343185745     \n10 news   news214,000… *          view_econ… 13431465… 1343146585     \n# … with 75 more variables: replyLevel <int>, replyCount <int>,\n#   replyAllCount <int>, replyPreviewNo <lgl>, replyList <lgl>,\n#   imageCount <int>, imageList <lgl>, imagePathList <lgl>,\n#   imageWidthList <lgl>, imageHeightList <lgl>, commentType <chr>,\n#   stickerId <lgl>, sticker <lgl>, sortValue <dbl>, contents <chr>,\n#   userIdNo <chr>, exposedUserIp <lgl>, lang <chr>, country <chr>,\n#   idType <chr>, idProvider <chr>, userName <chr>, …\n\n네이버 뉴스의 댓글은 훨씬 풍부한 정보를 제공하여(구조가\n복잡해서…) df를 기능상 제공하지 않습니다. 대신 댓글만 보는\n부분을 안내해 드리고 있습니다.\n\n\ncomments$result$commentList[[1]]\n\n\nNULL\n\n그냥 위 모양으로라도 제공하는게 맞는가 싶어 급하게 업데이트 했습니다.\nN2H4 패키지의 getComment() 함수도 type을\n지원하며, 기본값은 df이고 모든 데이터를 확인하기 위해서\nlist를 선택하시면 좋을 것 같습니다.\n\n\nN2H4::getComment(\"http://news.naver.com/main/read.nhn?mode=LSD&mid=sec&sid1=101&oid=214&aid=0000833933\",\n                 type = \"list\")\n\n\n$success\n[1] TRUE\n\n$code\n[1] \"1000\"\n\n$message\n[1] \"요청을 성공적으로 처리하였습니다.\"\n\n$lang\n[1] \"ko\"\n\n$country\n[1] \"KR\"\n\n$result\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       commentList\n1 news, news, news, news, news, news, news, news, news, news, news214,0000833933, news214,0000833933, news214,0000833933, news214,0000833933, news214,0000833933, news214,0000833933, news214,0000833933, news214,0000833933, news214,0000833933, news214,0000833933, *, *, *, *, *, *, *, *, *, *, default_economy, view_economy, default_economy, view_economy, view_economy, view_economy, view_economy, view_economy, view_economy, view_economy, 1343597525, 1343595725, 1343589535, 1343536845, 1343407745, 1343332545, 1343313585, 1343200155, 1343185745, 1343146585, 1343597525, 1343595725, 1343589535, 1343536845, 1343407745, 1343332545, 1343313585, 1343200155, 1343185745, 1343146585, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, txt, txt, txt, txt, txt, txt, txt, txt, txt, txt, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, 1526301193000, 1526301073000, 1526300678000, 1526297019000, 1526288199000, 1526283570000, 1526282249000, 1526276078000, 1526275163000, 1526272157000, 정말 가난한 사람들이구나 마음이~~~~, 주민들 다바보냐 ㆍ대표 감사 다한통속이고 ᆢ비리밝혀야지, 헐~~~, 그냥 옛날 귀족과 뭐가 다름?\\n아 아니다. 귀족이 아니라 왕이나 다름 없다고 봐야 겠네.\\n내가 뭐 잘못 말했나?, 와........대단하다 대단해...., 갑질로 시작해서 여기까지 올줄은 몰랐지? 전문경영인 세우고 오너일가 싹 물러나라, 식탁도 글로벌하네..그럼 감방도 글로벌하게 세계3대 감옥으로가자..국내감방에서도 갑질할거니, 그냥 다없애주세요!얼마나 무고한 사람들이 힘들었을까\\n국외로 추방했으면 합니다!!, 공물 갖다 바치는거냐. 왕조네 왕조., 법개정해서 걍 평생 옥살이 시켜라 저런건 나와도 사회도움 절대 안된다, 37nsJ, 5HzPo, 37nsJ, 1YJyu, 7dGi7, 2mS6W, 3mIMN, 4aKKm, Q7ZE, 6f8ZY, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, ko, ko, ko, ko, ko, ko, ko, ko, ko, ko, IT, KR, IT, KR, KR, KR, KR, KR, KR, KR, naver, naver, naver, naver, naver, naver, naver, naver, naver, naver, naver, naver, naver, naver, naver, naver, naver, naver, naver, naver, elen****, unb1****, elen****, pcw1****, iluv****, ywj2****, 77gu****, tntj****, c32h****, betl****, , , , , , , , , , , naver, naver, naver, naver, naver, naver, naver, naver, naver, naver, 2018-05-14T21:33:13+0900, 2018-05-14T21:31:13+0900, 2018-05-14T21:24:38+0900, 2018-05-14T20:23:39+0900, 2018-05-14T17:56:39+0900, 2018-05-14T16:39:30+0900, 2018-05-14T16:17:29+0900, 2018-05-14T14:34:38+0900, 2018-05-14T14:19:23+0900, 2018-05-14T13:29:17+0900, 2018-05-14T12:33:13+0000, 2018-05-14T12:31:13+0000, 2018-05-14T12:24:38+0000, 2018-05-14T11:23:39+0000, 2018-05-14T08:56:39+0000, 2018-05-14T07:39:30+0000, 2018-05-14T07:17:29+0000, 2018-05-14T05:34:38+0000, 2018-05-14T05:19:23+0000, 2018-05-14T04:29:17+0000, 2018-05-14T21:33:13+0900, 2018-05-14T21:31:13+0900, 2018-05-14T21:24:38+0900, 2018-05-14T20:23:39+0900, 2018-05-14T17:56:39+0900, 2018-05-14T16:39:30+0900, 2018-05-14T16:17:29+0900, 2018-05-14T14:34:38+0900, 2018-05-14T14:19:23+0900, 2018-05-14T13:29:17+0900, 2018-05-14T12:33:13+0000, 2018-05-14T12:31:13+0000, 2018-05-14T12:24:38+0000, 2018-05-14T11:23:39+0000, 2018-05-14T08:56:39+0000, 2018-05-14T07:39:30+0000, 2018-05-14T07:17:29+0000, 2018-05-14T05:34:38+0000, 2018-05-14T05:19:23+0000, 2018-05-14T04:29:17+0000, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, TRUE, TRUE, TRUE, TRUE, FALSE, TRUE, TRUE, TRUE, FALSE, TRUE, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 37nsJ, 5HzPo, 37nsJ, 1YJyu, 7dGi7, 2mS6W, 3mIMN, 4aKKm, Q7ZE, 6f8ZY, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, elen****, unb1****, elen****, pcw1****, iluv****, ywj2****, 77gu****, tntj****, c32h****, betl****, el****, un****, el****, pc****, il****, yw****, 77****, tn****, c3****, be****, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE\n  pageModel.page pageModel.pageSize pageModel.indexSize\n1              1                 10                  10\n  pageModel.startRow pageModel.endRow pageModel.totalRows\n1                  1               10                2444\n  pageModel.startIndex pageModel.totalPages pageModel.firstPage\n1                    0                  245                   1\n  pageModel.prevPage pageModel.nextPage pageModel.lastPage\n1                  0                  2                 10\n  pageModel.current pageModel.threshold pageModel.moveToLastPage\n1                NA                  NA                    FALSE\n  pageModel.moveToComment pageModel.moveToLastPrev morePage.prev\n1                   FALSE                    FALSE 04q7zmlgkmzg8\n  morePage.next morePage.start  morePage.end exposureConfig.reason\n1 04q7okqkyfpj0  04q7zmlgkmzg8 04q71atbvmojj                    NA\n  exposureConfig.status count.comment count.reply count.exposeCount\n1            COMMENT_ON          2444         231              2475\n  count.delCommentByUser count.delCommentByMon\n1                   1179                    11\n  count.blindCommentByUser count.blindReplyByUser count.total\n1                        0                      0        2675\n  listStatus sort config.useSnsLogin config.lineFeedOn config.useBest\n1    current  NEW              FALSE             FALSE          FALSE\n  config.useVote config.useVoteSelf config.useVoteGoodOnly\n1           TRUE              FALSE                  FALSE\n  config.useReport config.useCommonReport config.reportAuthority\n1             TRUE                  FALSE                    ALL\n  config.useDeleteOnManagerReport config.useReportSecret\n1                           FALSE                  FALSE\n  config.useSort config.sortTypes config.defaultSort\n1           TRUE              NEW                NEW\n  config.useByteLength config.useReply config.useReplyOnReply\n1                FALSE            TRUE                  FALSE\n  config.pageAfterReply config.maxReplyWriteBoxCount\n1          TO_LAST_PAGE                            0\n  config.useAutoRefresh config.useMention config.min config.max\n1                 FALSE             FALSE          1        300\n  config.useSticker config.stickerOnly\n1             FALSE              FALSE\n  config.stickerSupportedCategories config.stickerDefaultCategory\n1                                NA                            NA\n  config.stickerCategory config.stickerContentsUrl\n1                     NA                        NA\n  config.stickerKeyUrl config.stickerTabUrl config.stickerType\n1                   NA                   NA                 NA\n  config.stickerText config.stickerMarketUrl\n1              FALSE                      NA\n  config.stickerMobileResize config.useProfile config.useNaverProfile\n1                      FALSE              TRUE                   TRUE\n  config.dynamicProfile config.profileImageAreas\n1                 FALSE              LIST, WRITE\n                                                config.profileEmptyImage\n1 https://static.nid.naver.com/images/web/user/default.png?type=f132_132\n  config.displayMaskedUserId config.useManager config.managerDelete\n1                      FALSE             FALSE                FALSE\n  config.managerBlock config.managerNotice config.contentsManagerIcon\n1               FALSE                FALSE                      FALSE\n  config.secretComment config.exposureConfig\n1                FALSE                 FALSE\n  config.deleteAllAfterBlock config.useFold config.replyPreviewCount\n1                      FALSE           TRUE                        0\n  config.maxImageUploadCount config.maxImageUploadFileSize\n1                          0                             0\n  config.imageAutoRotate config.autoRefreshTime\n1                  FALSE                      0\n  config.autoRefreshDefaultOff config.autoRefreshChat\n1                        FALSE                  FALSE\n  config.maxChatFPS config.commentModify config.useCommentModify\n1                 0                FALSE                   FALSE\n  config.useViewAll config.useUserLevel config.anyUseImageExpose\n1              TRUE               FALSE                     TRUE\n  config.useImageComment config.useUrlLink\n1                  FALSE             FALSE\n  config.useCommentListIncludeDelete config.useStats\n1                              FALSE            TRUE\n  config.statsMinCount config.useUserEnvStats\n1                  100                  FALSE\n  config.countryStatsMinCount config.useConcurrentStats\n1                           0                     FALSE\n  config.useVoteStats config.useGpopCache config.useEnterSubmit\n1               FALSE               FALSE                 FALSE\n  config.useListReverse config.useTranslation config.useDeletedList\n1                 FALSE                 FALSE                  TRUE\n  config.combinedDeletedList config.displayDeletedList\n1                       TRUE                      TRUE\n  config.applyChangedNotice config.useUserCommentUi\n1                     FALSE                    TRUE\n  config.useUserCommentProfileUi config.userRecentStatsStartDate\n1                           TRUE                    1.584544e+12\n       config.userSortTypes config.useMentionLegacyFormat\n1 FAVORITE, NEW, OLD, REPLY                         FALSE\n  config.useMentionWrite config.mentionMaxCount config.useSecret\n1                  FALSE                      0            FALSE\n  config.useIdPenaltyLayer config.useRestrictWriteBySns\n1                     TRUE                        FALSE\n  config.photoInfraUploadDomain config.photoInfraSelectDomainHttps\n1                            NA                 g-cbox.pstatic.net\n  config.pcTempThumbnailType config.mobileTempThumbnailType\n1                    ff80_80                        ff50_50\n  config.realnameVerificationBlock config.realnameVerificationMessage\n1                            FALSE                                 NA\n  config.useBlindByReport config.keepTextareaOnRestriction\n1                   FALSE                               NA\n  config.displayIndividualBlindOnly config.hashtagMaxLength\n1                             FALSE                      20\n  config.useDualPagination\n1                    FALSE\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             config.reportReasonList\n1 AA03, AA14, AA68, AA33, AA01, AA24, AB28, 스팸홍보/도배글입니다., 음란물입니다., 불법정보를 포함하고 있습니다., 청소년에게 유해한 내용입니다., 욕설/생명경시/혐오/차별적 표현입니다., 개인정보 노출 게시물입니다., 불쾌한 표현이 있습니다., 사행성 오락이나 도박을 홍보하거나 권장하는 내용 등의 부적절한 스팸 홍보 행위, 동일하거나 유사한 내용 반복 게시, 성적 수치심을 일으키는 내용, 아동이나 청소년을 성 대상화한 표현, 과도하거나 의도적인 신체 노출, 음란한 행위와 관련된 부적절한 내용, 불법 행위, 불법 링크에 대한 정보 제공, 불법 상품을 판매하거나 유도하는 내용, 가출/왕따/학교폭력/자살 등 청소년에게 부정적인 영향을 조성하는 내용, 직·간접적인 욕설을 사용하여 타인에게 모욕감을 주는 내용, 생명을 경시여기거나 비하하는 내용, 계층/지역/종교/성별 등을 혐오하거나 비하하는 표현, 신체/외모/취향 등을 경멸하는 표현, 법적으로 중요한 타인의 개인정보를 게재, 당사자 동의 없는 특정 개인을 인지할 수 있는 정보, 불쾌한 표현 포함 [해당 사유는 클린봇 학습에 도움이 될 수 있습니다.] \n  config.displayReportLayer config.useHideAfterReport\n1                      TRUE                      TRUE\n  config.useCleanbot config.cleanbotEnforced\n1               TRUE                   FALSE\n  config.cleanbotServiceStepUI config.useCommentLinkToken\n1                            2                       TRUE\n  config.useUserBlock config.useUserBlockNaverIdType\n1                TRUE                           TRUE\n  config.useUserBlockNeoIdType config.useUserBlockProifleImageUi\n1                        FALSE                              TRUE\n  config.useChoice config.useNcc config.useRating\n1            FALSE         FALSE            FALSE\n  config.ratingUseSingleType config.ratingScale\n1                      FALSE                  0\n  config.ratingSelectorCount config.useFollow config.useManagerLike\n1                          0             TRUE                 FALSE\n  config.usePick config.pickLimit config.pickManagerLimit\n1          FALSE                0                       0\n  config.useLMP\n1         FALSE\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        config.blindReportReasonList\n1 AA03, AA14, AA68, AA33, AA01, AA24, AB28, 스팸홍보/도배글입니다., 음란물입니다., 불법정보를 포함하고 있습니다., 청소년에게 유해한 내용입니다., 욕설/생명경시/혐오/차별적 표현입니다., 개인정보 노출 게시물입니다., 불쾌한 표현이 있습니다., 사행성 오락이나 도박을 홍보하거나 권장하는 내용 등의 부적절한 스팸 홍보 행위, 동일하거나 유사한 내용 반복 게시, 성적 수치심을 일으키는 내용, 아동이나 청소년을 성 대상화한 표현, 과도하거나 의도적인 신체 노출, 음란한 행위와 관련된 부적절한 내용, 불법 행위, 불법 링크에 대한 정보 제공, 불법 상품을 판매하거나 유도하는 내용, 가출/왕따/학교폭력/자살 등 청소년에게 부정적인 영향을 조성하는 내용, 직·간접적인 욕설을 사용하여 타인에게 모욕감을 주는 내용, 생명을 경시여기거나 비하하는 내용, 계층/지역/종교/성별 등을 혐오하거나 비하하는 표현, 신체/외모/취향 등을 경멸하는 표현, 법적으로 중요한 타인의 개인정보를 게재, 당사자 동의 없는 특정 개인을 인지할 수 있는 정보, 불쾌한 표현 포함 [해당 사유는 클린봇 학습에 도움이 될 수 있습니다.] \n  bestList graph.gender.male graph.gender.female\n1     NULL                63                  37\n                                                                                                                                                               graph.old\n1 10, 20, 30, 40, 50, 60, 1, 6, 29, 42, 17, 4, exact, exact, exact, exact, exact, over, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, TRUE, FALSE, FALSE\n  graph.client graph.country graph.empty notice.noticeNo\n1           NA            NA       FALSE              43\n                               notice.title\n1 이태원 사고 댓글 작성시 주의 부탁드립니다\n                                                                                                                                                                                                                                                                                                                                                                                                                                        notice.content\n1 안녕하세요. 네이버뉴스입니다.\\r<br>\\r<br>이태원에서 10월29일 대규모 인명피해 사고가 발생했습니다.\\r<br>\\r<br>많은 분들이 뉴스 댓글을 통해 안타까움과 애도의 마음을 전하고 있습니다.\\r<br>하지만 일부 댓글에서 사회통념에서 벗어나는 글들이 눈에 띕니다.\\r<br>\\r<br>피해자들과 가족들이 댓글로 상처받지 않도록 악플이나 개인정보 노출이 우려되는 글들은  삼가주시기 바랍니다.\\r<br>이용자 여러분들의 협조를 부탁드립니다. \\r<br>\\r<br>네이버뉴스 드림\n            notice.regTime\n1 2022-10-30T19:24:47+0900\n\n$date\n[1] \"2022-11-27T05:11:20+0000\"\n\nattr(,\"row.names\")\n[1] 1\n\n드디어 다음 댓글을 가져올 수 있게 된 만큼, 많은 분들이 DNH4 패키지도 찾아주시리라\n기대합니다. DNH4 패키지는\nForkonLP 프로젝트의\n일부입니다.\n언제나 그렇듯, 잘못된 내용이 있거나 문제가 생기면 언제든지\n알려주세요. 감사합니다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106492737-9daf1c80-64fb-11eb-8739-beb6c28e89e0.png",
    "last_modified": "2022-11-27T05:11:21+00:00",
    "input_file": {}
  },
  {
    "path": "post/rtips-windows에서-rjava-스트레스-없이-설치하기/",
    "title": "[Rtips] Windows에서 rJava 스트레스 없이 설치하기",
    "description": "`multilinguer::install_jdk()`",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2018-05-08",
    "categories": [
      "R",
      "rJava",
      "KoNLP",
      "java",
      "installr",
      "windows",
      "multilinguer",
      "jdk"
    ],
    "contents": "\n\nContents\n업데이트\n2022-04-06\n업데이트\n2019-08-10\ninstallr\ninstall.java()\n따라하기\n\n\n업데이트 2022-04-06\nJava(jdk)를 설치하는 multilinguer\n패키지에서 install_jdk() 함수를 제공합니다.\ninstall.packages(\"multilinguer\")\nmultilinguer::install_jdk()\n업데이트 2019-08-10\nWindows와 MacOS 에서 동작하는 방법을 설명하는 포스트를\n작성하였습니다.\nhttps://mrchypark.github.io/post/correttor-r을-위해서-java를-설치해보자/\n한줄요약\ninstallr::install.java()\nrJava 패키지는 java의 풍부한 생태계를 R에서 사용하기\n위해 꼭 필요한 인터페이싱 패키지입니다. 비슷한 부류로 python의 reticulate, C++의\nRcpp 등이 있죠. 모두 각각의 언어를 설치하고 경로 설정을\n해줘야 하는 단계를 가지고 있습니다. 막상 진행해보면 쉬운 일이 아닙니다.\n그래서 해결책을 좀 찾아봤는데요. windows 환경에서 R에 관련된 설치와 R과\n함께 많이 사용하는 외부 프로그램 설치를 함수로 제공하는 installr 패키지를\n소개하겠습니다.\ninstallr\ninstallr 패키지는\nR의 업데이트 함수인 updateR()을 제공합니다. R과 함께\n사용하는 외부 프로그램 중 설치가 까다로운 ImageMagick이나\nMikTeX 같은 것도 제공합니다. 지금은\nrstudio에서 함께 제공하여 문제가 없지만, 저도 pandoc과 Tex 계열을 설치할\n때 도움을 받았습니다. 아무튼 installr 패키지에서\n제공하는 install.java()를 살펴보겠습니다.\ninstall.java()\nDownloads and set path openjdk\n\nDescription:\n\n     Downloads and set path the latest version of openjdk for Windows.\n\nUsage:\n\n    install.java(version = 10,\n                 page_with_download_url = \"http://jdk.java.net/java-se-ri/\",\n                 path = \"C:/java\")\n     \nArguments:\n\n    version: 9 or 10 is passible. Default is 10.\n\n    page_with_download_url: where to download. Default is <URL:http://jdk.java.net/java-se-ri/>\n\n    path: where to set java. Defulat path is C:/java\n\nDetails:\n\n    install openjdk 9 or 10 version for windows 10 64x.\n\nValue:\n\n    TRUE/FALSE - was the installation successful or not.\n\nAuthor(s):\n\n    Tal Galili and A. Jonathan R. Godfrey\n\nExamples:\n\n    ## Not run:\n    \n    install.java() \n    install.java(version = 10)\n    install.java(10)\n    ## End(Not run)\ninstall.java()는 3개의 인자를 제공합니다.\nversion,page_with_download_url,path이네요.\n현재는 windows 10 64x에서 jdk9와 jdk10만 지원한답니다.\nversion은 jdk 버전을 의미하는 것이군요.\npage_with_download_url은 바꿀 수 있어 보이지 않네요. openjdk 프로젝트의 최근 결과물인 것\n같습니다. path는 컴퓨터의 설치 경로를 뜻합니다. 기본값이\n이해하기 쉬운 곳에 있으니 저는 그냥 두겠습니다.\n따라하기\n조건을 잘 따져보겠습니다.\n1. windows 10 64비트를 사용하고 있다.\n2. 기존에 설치된 java가 없다.\n그럼 이제 R 콘솔을 실행해서 에러없이 동작하는지 확인하면 됩니다.\nremotes::install_github(\"talgalili/installr\")\ninstallr::install.java()\ninstall.packages(\"rJava\")\nlibrary(rJava)\n실제로 잘 동작하는 것인지 결과물로 확인하고 싶으시다면 KoNLP를 사용해보시면 좋을\n것 같습니다.\nremotes::install_github(\"talgalili/installr\")\ninstallr::install.java()\ninstall.packages('KoNLP')\nlibrary(KoNLP)\n\n## Checking user defined dictionary!\n문제 없이 실행되셨나요?\n언제나 그렇듯, 잘못된 내용이 있거나 문제가 생기면 언제든지\n알려주세요. 감사합니다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106492503-53c63680-64fb-11eb-9522-f09beac39a25.png",
    "last_modified": "2022-11-27T05:10:04+00:00",
    "input_file": {}
  },
  {
    "path": "post/kospacing-한글-띄어쓰기-패키지를-사용해보자/",
    "title": "[KoSpacing] 한글 띄어쓰기 패키지를 사용해보자",
    "description": "KoSpacing은 한글 띄어쓰기를 해주는 딥러닝 모델 패키지이다. python이 함께 필요한 패키지 기반으로 만들어서 python도 설치해야 한다. windows는 conda만 지원하므로 conda를 설치하여 사용해보자.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2018-05-02",
    "categories": [
      "R",
      "KoSpacing",
      "installr",
      "keras",
      "conda",
      "reticulate"
    ],
    "contents": "\n\nContents\n업데이트\n\n\n업데이트\n패키지의 설치 문제가 보고되어 확인하였습니다. 새롭게 설치를\n진행하시고, 0.1.1 버전인 것을 확인하시면 문제없이 동작할 것입니다. 0.1.1\n버전에서는 conda 명령이 실행가능한 상태여야 합니다.\nconda를 설치하는 conda4r 패키지를\n소개하는 포스트를\n작성하였습니다.\n세줄요약\nKoSpacing은 한글 띄어쓰기를 해주는 딥러닝 모델 패키지이다.\npython이 함께 필요한 패키지 기반으로 만들어서 python도 설치해야\n한다.\nwindows는 conda만 지원하므로 conda를 설치하여 사용해보자.\n한글 띄어쓰기 API 이용하는 포스트에서\n소개했던 API가 R & Python 패키지로 탄생하였습니다. (R 패키지 바로가기, Python 패키지\n바로가기) 이같은 멋진 패키지를 개발해주신 전희원님님 감사합니다.\nKoSpacing\n패키지는 전례가 없는 딥러닝 모델로 결과를 만드는 패키지로 본인의 포스트에서\nModel as a Program 이라고 소개한바 있습니다. R에는\ntensorflow와 keras가 reticulate\n패키지를 이용해서 python 패키지를 기반으로 최신 딥러닝 프레임워크를\n사용할 수 있습니다. KoSpacing은\nkeras로 작성된 모델을 사용하기 때문에, 패키지 사용을 위해서\nreticulate 설치가 필요합니다. KoNLP 역시\njava 기반의 라이브러리를 R에서 사용하기 위해\nrJava 설치가 필요했습니다. java의 경로 설정에\n비해 간편하긴 하지만 python을 또 설치해야 한다는 압박이\n있을 수 있다고 생각이 들었습니다. 간편하게 R에서 사용하는\n도구들의 설치를 도와주는 installr를 이용해서 miniconda를 설치해\n보겠습니다.\ninstallr\n업데이트: reticulate::install_miniconda()로\n설치하세요.\ninstallr 패키지는 windows 환경에서\nR에서 사용하는 여러 외부 프로그램들(pandoc, latex, 등등)을\n콘솔 명령으로 설치해주고, R의 버전 업데이트 등을 할 수 있는 함수를\n제공합니다. 완전히 Rphabetic(알파베틱)하죠.\nunix 계열(mac 포함)은 완전히 같은 기능을 제공하는 패키지가\n없다는 점이 조금 아쉽습니다.\nRtools를 설치하지 않으셨다면 아래 두 줄을 콘솔에서 실행해주세요.\ninstall.packages('installr')\ninstall.Rtools()\n이제 devtools를 설치하고 최신 버전의\ninstallr를 설치하도록 하겠습니다.\nif (!require('devtools')) install.packages('devtools')\ndevtools::install_github('talgalili/installr')\n최신 버전의 installr 패키지는\ninstall.conda() 함수를 제공합니다. 이를 이용해서\nKoSpacing 환경을 설치해보겠습니다.\nlibrary(installr)\ninstall.conda()\ninstall.conda() 함수는 windows 환경에 miniconda의 설치\n파일을 다운 받아 실행해 줍니다. 다운로드 페이지에서 자신에게\n맞는 설치 파일을 다운로드 받아 실행하셔도 같은 동작을 하는 것입니다.\n기본 옵션들을 유지한 채로 계속 다음을 눌러 설치를 완료해\n주세요.\n이제 KoSpacing을 설치해\n보겠습니다.\n업데이트: forkonlp 조직의 소스로 설치하도록 변경하였습니다.\nif (!require('remotes')) install.packages('remotes')\nremotes::install_github('forkonlp/KoSpacing')\n# remotes::install_github('haven-jeon/KoSpacing')\nlibrary(KoSpacing)\n잘 되셨나요? 저와는 조금 다른 메세지들이 보이실 수도 있습니다만,\n마지막 library(KoSpacing)이 잘 수행되면 성공인 겁니다!\nloaded KoSpacing model! 메세지를 확인하셨나요?\n이제 패키지를 사용해볼까요?\nspacing(\"김형호영화시장분석가는'1987'의네이버영화정보네티즌10점평에서언급된단어들을지난해12월27일부터올해1월10일까지통계프로그램R과KoNLP패키지로텍스트마이닝하여분석했다.\")\nR에서 keras를 사용하기 위해서 python이 설치되어 있어야 합니다.\nwindows는 conda만 사용할 수 있습니다. macOS와 linux 계열은 pip,\nvirtualenvs도 사용할 수 있습니다. installr 패키지는 windows 설치용\n패키지라는 것을 잊지 마세요.\n잘못된 내용이 있거나 문제가 생기면 언제든지 알려주세요.\n감사합니다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106488771-6474ad80-64f7-11eb-8ef2-6c3d41e24898.png",
    "last_modified": "2022-11-27T05:09:46+00:00",
    "input_file": {}
  },
  {
    "path": "post/r로나만의-웹페이지-만들기-2탄-github-pages/",
    "title": "[R로나만의] 웹페이지 만들기 2탄 Github pages",
    "description": "github pages로 나만의 웹페이지를 만들 수 있다. `.Rmd` 파일로 웹개발 지식없이 웹페이지를 만들자. 파일 이름이 곧 주소이고, index는 관례적으로 생략이 가능하다.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2018-03-24",
    "categories": [
      "R",
      "github",
      "web",
      "R로나만의",
      "Rmd",
      "github pages"
    ],
    "contents": "\n\n세줄요약\ngithub pages로 나만의 웹페이지를 만들 수 있다.\n.Rmd 파일로 웹개발 지식없이 웹페이지를 만들자.\n파일 이름이 곧 주소이고, index는 관례적으로 생략이 가능하다.\n드디어 blogdown을\n사용하기 위한 필수 내용을 설명하는 포스트를 작성하네요. 제 느린 속도를\n생각하면 감개가 무량합니다. ㅎㅎㅎ 그럼 시작해 볼까요?\n\nGithub pages는\n<계정이름>.github.io라는 주소를 제공하는 정적 웹\n호스팅 서비스입니다. Jekyll을 기본 엔진으로 하여\n마크다운 문서로 블로그나 홈페이지를 운영할 수도 있죠. 아무튼 오늘은\n.html 파일과 .md 파일로\n<계정이름>.github.io의 하위주소로 웹에 공개하는\n방법을 소개하겠습니다.\n설명드릴 내용은 아래 세 가지입니다.\n<계정이름>.github.io의 주소와\n<계정이름>.github.io/<저장소이름> 주소로\n웹페이지를 게시하는 것\n.md 파일과 .html 파일\n파일을 저장해야 하는 위치(root, docs, gh-pages branch)\n우선, 가장 간단한 조합인 폴더의 root 위치에 .md 파일로\n<계정이름>.github.io/<저장소이름>에 게시를\n해보겠습니다. 지난\n포스트에서 만들었던 myfirestrepo를\n사용해 보겠습니다.\n\n지난\n포스트를 따라 오셨다면 저처럼\nhttps://github.com/<계정이름>/myfirestrepo가\n있을겁니다. 이걸로 페이지를 만들 준비가 끝났습니다. 페이지 설정을 같이\n따라가 볼까요?\n\nCode, Issues, Pull requests 가 있는 탭의 오른쪽 마지막에 Settings가\n있습니다. 자신의 저장소에서만 보이는 옵션이니 회원가입하고 저장소를\n만드셔야 따라오실 수 있습니다.\n\n스크롤을 조금 내리면 드디어 GitHub Pages가 나옵니다. Source와 Theme\nChooser가 있는데, Theme Chooser는 나중에 설명하고, Source를 같이 보시죠.\n현재 None으로 되어있는데요, 클릭을 한 번 해볼까요?\n\nNone 말고 다른 옵션이 2개 더 있네요. 하나는 master branch, 다른\n하나는 master branch /docs folder 입니다. 각 옵션은 설정이 가능할 때, 즉\n호스팅할 파일이 있을 때 선택할 수 있습니다. 지금 /docs 폴더가 저장소내에\n없기 때문에 2번째 옵션은 선택할 수 없어요. 우선 기본 위치를 사용하는\nmaster branch를 설정해 보겠습니다. 첫 번째 옵션을 선택하고 오른쪽에 Save\n버튼을 클릭해주세요.\n\n설정이 저장되었다는군요.\n\n다시 GitHub Pages로 가보면 많은 것이 변해있습니다. 우선 https://mrchypark.github.io/myfirestrepo/ 주소로\n사이트가 게시 준비가 되었다네요!\n\n조금 기다려보면 이렇게 사이트가 게시되었다고 변한 녹색 알림을 볼 수\n있습니다. 새로고침을 해서 확인해보세요! 그럼 주소를 따라\n이동해볼까요?\n파란색 주소를 클릭하시면 됩니다.\n\n와! 드디어 github pages로 웹페이지를 게시했습니다! 이 간단한 페이지가\n뭘로 만들어진거냐 하면…\n\n처음 프로젝트 만들 때 체크로 만들었던 README.md 파일로\n만들어진 겁니다. 그렇다면 마크다운 문법으로 README.md\n파일을 바꾸면 웹 페이지 내용을 바꿀 수 있겠군요. 그래도 우리는 R로\n만들꺼니까, .Rmd로 .md를 만들어 봅시다.\n새로 시작해봅시다.\n이전\n포스트와 같이 할건데 라이선스는 지정하지 말고, 저장소 이름은\n마음대로 해보겠습니다. 어떤 보고서를 업로드할 꺼라면, 주소가 그 내용을\n반영하고 있으면 좋을 것 같네요. 저는 rmdhosting이라고\n해보겠습니다.\n\nRstudio로 프로젝트를 시작하면서 위 저장소로 시작해볼까요?\n\n위 화면의 오른쪽 아래처럼 파일이 3개가 있다면 잘 따라오신겁니다. 혹시\n잘 안되시면 댓글로 질문주시거나 이전\n포스트를 다시 확인해주세요. 그럼 이제 Rpubs\n소개 포스트에서 한 것처럼 .Rmd 파일을 만들겠습니다.\n대신 선택을 다른걸 할껀데요.\n\n위처럼 R markdown...을 만드는 팝업창을 켜고,\nFrom Template 탭을 확인하겠습니다.\n\n반가운 이름이 보이는군요! GitHub Document (Markdown)을\n선택하고 OK를 눌러 만들어보겠습니다.\n\n.Rmd 파일이 만들어졌습니다. 저장을 해주세요. 물론 필요한\n내용으로 수정해야겠죠?\n\n저는 우선 index 라고 저장하겠습니다. 모두 같은\n이름으로 따라해주세요. 처음에 .Rmd로 설정해서 새로 만들었기\n때문에 확장자를 지정하지 않아도 됩니다.\n\n그럼 이제 Knit 버튼을 눌러볼까요!?!\n\nRpubs\n소개 포스트에서는 여기서 Publish 버튼을 누르는 것으로\n진행했었습니다. 선택도 기본 html이었던것 같군요.\n이번에는 창을 닫고 다시 파일들을 확인해보겠습니다.\n\nindex.Rmd 파일은 제가 만든건데, Knit 버튼을\n누름으로써 index.md로 변환이 되었군요.\nindex_files 폴더도 새로 생겼습니다.\nindex_files 폴더는 보통 .md 파일로 변환하는\n과정에서 생기는 그림 파일들을 저장하는 곳입니다. 자동으로 일이 진행되니\n자세히 알고 있을 필요는 없습니다.\ngithub에 업로드\n이제 git을 이용해서 github에 push 해볼껀데요. 저희\n입장에서는 업로드와 같지만, git의 방법을 따라할겁니다.\n우선 오른쪽 위 창에서 git 탭을 클릭해보세요. 없다면 github 저장소를\n이용해서 프로젝트를 만든 것이 아닙니다. 이전\n포스트를 확인해주세요.\n\n저 같이 여러 리스트가 나올 건데요. 내용은 git에 대한 것이므로 (언제가\n될지 모르는) 나중에 다루도록 하구요. Commit 버튼을\n눌러보겠습니다.\n\n또 새로운 창이 뜹니다. 여기는 Commit을 하는 곳입니다.\n파일들이 변경된 상태를 저장하는 것이라고 이해하면 좋을 것\n같아요. 전부 저장해 볼까요?\n\n파일을 전부 선택합니다.\n\n그리고 파일 위에 Stage 버튼을 눌러 Staged\n박스를 전부 체크합니다.\n\n방금 과정 말고 Staged 박스를 하나씩 클릭해도 됩니다.\n\n\n오른쪽에 Commit message 칸에 지금 저장하는\n상태에 대해 간단한 설명글을 씁니다. 이건 git의\n기능으로 필수이기 때문에 뭐라도 적어주세요.\n그리고 Commit 버튼을 눌러볼까요?\n\nCommit을 어떻게 했다는 이러저러한 설명이 나오네요. 잘\n된거 같으니 확인 버튼을 누르겠습니다.\n다음 버튼은 오른쪽 가장 위에 있는 push 버튼입니다.\npush는 Commit된 내용들을 원격 저장소에\n보낸다는 뜻입니다. 업로드랑 비슷하죠? 그럼 클릭해볼까요.\n\n뭐라고 뭐라고 하다가…\n\n이렇게 master -> master라는 메세지가 뜨면 잘\npush(업로드)가 된 것입니다. github 웹 페이지로\n가서 잘 진행이 됬는지 확인해보죠.\n\n잘 된거 같습니다! 처음에는 만들지 않았던 파일들이 보이구요. 다행히도\nRstudio에서 만들어서 push 한 것들이네요!\n그럼 위에서 한 것처럼, setting으로 가서 github pages를 설정해볼까요?\n지금 파일들이 master branch에 있으니 선택해서\n저장해보겠습니다.\n\n사이트가 호스팅할 준비가 되었다고 하네요.\n\n이제 다 되었습니다!\n한번 주소를\n클릭해서 잘 호스팅되고 있는지 확인해볼까요?\n\n이렇게 허탈한 화면을 볼 수도 있습니다. 새로고침을 좀 해보셔도 안되면\nREADME.md 파일을 한번 지워보세요. 지우는 방법은 2가지가\n있는데, 하나는 Rstudio에서 지운후 Commit하고\nPush하는 것이구요. 다른 하나는 Github 웹\n페이지에서 바로 지우는 겁니다. 간단한 동작들은 Github 웹\n페이지에서 기능을 제공합니다.\n\n이 창에서 README.md 파일을 클릭해주세요.\n\n이 화면이면 맞습니다. 오른쪽 끝에 보니 모니터, 펜, 쓰레기통 버튼이\n보이는군요. 더 말하지 않아도 느낌이 오시죠?!\n\n역시 쓰레기통 버튼이었습니다. 클릭해볼께요!\n\n역시 git의 관리를 받는 파일들이라 파일을 지우는 것도\n어떤 상태인 모양입니다. 파일이 지워진 상태를\nCommit하는 창이 나오는군요.\n\n스크롤을 내려서 초록색 버튼인 Commit changes를\n클릭합니다. Commit message는 기본값이 있어서 알아서 저장이\n되는데요. 바꾸고 싶으시면 다르게 작성하셔도 됩니다. 지금은 기본값으로\nDelete READM.md가 들어가 있네요. 저는 마음에 드니까 그냥\n두겠습니다.\n\n파일이 성공적으로 지워졌다고 합니다.\n\nREADME.md 파일은 Github에서 관심가지는\n것이라고 설명드렸었나요? 파일이 없으니까 만드는게 어떻겠냐고 제안하네요.\n어쨌든 무시하고 우리의 웹 페이지 주소로 다시 가보겠습니다.\n\nhttps://mrchypark.github.io/rmdhosting/\n\n각자의 웹 페이지 주소의 구조는\nhttps://<계정명>.github.io/<저장소명>/ 입니다.\n제것과 비교해서 어떻게 다른지 한번 확인해보세요.\n이제 들어가면 우리가 보고 싶은 화면이 나옵니다.\n\n수고하셨습니다!\n앞으로도 설명드릴 내용이 많지만 이번 포스트는 여기서\n마무리해야겠네요.ㅎㅎ\nP.S 혹시 만약에라도 파일을 만드실 때 index.Rmd로 하지\n않으셔서 index.md 파일이 없으시다면 아직도 이 화면을 보지\n못하고 계실겁니다. 이 때는\nhttps://<계정명>.github.io/<저장소명>/<파일명>\n주소를 확인해주세요.\n\n제가 만든건\nhttps://<계정명>.github.io/<저장소명>/<파일명>\n으로도 동작하는군요?!? try.md같은 파일이라면\n<파일명> 부분을 try라고 해주시면 됩니다.\n제 경우라면 https://mrchypark.github.io/rmdhosting/try가 되겠죠.\n감사합니다.\nP.S2 질문, 오타 지적, 내용 지적, 외모 지적(응?), 와드용 공유 등 모두\n모두 환영합니다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106488428-0f389c00-64f7-11eb-8f44-692566f62dfd.png",
    "last_modified": "2022-11-27T05:10:12+00:00",
    "input_file": {}
  },
  {
    "path": "post/rqna-git을-설치했는데-rstudio에서-프로젝트-만들기-진행이-안되요/",
    "title": "[RQnA] git을 설치했는데 Rstudio에서 프로젝트 만들기 진행이 안되요",
    "description": "git을 설치하고도 프로젝트 만들기가 동작하지 않는다면, 환경 설정에서 git의 경로를 확인해주세요.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2018-03-19",
    "categories": [
      "R",
      "RQnA",
      "git",
      "github",
      "project",
      "rstudio",
      "setting"
    ],
    "contents": "\n\nContents\n본\n포스트는 windows 사용자 중 git 설치에 어려움이 있는 분들을 대상으로\n합니다.\n\n\n본\n포스트는 windows 사용자 중 git 설치에 어려움이 있는 분들을 대상으로\n합니다.\n한줄요약\nGit을 설치했는데도 안되면 Rstudio의 Tools > Global Options… >\nGit/SVN의 경로를 확인해라.\n지난\n포스트를 작성할 때 간단하게 넘어간 부분에 질문이 있어서 A/S 느낌으로\n급하게 포스트를 작성합니다. Rstudio에 github을 연결해 사용하기 위해서는\ngit을 설치해야 합니다. 지난\n포스트에서는 다른 블로그의 포스트를 소개해드렸습니다.\n상세히 설명된 포스트라 소개했는데, 아무래도 Rstudio에 대한 설정 내용이\n없어서 추가합니다.\ngit이 없습니다 팝업\n우선 프로젝트를 만드는 순서를 다시 따라가 볼까요?\n\n새 프로젝트를 만들기 위해 시작하면,\n\nVersion Control을 선택해서 진행했습니다.\n\n이제 이 화면입니다. Git과 Subversion을 선택하는 부분에서 Git을\n설치하지 않고 Git을 선택하면 아래와 같은 화면이 나옵니다.\n\n캡쳐 협찬해주신 이부일님\n감사합니다.\n보통은 위의 포스트를\n따라 설치하시고, 다시 위 프로젝트를 만드는 과정을 진행하면 다음 화면으로\n잘 넘어갑니다.\n\n이게 다음화면 인데요. 잘 안되셔서 재시작도 해봤는데, 여전히 진행이\n안되는 문제가 있었습니다. 그러면 Rstudio의 설정을 확인하여 해결할 수\n있습니다.\n\nTools > Global Options… 를 찾아 클릭합니다.\n\n옵션화면입니다. 아래에서 세번째에 Git/SVN 탭을 클릭합니다.\n\nGit executable: 이라고 되어있는 부분을 한 번 볼까요? 제\n컴퓨터에 설치된 Git은 C:/Program Files/Git/bin/git.exe에\n위치하고 있고, 그걸 사용한다고 Rstudio에 설정되어 있네요. 설치를\n했는데도 진행이 안되시는 분들은 이 곳의 경로를 확인해보시면 좋을 것\n같습니다.\n\n아마도 이렇게 되어 있을 것 같습니다.\n\n다른 설정 변경 없이 Git을 설치하셨다면 저와 같은 경로를 설정해주시면\n됩니다. 혹시 모르니 탐색기에서 경로에 파일이 있는지 확인해주세요!\n경로를 수정해도 진행이 안되시는 분들은 댓글로 알려주세요.\n감사합니다!\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106488004-9a656200-64f6-11eb-96b0-ad045e371d5a.png",
    "last_modified": "2022-11-27T05:09:49+00:00",
    "input_file": {}
  },
  {
    "path": "post/github-rstudio로-github-프로젝트-시작하기/",
    "title": "[github] rstudio로 github 프로젝트 시작하기",
    "description": "github은 git의 공개 remote repo를 제공하는 서비스다. 그래서 git 사용법을 알아야 한다. Rstudio의 project를 사용하면 좀 쉽다.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2018-03-15",
    "categories": [
      "R",
      "rstudio",
      "github",
      "project"
    ],
    "contents": "\n\n세줄요약\ngithub은 git의 공개 remote repo를 제공하는 서비스다.\n그래서 git 사용법을 알아야 한다.\nRstudio의 project를 사용하면 좀 쉽다.\nGithub은 이제 코드 관리와 공유\n플랫폼의 대명사입니다. R도 개발 언어로써 Github을 많이 사용할 기회가\n있는데요. 코드 공유, 패키지 공유, 분석 결과 공유 정도로 쓰임새를 정리할\n수 있을 것 같습니다. 이 때 많은 분들의 필요은 아마 분석 결과 공유이지\n않을까 싶습니다.\n분석 결과를 공유하기 위해서 github을 사용하실 때, R의 IDE로 많이\n사용하는 RStudio와 함께 사용하는 법을 소개해드릴까 합니다.\n우선 github에 repository를 만들어 시작하는 다양한 방법이 있습니다.\n단적으로는 웹브라우저에서 파일 만들기나 업로드로 진행하셔도 됩니다.\n각각의 방법을 설명하기 전에, github의 개념을 간단하게만 짚고\n넘어가겠습니다.\n코드의 저장 상태 백업과 공유를 위해서 git은 작업하는 나의 컴퓨터\n공간인 로컬 저장소(local repository)와 원격 저장소(remote\nrepository)라는 개념으로 구분하여 사용합니다. local을 개인이 일하고\n작업하는 공간, remote는 백업하고 공유하는 공간입니다.\n\n그런데 remote를 누가 그냥 주는 것도 아니고, 필요한 사람이 따로\n구축해야 합니다. 큰일인거죠. 이걸 SNS처럼 인터넷 서비스로 만든 것이 바로\nGithub입니다. Github은 원격 저장소를 회원 가입한 사람 모두에게 무료로\n나눠준거죠. 조건이 있다면 저장소를 공개(public)해야 합니다.\n비공개(private)로 만들려면 돈을 내야 합니다. 이런 Github의 유료정책을\n파고 들어서 [Gitlab][Gitlab]이나 Bitbucket은 무료 비공개 repo를\n제공하고 있습니다. 사용법이 좀 다르지만 git과 subvesion을 모두 사용할 수\n있으니 선택지가 넓은 셈이죠. 우리는 분석 결과 공유를 목적으로\n저장소(repository)를 사용할 계획이니 Github을 사용하겠습니다.\n시작해볼까요?\n로컬과 원격, 프로젝트의 시작\n무언가 작업이 발생하면 아주 작거나 간단한 것이 아니라면 프로젝트라고\n정의합니다. 원래 분석 프로젝트라고 하면 문제정의 -\n데이터 확보 - 분석 - 결과 공유의\n과정을 거칩니다. 각각의 세부항목도 많지만 우선은 넘어갈께요. 저 모든\n과정을 프로젝트라고 볼 수도 있지만, 우리는 결과 공유만\n프로젝트라고 합시다. 더 쉽게 하기 위해서 결과물이 .Rmd\n파일로 되어 있다고 해보겠습니다. 그렇게 하면 해야할 일은\ngithub에 새 저장소 만들기\n새 저장소에 결과물 업로드하기\n이제 여기서 몇 가지 분기가 발생하는데요.\ngit을 사용할 것인가 말것인가\n결과물을 어떤 파일 형식으로 저장할 것인가\n입니다.\ngit을 사용하지 않는다면 그냥 github에서 제공하는\nupload files 버튼으로 업로드 하는 방법이 있습니다. 예를\n들어 .pdf는 엄청 큰 파일이 아닌 이상 업로드하면 바로 웹에서\n보여주기도 합니다.\n\n이 주소로\n확인하실 수 있습니다. 예쁘지는 않을 수…\n우리는 R을 사용하니 파일 형식은 다양할 수 있습니다.\n.Rmd만 사용하면 이론적으로는 rpubs\n포스트에서 보여드린 만큼이나 가능하죠. 대표적으로 많이 사용하는\n형식으로는 .docx같이 MS 오피스 계열의 결과물이 있습니다.\n그리고 Github 친화적으로는 .md와\n.html을 꼽을 수 있을 것 같습니다.\n.md는 GFM이란게\n있을 정도로 Github이 사랑하는 파일 형식입니다. 오픈소스 저장소로써 많이\n사용하는 관례인 README.md는 파일을 보지 않아도 프로젝트\n페이지에서 출력도 해줍니다.\n.html은 Github\npages 서비스를 통해서 사용할 수 있습니다. 아마 다음 포스트를 Github\npages를 이용해서 웹페이지를 만들거나 하는 방법을 소개할 수 있을 거라\n기대하고 있습니다.\n위 두 파일 형식은 Github 친화적이기도 하면서 변환 동작에 다른 외부\n의존성이 없어서 작업환경을 만들기 쉽다는 장점이 있습니다. 예를 들어\n.pdf는 Latex 엔진을 추가로\n설치해야 합니다. 한글을 지원하는 엔진을 선정해야 해서 KTUG에서 관련 정보를 찾으실 수\n있습니다.\n서문이 너무 길었네요. Rstudio를 사용해서 Github 프로젝트를\n시작해보겠습니다.\ngit의 워크플로우\n\nGithub!\n위에서 Github이 git의 원격 저장소라는 설명을 드렸습니다. git을 사용해\n시작하는 상황은 두 가지입니다.\n처음 폴더를 만들어 로컬 저장소를 초기화하며 시작하기\n기존에 있는 프로젝트를 원격 저장소에서 클론하여 시작하기\n초기화하면서 시작하면 원격 저장소를 연결하는 과정이 추가로\n필요합니다. 원격 저장소를 연결하여 파일들을 업로드하는 행위를\n푸쉬(push)라고 하는데, 천천히 할 것이라면 초기화로\n시작하는 것도 좋은 선택입니다. 원격 저장소를 바로 사용할 것이라면, 원격\n저장소를 먼저 만들어 클론하면서 시작하는게 조금 더 제가 생각하는 쉬운\n방법입니다. 저는 원격 저장소를 바로 사용할 것이니 클론으로 시작하는\n방법을 소개하겠습니다.\n클론(git clone)으로 시작하기\n클론으로 시작하려면 원격 저장소를 먼저 만들어야\n한다고 말씀드렸습니다.\n\n로그인을 하고\n\n메인화면에\n\n오른쪽 위 + 버튼을 누르면 메뉴가 나옵니다.\n\n우린 새 저장소 만들어야 하니 New repository를\n선택해주세요.\n\n저장소 이름을 myfirstrepo 라고 했습니다. 옵션을 좀\n살펴볼까요?\nOwner\n계정입니다. 보통 자기 것만 있는데, 그룹 계정같은 것이 더 있을 수\n있습니다.\nRepository name\n저장소 이름입니다. 자신의 계정 내에만 겹치치 않으면 되니 편하게\n만들어 주세요.\nDescription\n저장소를 간단히 설명하는 곳입니다. 한 줄 정도로 설명문을 작성하면\n검색같은 곳에 같이 보여집니다.\n공개 범위\n공개 범위는 Public과 Private이 있습니다. 우리는 Public은 선택하죠.\nPrivate은 비용을 사용해야 합니다.\nREADME\n오픈소스 프로젝트는 관례적으로 root 위치에 README 파일을 두고\n있습니다. 여기서 선택하면 저장소 이름을 작성한 README.md 파일을 같이\n만들어줍니다. 우리는 선택해서 시작하겠습니다.\n.gitignore\ngit 시스템이 관리하지 않을 파일들의 리스트를 담고 있는 텍스트\n파일입니다. 파일명 앞에 .로만 되어 있는 건 숨김 파일이라는\n뜻입니다.\n\ngithub에서는 각 언어에서 관례적으로 필요한 .gitignore 리스트를\n템플릿으로 제공합니다. 우리도 R로 선택해 볼까요?\nlicense\n저장소의 코드들에 대한 라이선스를 지정할 수 있습니다. 정확히는\n.gitignore 파일처럼 주요 라이선스들의 템플릿을\n제공합니다.\n\n\n우리는 사용에 제약이 없고 대신 출처만 좀 써달라는 MIT\n라이선스로 하겠습니다.\n원격 저장소 만들기\n\n이제 초록 버튼을 눌러 원격 저장소를 만들어 보겠습니다.\n\n우리가 설정했던 .gitignore, LICENSE, README.md 파일 3개가 기본으로\n만들어지면서 원격 저장소가 생겼습니다. 이제 이 이 원격 저장소를 이용해\n로컬 저장소를 만들겠습니다.\nRstudio 프로젝트 만들기\n\n이제 Rstudio를 켜볼까요?\n\n오른쪽 위에 Project 버튼을 누르면 맨 위에 New Project\n버튼이 있습니다. File > New Project 로 진행하실 수도 있어요.\n\n새 프로젝트를 만들면 3가지 버튼이 나옵니다. 하나하나 살펴보죠.\nNew Directory : 새 폴더를 만들면서 프로젝트를 시작합니다. 새 폴더를\n만들면서 시작하기 때문에 같은 이름의 폴더가 있으면 에러가 납니다.\nExsting Directory : 기존에 있는 폴더를 프로젝트로 만듭니다. 저는\n사용할 일이 많이 없었습니다.\nVersion Control : 버전 관리 시스템으로 프로젝트를 시작합니다.\n\nVersion Control을 선택하겠습니다.\n\ngit과 subversion이 있는데 저희는 git을 사용할껍니다.\n\n아마 git이 설치가 안되어 있는 windows이신 분들은 다음으로 진행이\n안됩니다. 링크를\n참고해서 git을 설치해주세요.\n\n여기서 다운로드할 수 있습니다.\n\nGit을 설치했는데도 진행이 안되시면 이\n포스트를 참고하세요.(업데이트 - 2018.03.19)\n\n\n다시 github으로 돌아와서, 만든 원격 저장소의 URL을 복사합니다. 저는\n주소창을 애용하는 편인데, 오른쪽에 초록색 버튼을 눌러도 됩니다.\n\n그러면 주소 오른쪽 버튼이 URL 주소를 복사하는 버튼입니다. 그 버튼을\n클릭하고 Rstudio로 돌아오겠습니다.\n\n요 장면으로 다시 오시면 되구요.\n\n이렇게 주소를 Reposigory URL에 붙여넣으시면, 알아서 폴더 이름도\n설정됩니다. 보통 저장소 이름과 같게 설정합니다. 생성되는 폴더의 위치를\n지정해 줄 수 있는데요. ~/가 문서 폴더를 뜻하구요. 저 같은\n경우는 문서 폴더 밑에 project 폴더를 만들어서 그 안에\n프로젝트들을 만들어 관리하고 있습니다. 이제 Create project를\n눌러보겠습니다.\n\n자 git 명령어를 우리는 모르지만, 저 과정이\ngit clone https://github.com/mrchypark/myfirestrepo.git을\n수행한 것과 같습니다. 명령을 수행한 폴더 위치에\nmyfirestrepo(오타났네요;;)라는 폴더를 만들고, 그곳에 원격\n저장소의 git history와 파일들을 다운로드합니다.\n\n드디어 과정이 끝났습니다. Rstudio의 오른쪽 아래를 보시면 파일\n4개(github에서 만든 3개 + .Rproj 파일)가 있는 것을 확인하시면 과정이 잘\n끝난겁니다. 몇 가지가 원래랑 좀 다른데요. 하나는 콘솔창의 가장 위에\n보이는 작업공간(working directory)이 바뀌었구요. 그냥 프로젝트를 만들\n때와 달리 오른쪽 위 패널에 Git 탭이 추가된 것입니다.\ngithub과 연결된 프로젝트\n축하합니다! 드디어 github의 원격 저장소와 연결된 Rstudio 프로젝트를\n성공적으로 만들었습니다. 여기까지 따라하셨으면 새로운 프로젝트를 Git으로\n관리하면서 원격 저장소로 Github을 사용하는 상태가 되신겁니다. 이제\ngit으로 버전관리를 하거나 Github에 관련 내용을 올리는 내용을\n포스팅해야겠네요.ㄷㄷㄷ 따라 오시는 동안 궁금한 점이나 이상한 점, 잘\n안되거나 하는 부분이 있으면 댓글로 알려주세요. 블로그 글이 도움이\n되셨다면, 블로그에 도움을 주실 많은 방법이\n있습니다. 감사합니다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106487787-61c58880-64f6-11eb-8ec6-e210d8403e71.png",
    "last_modified": "2022-11-27T05:09:43+00:00",
    "input_file": {}
  },
  {
    "path": "post/번역-haproxy와-docker를-이용한-로드밸런싱/",
    "title": "[번역]Haproxy와 Docker를 이용한 로드밸런싱",
    "description": "load-balancing-applications-with-haproxy-and-docker 라는 제목의 글을 저자의 허락하에 번역하였습니다.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2018-03-12",
    "categories": [
      "docker",
      "haproxy",
      "swarm",
      "load balance"
    ],
    "contents": "\n\nContents\n실제 도커(Docker) 사용\n사례에 대한 예제\n\n\n본 번역은 원글을\n대상으로 저자의 허락을\n받았습니다. 저와 같은 문제에 직면한 분들에게 도움이 되었으면\n좋겠습니다.\n\n\n본 글에서 사용하는 이미지인 dockercloud-haproxy에서\n확인해보면 기능 추가는 없이 유지보수만 하는 이미지인 것을 알 수\n있습니다. 제품에 사용할 때는 참고해주세요.\n\n\n요약 : 도커(Docker)와 도커 스웜(Swarm), 스택(Stack)을 이용해서 여러\n개의 컨테이너를 추가 설정없이 연결하고 업데이트(컨테이너 갯수 추가/축소,\n버전업 등)하는 실전 예제를 수행해봄.\n\n실제 도커(Docker) 사용\n사례에 대한 예제\n최근에 일때문에 Docker, Docker Compose 및 Docker Swarm으로 로드\n밸런싱을 하는 글들을 많이 보았습니다. 몇백 개의 인스턴스가 있으며\n인스턴스를 관리하고 인스턴스간에 로드 밸런싱을 맞춰야하는 일입니다.\n이 주제를 다루는 많은 글들이 있지만, 정말 쉽고 간단한 사례만 다루기\n때문에 도움이 되지 않았습니다. 실제로 필요한 상황을 몇 가지 예로\n살펴보면,\n\n수백개의 컨테이너를 수동으로 생성하는 것\n그 수백개의 컨테이너 포트를 각각 다르게 수동으로 설정하는 것\nnginx conf 파일에 각 컨테이너의 ip와 포트를 일일이 작성하는 것\n\n그래서 우리가 현재 사용하고 있는 방법으로 예시 포스트를 작성하기로\n결정했습니다. 이것이 “올바른” 방법이나 유일한 방법은 아니지만, 지금 당장\n우리가 일하는 방법입니다. 포스트 작성은 Docker, Docker Compose 및 Docker\nSwarm을 알고 있다고 가정했습니다.\n\n시작해볼까요! :)\n예시를 위한 간단한\n어플리케이션\n간단한 Node.js 애플리케이션을 만들어 보겠습니다. 다음 코드를 사용하여\nindex.js라는 파일을 만듭니다.\nvar http = require('http');\nvar os = require('os');\nhttp.createServer(function (req, res) {\n    res.writeHead(200, {'Content-Type': 'text/html'});\n    res.end(`<h1>I'm ${os.hostname()}<\/h1>`);\n}).listen(8080);\n이제 Dockerfile이라는 이름의 파일을 만들어 아래 코드를\n저장합니다. 도커라이즈(Dockerize)1라고 합니다.\nFROM node\nRUN mkdir -p /usr/src/app\nCOPY index.js /usr/src/app\nEXPOSE 8080\nCMD [ \"node\", \"/usr/src/app/index\" ]\n예시로 작성한 간단한 어플리케이션(이하 멋진 Node.js 앱) 도커 이미지를\n빌드(build)하기 위해서 터미널에서\ndocker build -t awesome .이라고 입력합니다. 물론\nDockerfile과 index.js 파일이 한 공간에 있어야\n하고 Dockerfile이 있는 곳에서 실행해야 합니다.\n이제 간단하고 (그리고 멋진) Node.js 앱의 도커 이미지가 생겼습니다.\n이미지에서 컨테이너를 만들 수 있습니다. 해당 애플리케이션의 20 개\n컨테이너가 필요하다고 가정하면 해당 컨테이너를 만들고 관리하는 자동화 된\n방법이 필요합니다. 또한 요청을 라우팅하고 Node.js 컨테이너로 로드\n밸런싱하기 위해 HTTP 서버가 있는 컨테이너가 필요합니다.\nDocker Compose 사용하기\nHTTP 서버는 HAProxy를\n사용합니다. 즉, 포트 80을 수신하고 요청을 포트 8080의 다른 Node.js\n컨테이너에 로드 밸런싱하는 HAProxy가 있는 컨테이너를 만들어야 함을\n의미합니다. Docker Compose를 사용할 컨테이너 (Node.js 앱 및 HAProxy)를\n만들려면 docker-compose.yml 파일을 작성해 보겠습니다.\nversion: '3'\n\nservices:\n  awesome:\n   image: awesome\n   ports:\n     - 8080\n   environment:\n     - SERVICE_PORTS=8080\n   deploy:\n     replicas: 20\n     update_config:\n       parallelism: 5\n       delay: 10s\n     restart_policy:\n       condition: on-failure\n       max_attempts: 3\n       window: 120s\n   networks:\n     - web\n\n  proxy:\n    image: dockercloud/haproxy\n    depends_on:\n      - awesome\n    environment:\n      - BALANCE=leastconn\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock\n    ports:\n      - 80:80\n    networks:\n      - web\n    deploy:\n      placement:\n        constraints: [node.role == manager]\n\nnetworks:\n  web:\n    driver: overlay\n도대체 무슨 일이 일어나는 건지 설명하겠습니다. 우리는 2 가지 서비스를\n만들겁니다.\n첫 번째 서비스는 awesome으로 부를 멋진 Node.js\n앱입니다. 조금 전에 빌드한 awesome 이미지로 만들겁니다.\n8080 포트를 외부에 연결하고, 환경 변수로 SERVICE_PORTS로\n작성해두었습니다. HAProxy가 사용하는 설정으로 뒤에서 설명하겠습니다.\ndeploy 옵션으로 20개의 리플레카(replicas)2를\n만들고 업데이트 설정과 재시작 설정을 추가했습니다. 파일의 마지막에\n작성한 network인 web 네트워크에 모든\n컨테이너를 연결해둔 것이 가장 중요한 포인트입니다.\n두 번째 서비스는 Docker 팀의 haproxy 이미지로 만든\nHAProxy입니다. 이미 Docker 팀에서 만들어 두었기 때문에\n우리는 이미지를 빌드할 필요 없이 가져다 사용하면 됩니다.\ndepends_on 옵션으로 awesome 서비스가 부팅이\n완료된 이후에 실행을 시작합니다. 또한 volumes 옵션으로\ndocker.sock 파일을 공유합니다. HAProxy 컨테이너가\n네트워크에 이미 있거나 새롭게 들어오는 컨테이너들을 찾고 확인할 수\n있어야 하기 때문입니다. 우리는 80 포트는 외부에 연결했습니다. 그리고\nweb 네트워크에도 연결했습니다. 마지막으로 deploy 설정에서\nmanager node에서 항상 실행하도록 설정하였습니다. 이건 Docker Swarm의\n설정으로, node가 여러 개라면 volumes 옵션 때문에\n필요합니다.\n마지막으로 web이라는 이름의 network를\n생성하였습니다.\n\n진행하고 있는 프로젝트가 점점 멋져지고 있습니다. 그리고 거의 끝나갑니다!\nDockerCloud HAProxy 소개\n위에서 언급한대로 HTTP 서버로 HAProxy를 사용할 겁니다. 일반적인\n버전이 아니라 Docker 팀이 자신들의 클라우드에서 사용하는 버전을\n선택했습니다. awesome 서비스에서 SERVICE_PORTS\n환경변수를 사용한 이유이기도 합니다. SERVICE_PORTS\n환경변수로 설정한 포트는 HAProxy에 연결됩니다. 쉼표로\n구분하여 여러 포트를 연결할 수도 있습니다. 파일을 보면\nBALANCE 환경변수도 확인할 수 있습니다. 이것은 로드 밸런싱\n알고리즘을 선택하는 것인데요. 기본값인 roundrobin를 선택한\n것이 아니라 leastconn으로 설정했습니다.\nDocker Swarm 사용하기\n이제는 Swarm을 만들어 보겠습니다. (지금은 하나의 컴퓨터로 만들었지만\nSwarm에 더 많은 컴퓨터를 쉽게 추가 할 수 있음) 이렇게 하기 위해 우리는\ndocker swarm init을 입력하고 우리는 Swarm을 만들었습니다!!\n컴퓨터를 Swarm에 추가했으며, 지금 컴퓨터가 처음이기 때문에 Swarm의\n관리자이기도 합니다.\n네트워크, 서비스, 그리고 모든 컨테이너들을\n스택(stack)이라고 부릅니다. 스택을 생성하기 위해서는\ndocker stack 명령어를 사용해야 하지만 스택을\ndocker-compose.yml 파일로 수행하기를 원합니다. 그래야\n우리가 설계한대로 진행해줄테니까요.\ndocker stack deploy --compose-file=docker-compose.yml prod\n라고 실행하면 될 것 같습니다. deploy 명령으로 새로운 스택을\n배포하고, docker-compose.yml을 사용해 수행하기 위해서\n--compose-file 플래그(flag)를 사용했습니다. 물론 이미 있는\n스택을 업데이트할 때에도 명령을 사용할 수 있습니다. 마지막으로 우리는\n스택을 prod라고 부르기로 했습니다. (이걸 작성할 때 겨우\n생각한 이름이 이거라서 죄송합니다. :p)\nhttp://localhost 주소로 요청을 날리면, 우리는 응답으로\n컨테이너 ID를 받을 수 있습니다. 그러면 지금 상황에서는 매 요청마다 다른\nID를 받겠죠.\n\n요청마다 다른 컨테이너 ID를 받음\ndocker service ls 명령으로 우리 서비스들을 확인할 수\n있습니다. 어떤 서비스가 동작하고 있는지, 몇개의 복사본이 있는지 등을\n확인할 수 있죠.\n\n모든 도커 서비스 리스트\n이제 두번째 버전의 awesome 앱을 작성해보겠습니다. 코드를\n약간 바꿔서 응답의 마지막에 느낌표를 추가해보겠습니다.\nvar http = require('http');\nvar os = require('os');\nhttp.createServer(function (req, res) {\n    res.writeHead(200, {'Content-Type': 'text/html'});\n    res.end(`<h1>I'm ${os.hostname()}!!!<\/h1>`);\n}).listen(8080);\n이제 다시 빌드를 해야됩니다. 이번에 빌드할 때는\ndocker build -t awesome:v2 . 라고 이미지에 태그를\n추가해보겠습니다. awesome 이미지 이지만 태그가\nv2인 이미지를 만드는 것이지요. 서비스의 중단없이\nprod 스택에 awesome 서비스를 v2로\n교체하기 위해서는\ndocker service update --image awesome:v2 prod_awesome\n명령을 사용합니다. 그러면 docker-compose.yml에 명시한\n업데이터 설정과 같이 각 5개의 컨테이너가 순차적으로 업데이트를 할\n것입니다.\n도커가 차근차근 하지만 확실히 오래된 컨테이너를 제거하고 새로운\nv2 태그의 컨테이너를 실행하는 것을 확인할 수 있습니다. 그\n와중에 http://localhost에 요청해도 다운타임 없이 응답을\n받을 수 있습니다.\n\n몇몇 컨테이너는 다운타임 없이 두번째 버전을 응답\n만약 20개의 컨테이너보다 더 많이 필요하여 스케일을 키우고 싶다면,\ndocker service scale prod_awesome=503\n명령을 수행하면 됩니다. 도커는 awesome:v2 이미지로 30개의\n컨테이너를 추가로 실행할 것입니다.\n마무리\n이제 수백 개의 컨테이너를 수동으로 만들 필요가 없습니다. 우리는 앱의\n모든 컨테이너를 다른 포트에 둘 필요가 없습니다. 컨테이너 ip와 port를\n수동으로 ngninx / haproxy conf 파일에 쓸 필요가 없습니다. 또한 여러 서버\n(docker swarm 포함), 여러 서비스 (docker 작성 포함), 중단 시간없이 응용\n프로그램 업데이트, 중단 시간없이 확장 (또는 축소) 등의 작업을 수행 할 수\n있습니다.\n이번 글이 실용적이었으면 합니다. 그리고 혹시 당신의 회사에서는 어떻게\n사용하는지를 알려주시면 매우 기쁘게 듣겠습니다!\n\n역자주: 도커파일로 작성하여 이미지화 하는 것↩︎\n역자주: 복사본이라는 뜻으로 여기서는 같은 이미지에서\n생성된 같은 기능을 하는 컨테이너를 뜻함.↩︎\n역자가 가장 도움을 많이 받은 부분↩︎\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106568995-5cf4e900-6577-11eb-9440-f1dd52dafeb8.png",
    "last_modified": "2022-11-27T05:10:55+00:00",
    "input_file": {}
  },
  {
    "path": "post/r로나만의-웹페이지-만들기/",
    "title": "[R로나만의] 웹페이지 만들기 1탄 Rpubs",
    "description": "Rmd + RPubs로 웹페이지를 만들 수 있다. github pages 소개하려다 돌린건 안 비밀.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2018-03-09",
    "categories": [
      "R",
      "rpubs",
      "web",
      "html",
      "Rmd",
      "R로나만의"
    ],
    "contents": "\n\n세줄요약\nRmd + RPubs로 웹페이지를 만들 수 있다.\nRstudio에서 하면 쉽다.\ngithub pages 소개하려다 돌린건 안 비밀.\nWeb에 자신의 결과물을 정리하고 공개하는 것은 시간이 가면 갈 수록 그\n중요성을 더해 가고 있습니다.\n\n오늘날 웹사이트를 가지지 않은 사람은 존재하지 않는 것이다.\n\n저는 코드 공유 SNS인 Github을 이용해 코드를 공유하고\n대화하는 것을 공부하다 github\npages에 대해 알게 되었습니다. 거기에 .Rmd 파일은\n웹기술에 대한 사전지식 없이 .html 파일로 변환할 수\n있었습니다. R 마크다운 + github pages 조합으로\nR에서 만들 수 있는 여려 결과물들을 웹으로 공개하여 인터넷 주소로\n공유하는 방법이 있는 것입니다. 이건 다음 번에 설명하기로 하고, Rstudio를 이용해서 .Rmd\n문서를 .html 파일로 변경하여 웹페이지로 만들어주는 Rpubs라는 서비스를 소개하겠습니다.\nRpubs\n\nRpubs는\nEasy web publishing from R라는 말처럼 Rstudio로\n.html 파일을 쉽게 무료로 호스팅해주는\n서비스입니다. 우리는 .Rmd 파일로 쉽게 .html\n파일을 만들 수 있기 때문에, 이걸 이용해볼 겁니다.\n본래 일반적으로 사용하는 포멧은 .md 파일입니다. 판독(pandoc)이라는 오픈소스 프로젝트를\n이용해서 여러 다른 문서 포멧으로 변환할 수 있습니다. 아래 그림은 input\n-> output인데 한번 확인해 보시죠.\n\n이렇게 많은 변환 기능을 제공해주는 판독을 사용해서\n마크다운(.md)을 웹문서(.html)로 변환할\n겁니다.\n우리는 knitr 패키지를\n이용해서 .Rmd 문서를 .md 파일로 바꾸고, 판독을\n이용해서 원하는 다양한 포멧(이번 경우는 .html)으로\n바꿉니다.\n\n내부 동작은 이 정도로 가볍게 넘기고, Rstudio를 이용해서\n.Rmd 파일을 만들고 저장하고, .html 파일로\n바꿔보겠습니다.\n그럼 이제 Rstudio를 실행해 볼까요?\n<img src=“https://user-images.githubusercontent.com/6179259/37238875-1b273872-2473-11e8-8278-40edfd2aff12.PNG”,\nwidth=100%>\n새로 파일을 만드는 방법이 몇 가지 있지만, 우리는 아래 방법을 시도해\n볼겁니다.\n\nRstudio에서 File 버튼 밑에 새로 만들기 버튼을 누릅니다. 우리가 만들건\nR Markdown 입니다.\n\n필요한 패키지가 설치안 안되어 있는데, 설치할꺼냐고 물어보네요! 당연히\nYes를 눌러 패키지들을 설치해줍니다.\n\n패키지가 설치되고 있습니다. 글자가 깨진 부분은 기능에는 이상이 없으니\n우선은 넘어가겠습니다. 다음에 기회되면 한번 파보겠습니다.\n\n드디어 Rmd 파일을 만드는 창이 열렸습니다. 많은 옵션이 있지만 저희는\n기본으로 진행하려고 하니, 바로 OK를 눌러주세요.\n\n간단한 기능 설명이 포함되있는 문서가 만들어졌습니다. 그럼 간단하게만\n구조를 확인해 볼까요?\n\n우선 화면 내에 드래그 한 부분이 YAML header 입니다. YAML은 JSON, XML 같은 양식의 일종입니다.\n마크다운에는 header와 body 두 공간이 있습니다.\n물론 대부분의 마크업이 같은 구성을 가지고 있습니다.\nheader는 변환하기 위한 설정들을 작성하는 공간입니다. 지금\n화면에서는 html문서를 변환결과로 하겠다고 작성한 것입니다.\n여기에서\nhtml로 변환할 때의 다양한 옵션을 확인하세요.\nhtml 문서 이외에 다른 포멧들의 옵션도 설명이 잘되어\n있습니다.\n\nbody 부분은 전부 markdown 문법을 그대로 지원합니다. 문법\n설명은 정말 많이 있으니 한 번 확인해보세요. .Rmd는 코드\n덩어리에서 R 코드를 실행하고 결과를 함께 .md로\n변환해줍니다. 그래서 코드 덩어리 부분 문법만 확인하면 됩니다. 그 문법도\n지금 범위는 아니니 레퍼런스를\n확인해주세요!\n\n편집 공간의 왼쪽 위에 보면 Knit 버튼이 있습니다. Knit를\n바로 누르면 header에 작성한 output 양식에 따라\n바로 변환을 진행하구요. Knit 버튼의 화살표를 클릭하면 위의\n이미지와 같이 선택할 수 있는 옵션들이 나옵니다. 우리는\n.html이 되어야 하므로, 가장 위에\nKnit to HTML을 클릭해 보겠습니다.\n\nKnit 과정은 저장이 완료된 파일을 기준으로 변환을\n진행하기 때문에 파일이 온전히 저장된 상태여야 합니다. .Rmd\n파일을 저장하면 바로 변환 작업을 시작하며, 완료되면 팝업창으로 결과를\n보여줍니다.\n\n팝업창을 같이 확인해볼까요? 제일 위에 파일 이름을 보니\ntest.html로 .html 확장자인 것을 확인할 수\n있습니다. 팝업창은 기능이 제한적인 브라우저이므로\nOpen in Browser 버튼으로 크롬이나 익스플로러에서 파일을\n확인할 수 있습니다.\n\n드디어 Publish 버튼입니다. 처음 클릭하면 역시 추가\n패키지 설치를 묻는 창이 나오네요. 이전 것도 마찬가지지만 한번 설치하면\n다시 물어보지 않습니다. Yes로 설치를 진행해 주세요.\n\nPublish는 두 곳이 가능합니다. 드디어 제가 소개해드린\nRPubs를 선택할 수 있게 되었네요. 제 눈에는\nfree service가 크게 들여옵니다. ㅎㅎ\nRStudio Connect는 더 다양한 기능을 제공하는 방법(shiny\n등)이면서 기업 라이선스에서 많이 사용하는 방법입니다.\nRPubs를 선택하겠습니다.\n\n경고를 한번 해주는군요. Rpubs는 무료 서비스이기 때문에\n모든 사용자에게 공개되는 서비스입니다. 문서를 무료로\n웹서비스에 올릴 수 있지만, 제한적인 공개가 어렵다는 단점이 있군요.\n신기하게도 검색에도 잘 걸리는 편입니다. 파워포인트 형태의 결과물을\n공유하는 slideshare와 비슷하게\n보고서 형식의 문서를 공유하는 서비스라고 생각하면 좋을 것 같습니다.\n\nPublish 버튼으로 드디어 문서를 업로드합니다.\n두구두구두구두구둥!\n\n브라우저 창이 열리면서 로그인과 회원가입을 선택하는 페이지가\n열립니다. 회원가입으로 같이 따라가 볼까요? 로그인을 하면 바로 두 번째\n스탭으로 넘어갑니다.\n\n회원가입은 간단합니다. 아이디 역할을 할 email 주소, 문서상 공개될\nUsername, 이름과 비밀번호 , 비밀번호 확인입니다. 회원가입을\n해주세요.\n\n드디어 스텝 2 입니다. 문서의 제목과 설명을 설정할 수 있습니다.\nSlug라는 생소한 단어가 눈에 띕니다. 간단하게는 문서의\n인터넷 주소라고 생각하면 좋습니다. 아무것도 설정하지 않으면 무작위\n숫자로 자동 생성해줍니다. 저는 비운 채로 넘어가겠습니다.\n\n짜잔! 축하합니다. 저와 같은 과정을 따라오셨다면 거의 비슷한 문서가\n웹주소를 가진 상태로 세상에 공개되었을 겁니다. 예시는 그대로 공개해\n두었으니 확인해보세요. http://rpubs.com/test_user0375/368575 링크를 클릭하셔도\n좋습니다.\n오른쪽 아래에 댓글 기능인 Comments, 공유하는\nShare, 문서보기 모드인 Hide Toolbars를 선택할\n수 있습니다. 문서보기 모드가 많이 쓰일 것 같군요.\n데이터 분석에 있어 결과의 공유는 매우 중요합니다. 특히 과학적 방법에\n대한 설명과 재현성 확보를 통한 신뢰도 구축은 코드를 통한 문서화만이\n달성할 수 있는 목표입니다. 물론 데이터 공유 방법이나 다른 것들이\n받침되어야 하겠습니다.\nR markdown 문서를 웹으로 공유해서 좋은 분석가가 되어 보는 것은\n어떤가요?\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106486781-59208280-64f5-11eb-81cb-183510282c73.png",
    "last_modified": "2022-11-27T05:10:11+00:00",
    "input_file": {}
  },
  {
    "path": "post/blogdown으로-블로그-이사하기/",
    "title": "blogdown으로 블로그 이사하기",
    "description": "탈도 많았던 blog의 engine 이전을 완료했습니다. 사용하는 테마가 바뀌긴했지만, 그래도 지금 테마가 어느 정도 만족스러워 결정하게 되었습니다. 원래 `jekyll`로 작성한 블로그에서 `blogdown(Hugo)`으로 변경하였는데요. ...",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2018-03-06",
    "categories": [
      "blog",
      "blogdown",
      "hugo",
      "minimal",
      "rstudio"
    ],
    "contents": "\n\n탈도 많았던 blog의 engine 이전을 완료했습니다. 사용하는 테마가\n바뀌긴했지만, 그래도 지금 테마가 어느 정도 만족스러워 결정하게\n되었습니다. 원래 jekyll로 작성한 블로그에서\nblogdown(Hugo)으로 변경하였는데요. blogdown은 rstudio의 수석\n엔지니어인 Yihui Xie가 golang으로 작성된\nstatic site generator 입니다. jekyll 또한 같은\n범주의 도구이죠.\n그동안 jekyll을 사용한\n이유\njekyll은 간단함, 자유로운 테마 선택, 간단함 때문에\n사용했습니다.\njekyll의 간단함\njekyll 블로그는 Github 계정만 있으면\n아이디.github.io라는 주소로 쉽게 만들 수 있습니다! jekyll-now를\n포크하고, pages 설정만 하면 끝납니다.\njekyll은 지향점이 text를 블로그로 바꿔라!\n입니다. 덕분에 매우 쉬운 도구가 되었죠. .md 파일을\n블로그 포스트에 해당하는 형태로 운영할 수 있게 해줍니다.\nGithub는 ruby라는 언어로\n개발되었다고 합니다. 공교롭게도(!) jekyll도 ruby로 작성되어 있죠. 그래서\nGithub에서 제공하는 pages라는\n서비스에서 jekyll를 빌드없이 바로 사용할 수 있습니다. 물론\n.Rmd를 .md로 렌더링하는 과정이 필요하기 때문에\nR로 블로깅할 때는 아쉬운 대목입니다.\n자유로운 테마 선택\njekyll은 static site generator로써 가장\n유명한 도구 입니다. staticgen을\n확인해보면 압도적인 스타수를 확인할 수 있습니다. 다음 인기 있는 도구가\nHugo군요. 최근에는 Gatsby도 인기있다고\n들었습니다.\n아무튼… jekyll이 가장 인기있고 역사도 있는 만큼 선택할\n수 있는 테마의 범위가 가장 넓습니다. jekyllthemes라는 곳에서 잘 모아져\n있는 테마들을 구경할 수 도 있고, 따로 만들어진 테마들을 검색해서 찾을\n수도 있습니다. 저는 Lagrange라는 테마를\n선택했었습니다. 설명이 매우 잘 되어 있고(물론 영어입니다…), 사진 첨부가\n기능으로 들어가 있어서 이름만 정해주면 되었고, 결정적으로 디자인이 너무\n마음에 들었습니다.\n\njekyll의 간단함\n특별히 동작과정을 이해하려는 노력을 할 것이 아니라면 공부해야 할\n부분은 _config.yml 파일입니다.\n# Site Settings\ntitle:               Mrchypark\ntagline:             log for you & me\ndescription:\nbaseurl:            #\"/Lagrange\"\nurl:                #\"https://lenpaul.github.io\"\ngithub:\n  url:               #\"https://lenpaul.github.io/Lagrange\"\nauthor:\n  name:              \"박찬엽\"\n  email:             \"mrchypark@gmail.com\"\n  twitter:           \"mrchypark_\"\n  instagram:         \"mrchypark\"\n  github:            \"mrchypark\"\n  facebook:          \"mrchypark\"\n  linkedin:          \"chanyub.park\"\nnavigation:\n- title: Materials\n  url: /materials\n- title: Index\n  url: /index\n- title: About\n  url: /about\n\n\npaginate:            5\ndisqus:              \"mrchy****\"\nga:                  \"UA-478*****-**\"\n\n# Build settings\nmarkdown:            kramdown\nhighlighter:         rouge\npermalink:           none\ngems:                [jekyll-paginate]\nencoding:            \"UTF-8\"\n이건 기존의 jekyll로 블로그를 만들 때 사용한\n_config.yml 파일입니다. 테마가 친절한 편이여서 여러 SNS에\n대한 링크를 아이디만 넣어주면 바로 예쁘게 사용할 수 있게 설정해 줍니다.\n댓글을 위한 disqus나 GA 또한\nID만으로 연결을 해줍니다.\njekyll에서\nblogdown으로\n당연히도 jekyll은 R파베틱(Rphabetic)하지\n않기 때문입니다. 물론 Hugo라고 R파베틱한 것은 아니지만,\n패키지화되어 있다는 점이 Rstudio와의 호환성을 많이 올려줍니다.\nblogdown은 staticgen에서 두번째를 차지하고\n있는 Hugo를 R 패키지화한 도구입니다. Rstudio의\nAddin으로 사이트 구축, 새포스트 쓰기 등의 기능도 지원하고\nbuild_site() 명령어 한방으로 docs 폴더에\n블로그 구축을 완전히 끝내줍니다. Hugo가 빠른\n블로그라는 점도 한 몫했네요.\nblogdown은 설명서가 친절하다 - blogdown을\n만든 사람은 bookdown을 만든 사람이기도 합니다. 덕분에 자세한 메뉴얼이 온라인\n책으로 준비되어 있기도 합니다.\nrstudio와 호환이 좋다 - 아무래도 일하는 곳에 도구를 지원하는\n방식으로 패키지를 작성한 것 같습니다. Addin 기능 뿐만 아니라 Rstudio를\n블로그 글쓰기 에디터로 사용하는데 부족함 없게 지원합니다. 물론 버전이\n오르면서 한글 문제(정확하게는 중국어 문제)가 해결된 이유도\n있습니다.\n빠르다 - 신기하게 Hugo로 넘어간 많은 분들이\njekyll가 느려지는 문제를 지적하였습니다. 제 블로그가 글이\n많지는 않지만 미래를 대비하고자 하는 마음도 있었습니다.\n다시 도구 이전 신고\n네, 블로그를 blogdown으로 이전하였습니다. 추후 시간이\n되면 blogdown으로 블로그를 만드는 법에 대해서 포스팅하도록\n하겠습니다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106467983-b52cdc00-64e0-11eb-9f46-1f97f8abf56b.png",
    "last_modified": "2022-11-27T05:09:37+00:00",
    "input_file": {}
  },
  {
    "path": "post/rphabetic-알파베틱-제안/",
    "title": "Rphabetic(알파베틱) 제안",
    "description": "사용자 친화적 혹은 사용자가 이용하기 쉬운 을 개인적으로는 `Rphabetic`하다고 표현하려 합니다.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2018-03-06",
    "categories": [
      "suggest",
      "R",
      "term"
    ],
    "contents": "\n\nPython 공부를 하면서 재밌으면서도 직관적인 단어를 알게\n되었는데, Pythonic way입니다. 말하지 않아도\n파이썬스러운 방법이라는 뜻이라는게 한눈에\n들어오더라구요. Pythonic 하다, 하지 않다로도 많이 사용하는\n것을 봤습니다.\n그래서 R에서는 비슷한 단어가 없는건가 싶더라구요.\n찾아보니 R's way가 있었습니다만, 힙하지 않아\n보였습니다.(힙이라니…)\n아무튼 한국\nR 유저 그룹에 글을 올려 의견을 물었습니다. 제가\nR-legant하다를 먼저 제시하면서 다른 분들도 많은 의견을\n주셨습니다. 그러다가 역시 조금은 억지스러운가 라는 생각이 들었는데요.\nRcoholic 같이 발음으로도 좀 더 자연스러워야하지 않은가\n싶더라구요.\n고민 끝에 개인적으로는 Rphabetic하다고 표현하려\n합니다.\n굳이 정의하자면, 사용자 친화적 혹은 사용자가\n이용하기 쉬운 이라고 하면 어떨까요. 전에 리디북스의 분석가이신\n하헌철님께서 언급해주신 R의\n철학에 가까운 의미이지 않나 생각이 듭니다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106484489-0219ae00-64f3-11eb-8312-f4f6f8907adb.png",
    "last_modified": "2022-11-27T05:09:49+00:00",
    "input_file": {}
  },
  {
    "path": "post/구글-광고-추가/",
    "title": "구글 광고 추가",
    "description": "블로그 하단에 구글 광고를 추가하였습니다. 처음 붙여보는 것이라 하단 이외에 다른 곳에서도 광고가 나올 수 있습니다.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2018-03-06",
    "categories": [
      "anounce",
      "ad"
    ],
    "contents": "\n\n블로그 하단에 구글 광고를 추가하였습니다. 처음 붙여보는 것이라 하단\n이외에 다른 곳에서도 광고가 나올 수 있습니다. 읽어보시는 글이 도움이\n되셨다면 클릭 한 번 부탁드리겠습니다. 저는 여러 정보성 글로 먹고 사는\n일을 하고 싶습니다. 후원, 유료 컨텐츠등 다양한 방향으로도 시도할\n계획이니 많은 관심 부탁드립니다.\n감사합니다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106467282-c32e2d00-64df-11eb-9435-7ed1cc5bf3e0.png",
    "last_modified": "2022-11-27T05:10:51+00:00",
    "input_file": {}
  },
  {
    "path": "post/materials-페이지-업데이트/",
    "title": "Materials 페이지 업데이트",
    "description": "제 블로그 왼쪽 위에 Materials라는 메뉴를 추가하였습니다.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2017-11-22",
    "categories": [
      "news",
      "blog",
      "materials"
    ],
    "contents": "\n\n제 블로그 왼쪽 위에 Materials라는 메뉴가\n있습니다. 작성하는 자료들을 모아 놓는 공간으로 따로 분류해 두었었는데,\n그동안 만든 자료들이 좀 있어서 내용을 업데이트했습니다.\n짧게 소개하면 제가 패스트 캠퍼스에서 진행했던 강의 자료와 R로 api\n서버 만들기, 크롤링 하기, github 함께 사용하기 같은 발표자료를 링크해\n두었습니다.\n혹시 살펴보시다가 이야기해주실 부분에 대해서는 언제든지 어떤 체널로든\n피드백 부탁드립니다.\n감사합니다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106466661-f9b77800-64de-11eb-807d-fcedbfbc1df0.png",
    "last_modified": "2022-11-27T05:09:47+00:00",
    "input_file": {}
  },
  {
    "path": "post/한글-띄어쓰기-api-이용하기/",
    "title": "한글 띄어쓰기 API 이용하기",
    "description": "현재 아래 소개하는 api는 동작하지 않으며 KoSpacing패키지가 새롭게 배포되었습니다.\n패키지 사용 환경 설정은 본 블로그의 다른 포스트를 참고하세요.\nKoNLP 패키지를 만드신 고감자님께서 KoNLP에 한글 자동 띄어쓰기 기능을 추가하시기 위해서 관련 연구를 수행하시고 우선 결과물로 웹 요청으로 결과를 제공하는 API를 우선 공개하셨습니다....",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2017-10-09",
    "categories": [
      "R",
      "httr",
      "api",
      "server",
      "POST",
      "GET"
    ],
    "contents": "\n\nContents\n업데이트\n띄어쓰기 api 요청하기\nhttp 란\nR로 http\n요청하기\n\n\n\n업데이트\n현재 아래 소개하는 api는 동작하지 않으며 KoSpacing 패키지가\n새롭게 배포되었습니다. * 패키지 사용 환경 설정은 본 블로그의 다른\n포스트를 참고하세요.\nKoNLP 패키지를\n만드신 고감자님께서 KoNLP에 한글\n자동 띄어쓰기 기능을 추가하시기 위해서 관련\n연구를 수행하시고 우선 결과물로 웹 요청으로 결과를 제공하는 API를\n우선 공개하셨습니다.(관련글) 사용법도 함께\n공개하셨는데, R에서는 사용이 어색할 수 있는 reticulate 패키지로\n예시를 작성해주셔서 R에서 많이 사용하는 패키지들로 예시코드를 공유하면서\n웹 요청에 대한 내용도 함께 공유해볼까 합니다.\n띄어쓰기 api 요청하기\n먼저 공유해주신 코드를 살펴보겠습니다.\nlibrary(reticulate)\n\nrequests <- import('requests')\n\nspaced_sent <- requests$put('http://35.201.156.140:8080/spacing', \n      data=list(sent=\"아래와같은방식으로API를사용할수있으며,호출건수에대해서별도의제한은없으나,1회 호출에200글자로글자수를제한하고있다.\"))$json() \n\nprint(spaced_sent$sent)\nreticulate는 파이썬 코드를 R에서 사용할 있게 interface 해주는\n패키지로 위 코드를 실행하기 위해서는 reticulate 패키지, 파이썬, 파이썬의\nrequests 패키지가 필요합니다. 그럼 R에서 웹 요청을 보내기 좋은 httr 패키지로 코드를\n바꿔보겠습니다.\nif (!requireNamespace(\"httr\")) install.packages(\"httr\")\nlibrary(httr)\n\nbody<-list(sent=\"아래와같은방식으로API를사용할수있으며,호출건수에대해서별도의제한은없으나,1회 호출에200글자로글자수를제한하고있다.\")\nres<-PUT(url='http://35.201.156.140:8080/spacing', body=body)\n\ncontent(res)$sent\n## [1] \"아래와 같은 방식으로 API를 사용할 수 있으며, 호출 건수에 대해서 별도의 제한은 없으나, 1회 호출에 200글자로 글자수를 제한하고 있다. \"\n관련 기능을 만드실 때 고감자님에게 도움을 드린 것이 있는데 직접\n언급해주셨습니다. 다시 한번 감사드립니다. 아래로는 http란, R에서 간단한\n크롤링이나 api를 사용하기 위한 패키지 소개 및 간단한 사용 예시가\n작성되어 있습니다.\nhttp 란\nhttp란 보통 1999년에 발표된 http/1.1 버전을 뜻합니다.\n해당 링크에서 보면 프로토콜이란\n하나의 약속입니다. 브라우저와 서버가 서로 데이터를 주고 받기 위해서 만든\n규칙이라고 이해하시면 좋습니다. 그렇다면 웹의 정보를 R에서 가져오기\n위해서는 서버에게 브라우저가 요청하는 약속을 그대로 따라하면 좋을 것\n같습니다.\nR로 http 요청하기\nhttp로 요청하는 다양한 방법이 있지만, 간단하게는 GET과 POST만\n이해하시면 됩니다. 서버에게 요청하는 것은 request, 응답을 받는 것은\nresponse라고 하겠습니다.__(그놈의 영어)__ 우선 GET부터 보겠습니다.\nGET 요청\nGET은 서버의 주소만으로 서버에 데이터를 요청하는 방법입니다. 대부분의\n브라우저에 주소를 입력하고 엔터를 누르는 것과 같습니다. GET이라는 것을\n메소드라고 부릅니다. R에서는 http 요청을 하기 위한 다양항 패키지가\n있지만 메소드 이름을 바로 함수로 제공하는 httr 패키지를\n사용하겠습니다.\n\n\nif (!requireNamespace(\"httr\")) install.packages(\"httr\")\nlibrary(httr)\nres<-GET(\"https://mrchypark.github.io/\")\ncontent(res)\n\n\n{html_document}\n<html xmlns=\"http://www.w3.org/1999/xhtml\" lang=\"\" xml:lang=\"\">\n[1] <head>\\n<meta http-equiv=\"Content-Type\" content=\"text/html; cha ...\n[2] <body class=\"layout-listing\">\\n\\n<!--radix_placeholder_front_ma ...\n\n위의 결과에서 <html>이라고 나온 것을 볼 수\n있습니다. html는 css,\njavascrit와 함께 브라우저가 사람들이 볼 수 있는 그림을 그리도록 만들어진\n규칙입니다. GET 요청은 대부분 서버에서 이런 html 문서를 데이터로 받기\n위해서 브라우저에서 동작하는 방식입니다. 알고 계신 다른 사이트들을\n시도해보시면 더 이해가 좋을 것 같습니다. 이 html 문서에서 필요한 곳의\n내용만 추출하는 패키지로 rvest\n패키지가 있습니다. rvest 패키지 사용법은 많은 분들이 소개해주셔서\n검색해 보시길 추천드립니다.\nPOST 요청\nPOST는 서버에 데이터를 요청할 때 뭔가 값을 함께 요청하는 방식입니다.\n대표적으로 로그인이 있습니다. 위 고감자님의 요청은 PUT을 사용했는데,\nPOST와 거의 같습니다. POST를 값을 실어보내는 것을 body라고 합니다.\nbody는 R에서는 list 자료형으로 처리합니다.\n\n\nbody<-list(sent=\"아래와같은방식으로API를사용할수있으며,호출건수에대해서별도의제한은없으나,1회 호출에200글자로글자수를제한하고있다.\")\nbody\n\n\n$sent\n[1] \"아래와같은방식으로API를사용할수있으며,호출건수에대해서별도의제한은없으나,1회 호출에200글자로글자수를제한하고있다.\"\n\n위 띄어쓰기 API 요청을 보면 body를 선언하는 부분이\nlist로 되어 있고, 데이터는 띄어쓰기가 필요한 문장, 그\n이름을 sent로 하였습니다. 이건 서버에 sent라는\n이름으로 띄어쓰기가 필요한 문장을 함께 전달하기 위해서 선언한\n겁니다.\nPUT은 POST와 거의 같다고 했습니다. 여기서는\n예시를 PUT으로 하겠습니다.\nres<-PUT(url='http://35.201.156.140:8080/spacing', body=body, verbose())\n위는 PUT요청을 했을 때 일어나는 일들 전체를 보여줍니다.\nhttr 패키지가 다 알아서 해주니 우리는 이제 아래처럼\n요청하면 됩니다.\nres<-PUT(url='http://35.201.156.140:8080/spacing', body=body)\nres는 PUT 요청으로 서버에게 요청을 했을 때\n서버가 우리에게 돌려준 결과를 저장하였습니다. 위에서 말한\nresponse입니다.\nres\n## Response [http://35.201.156.140:8080/spacing]\n##   Date: 2018-03-05 07:15\n##   Status: 200\n##   Content-Type: application/json\n##   Size: 348 B\n## {\"sent\": \"\\uc544\\ub798\\uc640 \\uac19\\uc740 \\ubc29\\uc2dd\\uc73c\\ub85c API\\u...\n실제로 값에 response라고 하면서 여러 정보를 보여주고\n있습니다. 어느 서버 주소에서 받은 것인지, 언제 받았는지, 상태는 얼마인지\n받은 데이터가 어떤 것인지, 받은 데이터의 크기가 얼마나 되는지 같은\n것들이네요. 하나하나 따져 보시려면 str(res)를 수행해보시면\n좋을 것 같습니다. http가 response를 어떻게\n정의해 놨는지 알 수 있습니다.\n이 중에서 우리가 궁금한 것은 content입니다.\nhttr 패키지는 response 객체에서\ncontent만 보는 기능을 content() 함수로\n제공하고 있습니다. content()함수는 몇몇 유명한 형식에\n대해서 자동으로 가져오는 기능을 제공합니다.\ncontent(res)\n## $sent\n## [1] \"아래와 같은 방식으로 API를 사용할 수 있으며, 호출 건수에 대해서 별도의 제한은 없으나, 1회 호출에 200글자로 글자수를 제한하고 있다. \"\ncontent에 json 방식으로 준 모양입니다. R은\njson 방식의 데이터를 list 자료형으로\n해석합니다. json의 설명을\n확인해 보세요. list 이름이 sent인걸 보니\n마지막 단계만이 남았습니다.\ncontent(res)$sent\n## [1] \"아래와 같은 방식으로 API를 사용할 수 있으며, 호출 건수에 대해서 별도의 제한은 없으나, 1회 호출에 200글자로 글자수를 제한하고 있다. \"\nresData<-content(res)\nresData$sent\n## [1] \"아래와 같은 방식으로 API를 사용할 수 있으며, 호출 건수에 대해서 별도의 제한은 없으나, 1회 호출에 200글자로 글자수를 제한하고 있다. \"\nOpen API 라고 되어 있는 서비스들이 위와 같은 방식을 사용하고\n있습니다. 보통은 sent라고 되어 있는 부분(요청시 body로\n선언할 내용과 방법)을 서비스 제공자 쪽에서 설명해줘야 합니다. 다른 API\n서비스를 사용하실 때 오늘의 내용이 도움이 되었으면 합니다.\n끝까지 읽어주셔서 감사합니다. 질문, 지적 대환영이며 댓글로\n부탁드립니다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106461744-8c084d80-64d8-11eb-93a4-ebedf3fb21c7.png",
    "last_modified": "2022-11-27T05:11:52+00:00",
    "input_file": {}
  },
  {
    "path": "post/논리-연산자-정리/",
    "title": "논리 연산자 정리",
    "description": "R의 논리 연산자에 대해 설명합니다.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2017-07-31",
    "categories": [
      "operator",
      "logical",
      "Boolean",
      "R",
      "rlang"
    ],
    "contents": "\n\nContents\n논리\n연산자란\n논리 연산자\n논리 연산자 왼쪽의\n데이터가 1개 일때\n논리 연산자 왼쪽의\n데이터가 여러개 일때\n논리 연산자 데이터가 모두\n여러개 일때\n\n\n드디어 블로그에서 Rmd를 사용할 수 있게 되어서 매우 기쁜\n마음에 포스팅을 하나 기획하였습니다. 그것은 바로\n논리 연산자! 기본적은 것은 다 쉬운데 데이터가 여러 개인\n벡터(vector)일 때 동작에 대해서 많이 고민하지 않는 것 같아\n이렇게 첫 번째 주제로 잡았습니다.\n논리 연산자란\n논리 연산자(Logical Operators)란 논리\n자료형(logical로 표시하며 T/F를 의미)를 사칙 연산처럼 TRUE\n/ FALSE 를 계산하여 하나의 결과를 만드는 것이라고 할 수 있습니다.\n대표적으로 if 구문에 해당하는 조건문에서 사용하는데요, 코드를 짤 때\n조건문을 피할 수 없기 때문에 동작에 대해 잘 이해하고 있는 것이\n좋습니다.\nR에서 사용하는 논리 연산은 아래와 같습니다.\n논리 연산자\na, b: 숫자 데이터 1개\nx, y: 논리 데이터 1개\n\n\n연산자\n\n\n설명\n\n\na < b\n\n\na가 b보다 작다\n\n\na <= b\n\n\na가 b보다 작거나 같다\n\n\na > b\n\n\na가 b보다 크다\n\n\na >= b\n\n\na가 b보다 크거나 같다\n\n\na == b\n\n\na와 b가 같다\n\n\na !=\n\n\na와 b가 같지 않다\n\n\n!x\n\n\nx가 아니다\n\n\nx | y\n\n\nx이거나 y이다\n\n\nx & y\n\n\nx이고 y이다\n\n\nisTRUE(x)\n\n\nx가 TRUE이다\n\n\n더하기, 빼기 같은 산술 연산자도 있으니 R에서 사용하는 연산자 소개는\n이곳을\n참고하면 좋을 것 같습니다. 위에서 강조한 바와 같이 위에 논리 연산자는\n모두 데이터가 1개 일때를 의미합니다. 정확하게는 연산자의 왼쪽인 a는 여러\n데이터인 벡터(vector)여도 되는데, 연산자의 오른쪽인 b는\n한 개 여야만 합니다. 아니, 여러 개일 때 어떻게 동작하는지\n알고 있어야 합니다.\n우선 a가 1개일 때와 여러 개일 때를 확인해 보겠습니다.\n논리 연산자 왼쪽의\n데이터가 1개 일때\n데이터가 1개인 경우는 매우 간단하고, 모두 상상하는 처음 예시이기도\n합니다.\n\n\na <- 10\nb <- 30\n\na < b\n\n\n[1] TRUE\n\na <= b\n\n\n[1] TRUE\n\na > b\n\n\n[1] FALSE\n\na >= b\n\n\n[1] FALSE\n\na == b\n\n\n[1] FALSE\n\na != b\n\n\n[1] TRUE\n\n위에는 모두 상상하시는 대로 결과가 나왔으리라 생각합니다. 맨 아래만\n짚어보면 =는 <-와 같은 뜻이어서, 수학적인\n등호의 역할을 하길 기대해야 하는 기호는 ==입니다.\n==는 왼쪽과 오른쪽이 같다라는 뜻입니다. 그리고\n맨 위에 !x에 x가 아니다라는 설명을\n해두었습니다. x는 논리 데이터 1개라는 설명도 했죠. 그러다\n보니 !=는 !(a == b)와 의미가 같습니다.\n작성하기 편하게 하기위해서 약어처럼 정의를 해둔 것이지요. 보통은 논리\n자료형 앞에 붙어서 원래 결과의 부정을 뜻합니다.\n|나 &는 잘 아시리라 생각하고,\nisTRUE()를 좀 확인해 보겠습니다.\nisTRUE()\nR에서 몇 가지 요령이 있는데, ?함수이름,\nhelp(함수이름)이라고 하면 설명이 나오고, ()를\n붙이지 않고 함수이름만 콘솔에 입력하면 그 함수를 구성하는\n코드가 출력됩니다.\n\n\nisTRUE\n\n\nfunction (x) \nis.logical(x) && length(x) == 1L && !is.na(x) && x\n<bytecode: 0x7fb2c42d0710>\n<environment: namespace:base>\n\nisTRUE()가 어떻게 동작하는 함수인지 궁금해서 코드를\n확인해 봤습니다. 여러개가 있지만 눈에 들어오는 것은\nidentical(TRUE, x)네요. 입력인자인 x가\nTRUE와 같은 것인지를 확인하는 것입니다.\nidentical()은 정확하게 같은지를 결과로 줍니다.\n예를 들면 같은 숫자인데 자료형이 다르던가, R은\nNA를 계산할 수 없음으로 취급해서 ==으로\n확인하면 NA로 결과를 줍니다. 그래서 rstudio를 사용하시면\n== NA를 인식해서 is.ns()를 사용하라고 경고를\n주기도 합니다. 아래 코드를 봐주세요.\n\n\n2L == 2\n\n\n[1] TRUE\n\nidentical(2L,2)\n\n\n[1] FALSE\n\n10 == NA\n\n\n[1] NA\n\n10 != NA\n\n\n[1] NA\n\n10 > NA\n\n\n[1] NA\n\nidentical(10,NA)\n\n\n[1] FALSE\n\n그래서 isTRUE(x)는 x가 TRUE와 완전히\n같은지를 확인해서 같으면 TRUE, 다르면 FALSE를\n결과로 주는 함수입니다. 조건문 안에 identical()은\n익숙해지면 자주 사용하는 함수이니 확인해주세요.\n논리 연산자 왼쪽의\n데이터가 여러개 일때\n데이터가 여러개라는 것은 벡터(vector)로 구성한다는\n뜻입니다. 우선 결과를 확인해 보겠습니다. 일반적으로 벡터를 만들 때는\nc()를 사용합니다. ?c로 설명서를 확인해\n보세요.\n\n\na <- c(10,20,30,40,50)\nb <- 30\n\na <  b\n\n\n[1]  TRUE  TRUE FALSE FALSE FALSE\n\na <= b\n\n\n[1]  TRUE  TRUE  TRUE FALSE FALSE\n\na > b\n\n\n[1] FALSE FALSE FALSE  TRUE  TRUE\n\na >= b\n\n\n[1] FALSE FALSE  TRUE  TRUE  TRUE\n\na == b\n\n\n[1] FALSE FALSE  TRUE FALSE FALSE\n\na != b\n\n\n[1]  TRUE  TRUE FALSE  TRUE  TRUE\n\n결과를 확인해 보면 모두 a 데이터의 개수인 5개 만큼 결과\n또한 출력된 것을 확인할 수 있습니다. 이것은 산술 연산자에서도 확인할 수\n있는 동작인데요.\n\n\na <- c(10,20,30,40,50)\nb <- 30\n\na + b\n\n\n[1] 40 50 60 70 80\n\na - b\n\n\n[1] -20 -10   0  10  20\n\na * b\n\n\n[1]  300  600  900 1200 1500\n\na / b\n\n\n[1] 0.3333333 0.6666667 1.0000000 1.3333333 1.6666667\n\na ** b\n\n\n[1] 1.000000e+30 1.073742e+39 2.058911e+44 1.152922e+48 9.313226e+50\n\na %% b\n\n\n[1] 10 20  0 10 20\n\na %/% b\n\n\n[1] 0 0 1 1 1\n\n이렇게 연산자의 왼쪽이 여러개의 데이터인 벡터이고, 오른쪽이 데이터\n1개 일때(데이터가 1개 일때도 벡터라고 합니다.) 연산자는 왼쪽 데이터를\n기준으로 각각 연산을 수행해서 왼쪽 데이터의 개수만큼 결과를 보여줍니다.\n그렇다면, 논리 연산자 오른쪽의 데이터가 여러개면 어떻게 될까요? 예상되실\n겁니다.\n\n\na <- 30\nb <- c(10,20,30,40,50)\n\na <  b\n\n\n[1] FALSE FALSE FALSE  TRUE  TRUE\n\na <= b\n\n\n[1] FALSE FALSE  TRUE  TRUE  TRUE\n\na > b\n\n\n[1]  TRUE  TRUE FALSE FALSE FALSE\n\na >= b\n\n\n[1]  TRUE  TRUE  TRUE FALSE FALSE\n\na == b\n\n\n[1] FALSE FALSE  TRUE FALSE FALSE\n\na != b\n\n\n[1]  TRUE  TRUE FALSE  TRUE  TRUE\n\n논리 연산자 데이터가 모두\n여러개 일때\n그럼 이제 마지막 경우를 남겨두고 있습니다. 양쪽 다 여러개의 데이터인\n경우인데요, 이 경우에서도 데이터의 개수가 같은 경우와 다른 경우로\n달라집니다.\n데이터의 개수가 같은 경우\n먼저 결과부터 보시죠\n\n\na <- c(10,20,30,40,50)\nb <- c(1,2,3,4,5)\n\na <  b\n\n\n[1] FALSE FALSE FALSE FALSE FALSE\n\na <= b\n\n\n[1] FALSE FALSE FALSE FALSE FALSE\n\na > b\n\n\n[1] TRUE TRUE TRUE TRUE TRUE\n\na >= b\n\n\n[1] TRUE TRUE TRUE TRUE TRUE\n\na == b\n\n\n[1] FALSE FALSE FALSE FALSE FALSE\n\na != b\n\n\n[1] TRUE TRUE TRUE TRUE TRUE\n\n개수가 같으니 결과도 같은 개수만큼 나왔고, 그 의미는 각각의 위치에\n것들이 각각 연산되었다는 뜻입니다. |나 &도\n같이 동작하는지 보시죠\n\n\nx <- c(T,T,T)\ny <- c(T,F,F)\n\nx & y\n\n\n[1]  TRUE FALSE FALSE\n\nx | y\n\n\n[1] TRUE TRUE TRUE\n\n|나 &도 똑같이 결과가 데이터의 갯수와\n같이 3개로 나오는 것을 볼 수 있습니다. 그런데, 논리 자료형의 연산 결과가\n여러 개인 경우는 사실 조건문을 사용하는데 좋은 결과가 아닙니다. 그래서\n논리 자료형의 연산 결과를 1개로 정리하는 방법들이 있습니다.\n\n\nx <- c(T,T,T)\ny <- c(T,F,F)\n\nany(y)\n\n\n[1] TRUE\n\nall(y)\n\n\n[1] FALSE\n\nx && y\n\n\n[1] TRUE\n\nx || y\n\n\n[1] TRUE\n\n첫번째 방법은 any(), all()함수를 사용하는\n방법입니다. 두 함수 모두 인자로 논리 자료형의 벡터를 사용하는데요,\nany()는 뭐라도 하나 TRUE라면\nTRUE를 결과로 줍니다. any라는 이름에 걸맞죠.\nall()은 전부 TRUE여야 TRUE를\n줍니다. 역시 all이라는 이름에 걸맞습니다. 여러개의 논리\n데이터를 하나의 결과로 정리한다는 점에서 조건문에 사용하기 좋습니다.\n그 아래 ||와 &&도 결과를 한개만\n준다는 점에서는 같습니다만 연산 방식이 다릅니다. 이 두 연산자는 양쪽에\n데이터가 여러개가 온다고 하더라도 첫번째 데이터만 사용합니다. 조건문의\n()에 논리 데이터가 여러개이면 경고를 주고 첫번째 데이터만\n사용한다고 합니다. ||와 &&은\n의도적으로 모두 첫번째 데이터만 연산에 사용한다는 것을 명시적으로\n표현하는 것입니다. 한번 확인해 보겠습니다.\n\n\nx <- c(T,T,T)\ny <- c(T,F,F)\nx && y\n\n\n[1] TRUE\n\nx || y\n\n\n[1] TRUE\n\nx <- c(F,T,T)\ny <- c(T,F,F)\nx && y\n\n\n[1] FALSE\n\nx || y\n\n\n[1] TRUE\n\nx <- c(T,T,T)\ny <- c(F,F,F)\nx && y\n\n\n[1] FALSE\n\nx || y\n\n\n[1] TRUE\n\nx <- c(F,T,T)\ny <- c(F,F,F)\nx && y\n\n\n[1] FALSE\n\nx || y\n\n\n[1] FALSE\n\n지금은 앞에만 달리하며 출력했는데, 뒤에 데이터를 변경해서 결과가\n달라지지 않는 것을 직접 확인해 보시면 좋을 것 같습니다. 더 자세한 정보는\n?\"|\"로 확인하실 수 있습니다. 한 문장만 가져와서\n보여드리면\n\nThe longer form evaluates left to right examining only the first\nelement of each vector.\n\n여기서 longer form이 ||나\n&&를 뜻합니다.\n데이터의 개수가 다른 경우\n데이터의 개수가 다른 경우는 또 두 가지 경우로 나뉩니다. 두 데이터의\n개수가 배수 관계에 있는 경우와 아닌 경우입니다. 배수인 경우 먼저\n보시죠\n데이터의 개수가 배수 관계인\n경우\n\n\na <- c(10,20,30,40,50,60)\nb <- c(10,20,30)\n\na <  b\n\n\n[1] FALSE FALSE FALSE FALSE FALSE FALSE\n\na <= b\n\n\n[1]  TRUE  TRUE  TRUE FALSE FALSE FALSE\n\na > b\n\n\n[1] FALSE FALSE FALSE  TRUE  TRUE  TRUE\n\na >= b\n\n\n[1] TRUE TRUE TRUE TRUE TRUE TRUE\n\na == b\n\n\n[1]  TRUE  TRUE  TRUE FALSE FALSE FALSE\n\na != b\n\n\n[1] FALSE FALSE FALSE  TRUE  TRUE  TRUE\n\n우선 결과가 경고 없이 잘 나왔고, 총 6개입니다. 이때는 개수가 부족한\n쪽이 개수가 많은 쪽 만큼 한번 더 돌아서(Recycle) 연산에\n사용된 것을 알 수 있습니다. 이것을 Recycling Rule이라고\n합니다. 배수관계에 있다보니 특별히 잘못했다고 경고를 주지도 않습니다.\n그럼 배수 관계가 아닐 떈 어떻게 될까요?\n데이터의 개수가 배수\n관계가 아닌 경우\n\n\na <- c(10,20,30,40,50)\nb <- c(10,20,30)\n\na <  b\n\n\n[1] FALSE FALSE FALSE FALSE FALSE\n\na <= b\n\n\n[1]  TRUE  TRUE  TRUE FALSE FALSE\n\na > b\n\n\n[1] FALSE FALSE FALSE  TRUE  TRUE\n\na >= b\n\n\n[1] TRUE TRUE TRUE TRUE TRUE\n\na == b\n\n\n[1]  TRUE  TRUE  TRUE FALSE FALSE\n\na != b\n\n\n[1] FALSE FALSE FALSE  TRUE  TRUE\n\n똑같이 Recycling Rule이 적용되어 적은 쪽이 많은 쪽 개수\n만큼 한번 더 돌아서 사용하여 연산하지만, 쓰다 말기 때문에 경고를 줍니다.\n배수관계가 아닌데 너가 지금 잘 사용한 게 맞는거냐라고 물어보는 거죠.\n맞다면 무시하시면 됩니다. 결과도 긴 데이터쪽 개수만큼인 5개로 나왔네요.\n의도하신거라면 이대로 진행하시면 됩니다.\n이렇게 논리 연산자도 데이터가 여러개일 때 산술 연산자와 같은 동작을\n취합니다. 이 부분이 아마 기초를 배운 후에 조합해서 확인해 봐야 하는\n부분인 것 같습니다. 그리고 많이 실수하시는 부분이 있습니다. 논리\n자료형이라면 특별히 문제되지 않는데, ==의 동작을\n오해하세요. 사실 이걸 이야기하고 싶어서 위에 저 많은 얘기를 했는데요.\n이미 주제 하나 정도 되는 것 같아 포스트를 나누겠습니다.\n다음 포스트는 왜\n%in% 연산자를 사용하는가? feat.==\n입니다.\n끝까지 읽어주셔서 감사합니다. 질문, 지적 대환영이며 댓글로\n부탁드립니다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106395892-0e94fc80-6448-11eb-9836-f3f8449a472b.png",
    "last_modified": "2022-11-27T05:10:54+00:00",
    "input_file": {}
  },
  {
    "path": "post/블로그-reboot/",
    "title": "블로그 reboot",
    "description": "blogdown으로 옮겨서 시작합니다.",
    "author": [
      {
        "name": "Chanyub Park",
        "url": "https://mrchypark.github.io/about"
      }
    ],
    "date": "2017-04-05",
    "categories": [
      "anounce",
      "blog",
      "reboot"
    ],
    "contents": "\n\n블로그를 찾아주신 모든 분들 반갑습니다! 안녕하세요 박찬엽입니다. 여러\n블로그 도구들과 씨름하다 정착하고 싶어 어느 정도 정리했습니다. 가능하면\n한 번에 처리할 방법들을 고민하고 사용해보고 하는 기간이 길었던 것\n같습니다. reboot라고 제목을 지은 이유는 이런 저런 실험을 하고 OS에\n환경을 세팅하고 난 후에는 reboot을 하기 때문입니다. 이제 다시 reboot할\n일 없는 열일하는 서버처럼 잘 운영해 보겠습니다.\n감사합니다.\n\n\n\n",
    "preview": "https://user-images.githubusercontent.com/6179259/106381525-aff66100-63fc-11eb-878f-724b1f26b387.png",
    "last_modified": "2022-11-27T05:11:01+00:00",
    "input_file": {}
  }
]
